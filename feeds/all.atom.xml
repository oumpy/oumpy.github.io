<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>大阪大学医学部 Python会</title><link href="http://oumpy.github.io/" rel="alternate"></link><link href="http://oumpy.github.io%5Cfeeds/all.atom.xml" rel="self"></link><id>http://oumpy.github.io/</id><updated>2020-03-21T00:00:00+09:00</updated><subtitle>Now is better than never.</subtitle><entry><title>Webサイトをリニューアルしました！</title><link href="http://oumpy.github.io%5Carticles/2020/03/website_renewal.html" rel="alternate"></link><published>2020-03-21T00:00:00+09:00</published><updated>2020-03-21T00:00:00+09:00</updated><author><name>Python会</name></author><id>tag:oumpy.github.io\articles,2020-03-21:/2020/03/website_renewal.html</id><summary type="html">&lt;p&gt;Python会のWebサイトと技術ブログがリニューアルしました。&lt;/p&gt;
&lt;p&gt;第一編　総則
第一章　通則
（国内犯）
第一条　この法律は、日本国内において罪を犯したすべての者に適用する。
２　日本国外にある日本船舶又は日本航空機内において罪を犯した者についても、前項と同様とする。
（すべての者の国外犯）
第二条　この法律は、日本国外において次に掲げる罪を犯したすべての者に適用する。
一　削除
二　第七十七条から第七十九条まで（内乱、予備及び陰謀、内乱等幇助）の罪
三　第八十一条（外患誘致）、第八十二条（外患援助）、第八十七条（未遂罪）及び第八十八条（予備及び陰謀）の罪
四　第百四十八条（通貨偽造及び行使等）の罪及びその未遂罪
五　第百五十四条（詔書偽造等）、第百五十五条（公文書偽造等）、第百五十七条（公正証書原本不実記載等）、第百五十八条（偽造公文書行使等）及び公務所又は公務員によって作られるべき電磁的記録に係る第百六十一条の二（電磁的記録不正作出及び供用）の罪 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Python会のWebサイトと技術ブログがリニューアルしました。&lt;/p&gt;
&lt;p&gt;第一編　総則
第一章　通則
（国内犯）
第一条　この法律は、日本国内において罪を犯したすべての者に適用する。
２　日本国外にある日本船舶又は日本航空機内において罪を犯した者についても、前項と同様とする。
（すべての者の国外犯）
第二条　この法律は、日本国外において次に掲げる罪を犯したすべての者に適用する。
一　削除
二　第七十七条から第七十九条まで（内乱、予備及び陰謀、内乱等幇助）の罪
三　第八十一条（外患誘致）、第八十二条（外患援助）、第八十七条（未遂罪）及び第八十八条（予備及び陰謀）の罪
四　第百四十八条（通貨偽造及び行使等）の罪及びその未遂罪
五　第百五十四条（詔書偽造等）、第百五十五条（公文書偽造等）、第百五十七条（公正証書原本不実記載等）、第百五十八条（偽造公文書行使等）及び公務所又は公務員によって作られるべき電磁的記録に係る第百六十一条の二（電磁的記録不正作出及び供用）の罪
六　第百六十二条（有価証券偽造等）及び第百六十三条（偽造有価証券行使等）の罪
七　第百六十三条の二から第百六十三条の五まで（支払用カード電磁的記録不正作出等、不正電磁的記録カード所持、支払用カード電磁的記録不正作出準備、未遂罪）の罪
八　第百六十四条から第百六十六条まで（御璽偽造及び不正使用等、公印偽造及び不正使用等、公記号偽造及び不正使用等）の罪並びに第百六十四条第二項、第百六十五条第二項及び第百六十六条第二項の罪の未遂罪
（国民の国外犯）
第三条　この法律は、日本国外において次に掲げる罪を犯した日本国民に適用する。
一　第百八条（現住建造物等放火）及び第百九条第一項（非現住建造物等放火）の罪、これらの規定の例により処断すべき罪並びにこれらの罪の未遂罪
二　第百十九条（現住建造物等浸害）の罪
三　第百五十九条から第百六十一条まで（私文書偽造等、虚偽診断書等作成、偽造私文書等行使）及び前条第五号に規定する電磁的記録以外の電磁的記録に係る第百六十一条の二の罪
四　第百六十七条（私印偽造及び不正使用等）の罪及び同条第二項の罪の未遂罪
五　第百七十六条から第百八十一条まで（強制わいせつ、強制性交等、準強制わいせつ及び準強制性交等、監護者わいせつ及び監護者性交等、未遂罪、強制わいせつ等致死傷）及び第百八十四条（重婚）の罪
六　第百九十八条（贈賄）の罪
七　第百九十九条（殺人）の罪及びその未遂罪
八　第二百四条（傷害）及び第二百五条（傷害致死）の罪
九　第二百十四条から第二百十六条まで（業務上堕胎及び同致死傷、不同意堕胎、不同意堕胎致死傷）の罪
十　第二百十八条（保護責任者遺棄等）の罪及び同条の罪に係る第二百十九条（遺棄等致死傷）の罪
十一　第二百二十条（逮捕及び監禁）及び第二百二十一条（逮捕等致死傷）の罪
十二　第二百二十四条から第二百二十八条まで（未成年者略取及び誘拐、営利目的等略取及び誘拐、身の代金目的略取等、所在国外移送目的略取及び誘拐、人身売買、被略取者等所在国外移送、被略取者引渡し等、未遂罪）の罪
十三　第二百三十条（名誉毀損）の罪
十四　第二百三十五条から第二百三十六条まで（窃盗、不動産侵奪、強盗）、第二百三十八条から第二百四十条まで（事後強盗、昏こん酔強盗、強盗致死傷）、第二百四十一条第一項及び第三項（強盗・強制性交等及び同致死）並びに第二百四十三条（未遂罪）の罪
十五　第二百四十六条から第二百五十条まで（詐欺、電子計算機使用詐欺、背任、準詐欺、恐喝、未遂罪）の罪
十六　第二百五十三条（業務上横領）の罪
十七　第二百五十六条第二項（盗品譲受け等）の罪
（国民以外の者の国外犯）
第三条の二　この法律は、日本国外において日本国民に対して次に掲げる罪を犯した日本国民以外の者に適用する。
一　第百七十六条から第百八十一条まで（強制わいせつ、強制性交等、準強制わいせつ及び準強制性交等、監護者わいせつ及び監護者性交等、未遂罪、強制わいせつ等致死傷）の罪
二　第百九十九条（殺人）の罪及びその未遂罪
三　第二百四条（傷害）及び第二百五条（傷害致死）の罪
四　第二百二十条（逮捕及び監禁）及び第二百二十一条（逮捕等致死傷）の罪
五　第二百二十四条から第二百二十八条まで（未成年者略取及び誘拐、営利目的等略取及び誘拐、身の代金目的略取等、所在国外移送目的略取及び誘拐、人身売買、被略取者等所在国外移送、被略取者引渡し等、未遂罪）の罪
六　第二百三十六条（強盗）、第二百三十八条から第二百四十条まで（事後強盗、昏酔強盗、強盗致死傷）並びに第二百四十一条第一項及び第三項（強盗・強制性交等及び同致死）の罪並びにこれらの罪（同条第一項の罪を除く。）の未遂罪
（公務員の国外犯）
第四条　この法律は、日本国外において次に掲げる罪を犯した日本国の公務員に適用する。
一　第百一条（看守者等による逃走援助）の罪及びその未遂罪
二　第百五十六条（虚偽公文書作成等）の罪
三　第百九十三条（公務員職権濫用）、第百九十五条第二項（特別公務員暴行陵虐）及び第百九十七条から第百九十七条の四まで（収賄、受託収賄及び事前収賄、第三者供賄、加重収賄及び事後収賄、あっせん収賄）の罪並びに第百九十五条第二項の罪に係る第百九十六条（特別公務員職権濫用等致死傷）の罪
（条約による国外犯）
第四条の二　第二条から前条までに規定するもののほか、この法律は、日本国外において、第二編の罪であって条約により日本国外において犯したときであっても罰すべきものとされているものを犯したすべての者に適用する。
（外国判決の効力）
第五条　外国において確定裁判を受けた者であっても、同一の行為について更に処罰することを妨げない。ただし、犯人が既に外国において言い渡された刑の全部又は一部の執行を受けたときは、刑の執行を減軽し、又は免除する。
（刑の変更）
第六条　犯罪後の法律によって刑の変更があったときは、その軽いものによる。
（定義）
第七条　この法律において「公務員」とは、国又は地方公共団体の職員その他法令により公務に従事する議員、委員その他の職員をいう。
２　この法律において「公務所」とは、官公庁その他公務員が職務を行う所をいう。
第七条の二　この法律において「電磁的記録」とは、電子的方式、磁気的方式その他人の知覚によっては認識することができない方式で作られる記録であって、電子計算機による情報処理の用に供されるものをいう。
（他の法令の罪に対する適用）
第八条　この編の規定は、他の法令の罪についても、適用する。ただし、その法令に特別の規定があるときは、この限りでない。
第二章　刑
（刑の種類）
第九条　死刑、懲役、禁錮こ、罰金、拘留及び科料を主刑とし、没収を付加刑とする。
（刑の軽重）
第十条　主刑の軽重は、前条に規定する順序による。ただし、無期の禁錮と有期の懲役とでは禁錮を重い刑とし、有期の禁錮の長期が有期の懲役の長期の二倍を超えるときも、禁錮を重い刑とする。
２　同種の刑は、長期の長いもの又は多額の多いものを重い刑とし、長期又は多額が同じであるときは、短期の長いもの又は寡額の多いものを重い刑とする。
３　二個以上の死刑又は長期若しくは多額及び短期若しくは寡額が同じである同種の刑は、犯情によってその軽重を定める。
（死刑）
第十一条　死刑は、刑事施設内において、絞首して執行する。
２　死刑の言渡しを受けた者は、その執行に至るまで刑事施設に拘置する。
（懲役）
第十二条　懲役は、無期及び有期とし、有期懲役は、一月以上二十年以下とする。
２　懲役は、刑事施設に拘置して所定の作業を行わせる。
（禁錮）
第十三条　禁錮は、無期及び有期とし、有期禁錮は、一月以上二十年以下とする。
２　禁錮は、刑事施設に拘置する。
（有期の懲役及び禁錮の加減の限度）
第十四条　死刑又は無期の懲役若しくは禁錮を減軽して有期の懲役又は禁錮とする場合においては、その長期を三十年とする。
２　有期の懲役又は禁錮を加重する場合においては三十年にまで上げることができ、これを減軽する場合においては一月未満に下げることができる。
（罰金）
第十五条　罰金は、一万円以上とする。ただし、これを減軽する場合においては、一万円未満に下げることができる。
（拘留）
第十六条　拘留は、一日以上三十日未満とし、刑事施設に拘置する。
（科料）
第十七条　科料は、千円以上一万円未満とする。
（労役場留置）
第十八条　罰金を完納することができない者は、一日以上二年以下の期間、労役場に留置する。
２　科料を完納することができない者は、一日以上三十日以下の期間、労役場に留置する。
３　罰金を併科した場合又は罰金と科料とを併科した場合における留置の期間は、三年を超えることができない。科料を併科した場合における留置の期間は、六十日を超えることができない。
４　罰金又は科料の言渡しをするときは、その言渡しとともに、罰金又は科料を完納することができない場合における留置の期間を定めて言い渡さなければならない。
５　罰金については裁判が確定した後三十日以内、科料については裁判が確定した後十日以内は、本人の承諾がなければ留置の執行をすることができない。
６　罰金又は科料の一部を納付した者についての留置の日数は、その残額を留置一日の割合に相当する金額で除して得た日数（その日数に一日未満の端数を生じるときは、これを一日とする。）とする。
（没収）
第十九条　次に掲げる物は、没収することができる。
一　犯罪行為を組成した物
二　犯罪行為の用に供し、又は供しようとした物
三　犯罪行為によって生じ、若しくはこれによって得た物又は犯罪行為の報酬として得た物
四　前号に掲げる物の対価として得た物
２　没収は、犯人以外の者に属しない物に限り、これをすることができる。ただし、犯人以外の者に属する物であっても、犯罪の後にその者が情を知って取得したものであるときは、これを没収することができる。
（追徴）
第十九条の二　前条第一項第三号又は第四号に掲げる物の全部又は一部を没収することができないときは、その価額を追徴することができる。
（没収の制限）
第二十条　拘留又は科料のみに当たる罪については、特別の規定がなければ、没収を科することができない。ただし、第十九条第一項第一号に掲げる物の没収については、この限りでない。
（未決勾こう留日数の本刑算入）
第二十一条　未決勾こう留の日数は、その全部又は一部を本刑に算入することができる。
第三章　期間計算
（期間の計算）
第二十二条　月又は年によって期間を定めたときは、暦に従って計算する。&lt;/p&gt;</content><category term="news"></category><category term="news"></category></entry><entry><title>PythonとKerasでどうぶつしょうぎ</title><link href="http://oumpy.github.io%5Carticles/2019/04/animalshogi.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/animalshogi.html</id><summary type="html"></summary><content type="html">&lt;h2 id="toc_1"&gt;はじめに&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;「どうぶつしょうぎ」&lt;/strong&gt;というゲームをご存知でしょうか。（&lt;a href="https://ja.wikipedia.org/wiki/%E3%81%A9%E3%81%86%E3%81%B6%E3%81%A4%E3%81%97%E3%82%87%E3%81%86%E3%81%8E"&gt;wikipediaの解説&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;普及・教育用のミニ将棋として考案されたもので、本将棋が盤9x9、駒8種のところを盤3x4、駒4種までコンパクトにしたものです。&lt;/p&gt;
&lt;p&gt;駒の名前もひよこ（歩）、ぞう（弱い角）、きりん（弱い飛車）、ライオン（玉）、にわとり（ひよこの成り駒＝と金）、のように、かわいいです。&lt;/p&gt;
&lt;p&gt;駒に描かれているイラストも、大変、かわいいです。&lt;/p&gt;
&lt;p&gt;ゲーム空間の規模がそこそこ小さいため、すでに随分前に&lt;a href="https://www.tanaka.ecc.u-tokyo.ac.jp/ktanaka/dobutsushogi/"&gt;完全解析もされています&lt;/a&gt;。
双方最善を尽くすと78手まで後手勝ち、だそうです。&lt;/p&gt;
&lt;p&gt;今回は、&lt;a href="https://www.nature.com/articles/nature16961"&gt;AlphaGo &lt;/a&gt;(&lt;a href="https://www.nature.com/articles/nature24270"&gt;Zero&lt;/a&gt;)を部分的に真似した深層強化学習で、PythonとKeras（初心者向けの深層学習フレームワーク）を使い、&lt;strong&gt;どうぶつしょうぎをプレイするプログラム&lt;/strong&gt;を作ってみました。&lt;/p&gt;
&lt;p&gt;ひとまず先読みは無しで、目の前の局面に対して直感的に手を選び、そこそこ強いもの、を目指します。&lt;/p&gt;
&lt;p&gt;今更な話題で研究としての価値はほぼないと思いますが、ただ論文を読むだけよりも実際に手を動かしてみると、色々とわかることもあるものです。 （たぶん。）
&lt;h2 id="toc_2"&gt;つくりかた概要&lt;/h2&gt;
「プレイするプログラム」と大層なことを書きましたが、核心部分は「与えられた局面に対して次の指し手を返す」、これだけです。&lt;/p&gt;
&lt;p&gt;この部分を、深層ニューラルネットワーク「だけ」で作ります。&lt;/p&gt;
&lt;p&gt;実はこれ、&lt;strong&gt;画像カテゴリ認識と殆ど同じ&lt;/strong&gt;です。
例えば手書き数字認識と対比すると、数字画像の代わりに局面データ、0-9の代わりに何番目の指し手か、が対応します。&lt;/p&gt;
&lt;p&gt;入力として局面を与え、各指し手のスコア（指す確率）を出力する、順伝搬型の深層ネットワークを作ればいいわけです。
&lt;h2 id="toc_3"&gt;ネットワーク構成&lt;/h2&gt;
&lt;h3 id="toc_4"&gt;入力：盤面と持駒の表現&lt;/h3&gt;
どうぶつしょうぎの盤面は3x4。各マスを考えるとそれぞれ11通りの状態がありえます。
（駒が成駒含めて5種類、自分と相手の駒があり、空白マスとあわせて5x2+1=11です。）&lt;/p&gt;
&lt;p&gt;なので、盤面はサイズ(3,4,11)の3次元整数配列として与えましょう。
各マスで11チャネルのうち1つだけが1、残りは0をとるようにします。&lt;/p&gt;
&lt;p&gt;次に持駒ですが、持駒になるのはひよこ、ぞう、きりんの3種のみ。各最大2枚。&lt;/p&gt;
&lt;p&gt;こちらは(2,3,2)の3次元配列とします。次元は順に、自分か相手か、駒の種類、持駒の1枚目または2枚目、を表し、値はいずれも0または1です。&lt;/p&gt;
&lt;p&gt;入力は合わせて144ノード。ちょっと冗長すぎる気はしますが、ひとまず気にせず進めましょう。
&lt;h3 id="toc_5"&gt;出力：可能な指し手を網羅する&lt;/h3&gt;
どうぶつしょうぎの指し手は、(1)駒の移動、(2)駒打ち、の2種類があります。&lt;/p&gt;
&lt;p&gt;これらは任意の局面に対して、&lt;/p&gt;
&lt;p&gt;(1)「動かす駒の位置」「移動後の位置」「成るか、成らないか」&lt;/p&gt;
&lt;p&gt;(2)「打つ駒の種類」「打つ位置」&lt;/p&gt;
&lt;p&gt;を与えると一意に決められます。&lt;/p&gt;
&lt;p&gt;一番強い駒であるライオンでも、盤の端から端まで一手で移動などはできないため、(1)には制限があります。実際に合法でありうる動きは61通り。(2)は単純に、打てる駒3種（ひよこ、ぞう、きりん）と打ち場所3x4で36通り。&lt;/p&gt;
&lt;p&gt;合わせて&lt;strong&gt;合法手の可能性は97通り&lt;/strong&gt;です。
ですからネットワークは、&lt;strong&gt;97ノードのソフトマックスを出力とすればよい&lt;/strong&gt;ことになります。
&lt;h3 id="toc_6"&gt;今回使ったネットワーク&lt;/h3&gt;
入力と出力が決まったので、あとは工夫しだい。
今回は適当に、こんなネットワークでやってみます。
&lt;div&gt;
&lt;pre&gt;&lt;code class="language-none"&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;__
Layer (type)                     Output Shape          Param #     Connected to                   &lt;br&gt;
====================================================================================================
input_1 (InputLayer)             (None, 3, 4, 11)      0                                            &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;input_2 (InputLayer)            (None, 2, 3, 2)       0                                            &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;flatten_1 (Flatten)              (None, 132)           0           input_1[0][0]                    &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;flatten_2 (Flatten)             (None, 12)            0           input_2[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;concatenate_1 (Concatenate)      (None, 144)           0           flatten_1[0][0]                &lt;br&gt;
                                                                   flatten_2[0][0]                 &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_1 (Dense)                 (None, 128)           18560       concatenate_1[0][0]              &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_2 (Dense)                 (None, 128)           16512       dense_1[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_3 (Dense)                 (None, 128)           16512       dense_2[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_4 (Dense)                 (None, 128)           16512       dense_3[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_5 (Dense)                 (None, 128)           16512       dense_4[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;dense_6 (Dense)                 (None, 128)           16512       dense_5[0][0]                   &lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;dense_7 (Dense)                 (None, 97)            12513       dense_6[0][0]&lt;/h1&gt;
&lt;p&gt;Total params: 113,633
Trainable params: 113,633
Non-trainable params: 0
&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;&lt;/strong&gt;__&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
input_1とinput_2がそれぞれ盤面と持駒の入力です。中間層6層、活性化関数は途中全てReLU、最後はsoftmax。パラメータ数は11万余り。&lt;/p&gt;
&lt;p&gt;盤が小さいので、畳み込みも使わず全て全結合にしています。本将棋に拡張する場合は、畳み込みを使った方がいいでしょう。
&lt;h2 id="toc_7"&gt;強化学習：自己対戦と指し手評価&lt;/h2&gt;
さて、ようやく本番の学習。基本は、自己対戦の結果による指し手評価です。&lt;/p&gt;
&lt;p&gt;そのためには、&lt;strong&gt;審判・履歴機能付きのどうぶつしょうぎ盤セット&lt;/strong&gt;をPythonのクラスとして実装することが必要です。実は全体の中でここが一番面倒なのですが、別に面白くはないので割愛。数時間頑張れば、動くものは作れます。そう、Pythonならね。&lt;/p&gt;
&lt;p&gt;自己対戦学習は多少試行錯誤して、いくつか工夫しました。これが良いかはよくわかりませんが。
&lt;ul&gt;
    &lt;li&gt;初期配置からいきなり自己対戦するのではなく、勝負がつかない範囲でランダムに数手〜数十手進めた局面から開始。&lt;/li&gt;
    &lt;li&gt;出力中の反則手は無視し、合法手の中で、スコアに比例した確率で指す。&lt;/li&gt;
    &lt;li&gt;自己対戦の終局後、勝者側の指し手全てを教師信号としてネットワークを学習する。&lt;/li&gt;
    &lt;li&gt;敗者側の指し手は無視し、減点しない。また反則スコアが高くても減点しない。（褒めて伸ばす。初期局面が敗勢だとどうしようもないから、という理由もあり。）&lt;/li&gt;
&lt;/ul&gt;
今回は2^17局の自己対戦を行い、終局ごとに学習させました。1局あたりの平均手数は20手、このうち勝者側のみを学習するので、延べ130万局面程度を学習したことになります。&lt;/p&gt;
&lt;p&gt;計算は全てノートPC上で行い、計算時間は45分程度でした。
&lt;h2 id="toc_8"&gt;学習結果&lt;/h2&gt;
&lt;h3 id="toc_9"&gt;ルールの習得&lt;/h3&gt;
まず、学習したネットワークはどうぶつしょうぎのルール（合法手の規則）をどれくらい学んでいるのか？を検証してみます。&lt;/p&gt;
&lt;p&gt;ランダムに指して生成した局面で、ルールの制限を外して自由に指させてみたところ、じつに&lt;strong&gt;合法手が98.7%&lt;/strong&gt;となりました。1.3%の指し手が反則です。&lt;/p&gt;
&lt;p&gt;これら局面での合法手は、平均して局面あたり6.5手程度しかありません。97手からランダムに指せば殆どが反則、合法手は7%にも満たないはず。&lt;/p&gt;
&lt;p&gt;ルールについてはかなり良く習得してきていることがわかります。
&lt;h3 id="toc_10"&gt;どれくらい強い？&lt;/h3&gt;
自分で対戦してみたいところなのですが、インターフェースを作っていないのと客観性のため、学習前のランダムなネットワークと対戦させてみます。揺らぎが1%程度未満になるように、2^14局連続で対戦。先手後手はランダムです。&lt;/p&gt;
&lt;p&gt;結果は、、、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勝率 53% !!!!!!&lt;/strong&gt; (´･ω･`)&lt;/p&gt;
&lt;p&gt;んと、、、まず、この数字は十分に有意であるといえます（ｷﾘｯ）。&lt;/p&gt;
&lt;p&gt;ランダムに指すのと比べて、確実に強いです。&lt;/p&gt;
&lt;p&gt;しかし、、この程度では、まだ人間と勝負できるレベルでないことも明らかでしょう。&lt;/p&gt;
&lt;p&gt;原因についてはネットワーク設計に問題がある可能性もありますが、おそらく学習量が全然足りないのだと思われます。&lt;/p&gt;
&lt;p&gt;強化学習の成長はゆっくりで、少しづつ高度な好手を順番に見出していく必要があります。&lt;/p&gt;
&lt;p&gt;例えばまず最初に、ライオンが取れるときは取るのが好手だ、ということを学ぶ。すると、駒が多いとライオンを取れる機会も増えるので、駒を取るのがいいことを学ぶ。多分まだ、最初の段階の途中くらいと想像できます。&lt;/p&gt;
&lt;p&gt;そういうことを考えると、130万局面を評価した段階での勝率53%は、それなりに納得できる数字かもしれません。&lt;/p&gt;
&lt;p&gt;今回はノートPC上で1時間足らずの学習なので、また時間ができたらもっと大規模にやってみたいと思います。
自己対戦部分をCythonで高速化して、GPUサーバ上で学習するとか。&lt;/p&gt;
&lt;p&gt;ひとまず今回はここまで。おしまい。
&lt;h3 id="toc_11"&gt;追記1&lt;/h3&gt;
強化学習をさらに2倍、総計2^18局の自己対戦まで行わせたところ、合法手率86.0%、学習前ネットワークに対する勝率51.7%までそれぞれ暴落。何が起こっているのか、やっぱりよくわかりません。学習方法をもう少し検討するとか、あとはやはりもっと計算資源を投入する必要はありそうですかね。
&lt;h3 id="toc_12"&gt;追記2&lt;/h3&gt;
強化学習の方法についてですが、碁と将棋の違いとして、特に棋力が低い場合、将棋では終盤（終局間際）の指し手が勝敗に圧倒的に重要、ということがあるかもしれません。&lt;/p&gt;
&lt;p&gt;今の場合、最初はライオン取りを学ぶことが必要なのですが、最後にライオンを取るまでにライオン取りを見逃した手なども教師信号になってしまいます。&lt;/p&gt;
&lt;p&gt;最初は最終手だけ学ぶなどと人為的に重みをいじった方が、今のレベルでは良い結果が出るかも。王道は、マシンパワーの力尽くなのでしょうが。。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>AtCoder Beginners Selection 雑感</title><link href="http://oumpy.github.io%5Carticles/2019/04/atcoder.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>Python会</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/atcoder.html</id><summary type="html"></summary><content type="html">&lt;section class="pdf_page" aria-label="Page 1"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;プログラミング初心者の加藤です。勉強会の時に、とりあえずやってみたらいいよと言われたので、&lt;/div&gt;
&lt;div&gt;よく分からないままやってみました。その概要と雑感です。&lt;/div&gt;
&lt;h2&gt;・AtCoderとは？&lt;/h2&gt;
&lt;div&gt;まず始めにAtCoderの説明から。AtCoderとは、オンライン上で競技プログラミングのコンテストを提供しているサイトのことです(https://atcoder.jp/?lang=ja)。&lt;/div&gt;
&lt;div&gt;定期的にコンテストを主催していたり、企業から(広告や人材獲得戦略の一環として)&lt;/div&gt;
&lt;div&gt;コンテストが開かれることもあります。&lt;/div&gt;
&lt;div&gt;コンテストに参加する以外にも、コンテストで使用された問題を解くこともでき、初心者でも、「プログラミング勉強したいけど本をなぞるだけじゃつまらない！」っていう僕みたいなわがままな人にはちょうどいいモチベーションアッパーになると思います。&lt;/div&gt;
&lt;h2&gt;・AtCoder Beginners Selectionを解こう！&lt;/h2&gt;
&lt;div&gt;チュートリアルを読むと、「何をすれば良いか分からない人は、AtCoder Beginners Selection&lt;/div&gt;
&lt;div&gt;から、まずいくつかの問題を解いてみましょう。」と書いてあります。ページに飛んでみると、さらに、「このコンテストは、『AtCoderに登録したけど何をしていいか分からない・・・！』という人に向けて作られた初心者向け問題集です。」とも書いてます。&lt;/div&gt;
&lt;div&gt;何も分かってない子羊ちゃんは素直に優しい言葉に付いて行くのでした。&lt;/div&gt;
&lt;div&gt;以下いくつかの問題をピックアップしてみます。&lt;/div&gt;
&lt;h3&gt;・問題０：はじめてのあっとこーだー&lt;/h3&gt;
&lt;div&gt;わざわざ平仮名で表記しちゃってまあどんな接待をしてくれるのやら...。問題文を読みます。&amp;lt;/
&lt;div&gt;問題文&lt;/div&gt;
&lt;div&gt;高橋君はデータの加工が行いたいです。&lt;/div&gt;
&lt;div&gt;整数 a,b,cと、文字列 s が与えられます。&lt;/div&gt;
&lt;div&gt;整数 a+b+c と、文字列 s を並べて表示しなさい。&lt;/div&gt;
&lt;div&gt;入力&lt;/div&gt;
&lt;div&gt;入力は次の形式で与えられる。&lt;/div&gt;
&lt;div&gt;a&lt;/div&gt;
&lt;div&gt;b c&lt;/div&gt;
&lt;div&gt;　s&lt;/div&gt;
&lt;div&gt;1 行目は、整数 a (1≦a≦1,000) が与えられる。&lt;/div&gt;
&lt;div&gt;2 行目は、整数 b,c (1≦b,c≦1,000) が与えられる。&lt;/div&gt;
&lt;div&gt;3 行目は、文字列 s が与えられる。この文字列の長さは 1文字以上&lt;/div&gt;
&lt;div&gt;100文字以下であ&lt;/div&gt;
&lt;div&gt;る。&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;

&lt;section class="pdf_page" aria-label="Page 2"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;ん？&lt;/div&gt;
&lt;div&gt;入力ってなんだ？(競プロ初心者並感)&lt;/div&gt;
&lt;div&gt;いや入力はinputを使えばいい、でも「b c」はどうやって入力するんだ？(Python初心者並感)&lt;/div&gt;
&lt;div&gt;そもそも複数行の入力ってどうするんだ？(プログラミング初心者並感)&lt;/div&gt;
&lt;div&gt;......(思考停止)&lt;/div&gt;
&lt;div&gt;数問解いた後の話ですが、気付きました。&lt;/div&gt;
&lt;div&gt;ああこれが競技プログラミングなのか。&lt;/div&gt;
&lt;div&gt;あれです、初心者あるあるの「思ってたのと違う」ってやつです。今回のは悪い意味ではないので&lt;/div&gt;
&lt;div&gt;すが。&lt;/div&gt;
&lt;div&gt;言語つながりで、例えば英語の問題なら、文法や読解、和文英訳など受験でさんざんやった形式&lt;/div&gt;
&lt;div&gt;のものが思い浮かびます。てっきりそういう類いの問題が出るのかなと思っていたら、完全に実&lt;/div&gt;
&lt;div&gt;践形式の問題で驚きました。英語始めたばっかりで、いきなり英会話しようと言われたら誰だっ&lt;/div&gt;
&lt;div&gt;てそうなるでしょう。&lt;/div&gt;
&lt;div&gt;このように競技プログラミングでは答えが決まってはなく、かなりのバリエーションがあり、独&lt;/div&gt;
&lt;div&gt;自に考えたプログラムが答えになり得るというのが面白みの一つですね。また、同じ方針でも表&lt;/div&gt;
&lt;div&gt;記の仕方がたくさんあって、まるで方言のようです。&lt;/div&gt;
&lt;div&gt;まとめっぽくなりましたが問題に戻ります。&lt;/div&gt;
&lt;div&gt;考えても分かる訳なさそうなので、この問題にだけついている解答例を見ます。&lt;/div&gt;
&lt;div&gt;いまさらですが言語はPython3です。&lt;/div&gt;
&lt;div&gt;なるほど、入力が複数行に分かれているのは文字列にエンターが含まれているからなのか、input&lt;/div&gt;
&lt;div&gt;１回だけで全て読み込めるのではないのだな。行が分かれているというのは本質的ではなく、入&lt;/div&gt;
&lt;div&gt;力をそのまま表示した結果なのか。いつものインタプリタと同じだ。というのがこの問題で一番&lt;/div&gt;
&lt;div&gt;印象に残った事です。&lt;/div&gt;
&lt;div&gt;map&lt;/div&gt;
&lt;div&gt;とかフォーマットとか、多分見るのが２ヶ月ぶりとかで、ああそういえばそんなのあったな&lt;/div&gt;
&lt;div&gt;状態です。&lt;/div&gt;
&lt;div&gt;1.&lt;/div&gt;
&lt;div&gt;a = int(input())&lt;/div&gt;
&lt;div&gt;2.&lt;/div&gt;
&lt;div&gt;b, c = map(int, input().split())&lt;/div&gt;
&lt;div&gt;3.&lt;/div&gt;
&lt;div&gt;s = input()&lt;/div&gt;
&lt;div&gt;4.&lt;/div&gt;
&lt;div&gt;print(“{} {}”.format(a+b+c, s))&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;

&lt;section class="pdf_page" aria-label="Page 3"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;・問題４：Coins&lt;/div&gt;
&lt;div&gt;コンピューターっぽくて印象的な問題です。&lt;/div&gt;
&lt;div&gt;よくみる整数問題ですね。これは簡単に解けると思いきや...？&lt;/div&gt;
&lt;div&gt;こういう問題は受験数学的にはパパッと場合分けが浮かびますが、その条件分けを実装するのは&lt;/div&gt;
&lt;div&gt;面倒です。そう、受験問題では入力が１つだけですが、競技プログラミングでは複数の入力がな&lt;/div&gt;
&lt;div&gt;されるため、全ての場合分けに対応しないといけません。できないことはないですが、正直言っ&lt;/div&gt;
&lt;div&gt;てかなり面倒です。&lt;/div&gt;
&lt;div&gt;(&lt;/div&gt;
&lt;div&gt;http://delta114514.hatenablog.jp/entry/2018/03/15/014555&lt;/div&gt;
&lt;div&gt;　より引用)&lt;/div&gt;
&lt;div&gt;問題文&lt;/div&gt;
&lt;div&gt;あなたは、500円玉をA枚、100円玉をB枚、50円玉をC枚持っています。これらの硬貨&lt;/div&gt;
&lt;div&gt;の中から何枚かを選び、合計金額をちょうどX&lt;/div&gt;
&lt;div&gt;円にする方法は何通りありますか。&lt;/div&gt;
&lt;div&gt;同じ種類の硬貨同士は区別できません。２通りの硬貨の選び方は、ある種類の硬貨につ&lt;/div&gt;
&lt;div&gt;いてその硬貨を選ぶ枚数が異なるとき区別されます。&lt;/div&gt;
&lt;div&gt;制約&lt;/div&gt;
&lt;div&gt;0&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;A,B,C&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;50&lt;/div&gt;
&lt;div&gt;A+B+C&lt;/div&gt;
&lt;div&gt;≥&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;50&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;X&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;20,000&lt;/div&gt;
&lt;div&gt;A,B,C は整数である&lt;/div&gt;
&lt;div&gt;Xは50の倍数である&lt;/div&gt;
&lt;div&gt;入力&lt;/div&gt;
&lt;div&gt;入力は以下の形式で標準入力から与えられる。&lt;/div&gt;
&lt;div&gt;　A&lt;/div&gt;
&lt;div&gt;　B&lt;/div&gt;
&lt;div&gt;　C&lt;/div&gt;
&lt;div&gt;　X&lt;/div&gt;
&lt;div&gt;出力&lt;/div&gt;
&lt;div&gt;硬貨を選ぶ方法の個数を出力せよ。&lt;/div&gt;
&lt;div&gt;1.&lt;/div&gt;
&lt;div&gt;a, b, c, x = map(int, [input() for i in range(4)])&lt;/div&gt;
&lt;div&gt;2.&lt;/div&gt;
&lt;div&gt;ans = 0&lt;/div&gt;
&lt;div&gt;3.&lt;/div&gt;
&lt;div&gt;for i in range(a+1):&lt;/div&gt;
&lt;div&gt;4.&lt;/div&gt;
&lt;div&gt;for j in range(b+1):&lt;/div&gt;
&lt;div&gt;5.&lt;/div&gt;
&lt;div&gt;for k in range(c+1):&lt;/div&gt;
&lt;div&gt;6.&lt;/div&gt;
&lt;div&gt;if i * 500 + j * 100 + k * 50 == x:&lt;/div&gt;
&lt;div&gt;7.&lt;/div&gt;
&lt;div&gt;ans += 1&lt;/div&gt;
&lt;div&gt;8.&lt;/div&gt;
&lt;div&gt;print&lt;/div&gt;
&lt;div&gt;(ans)&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;

&lt;section class="pdf_page" aria-label="Page 4"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;しばらく場合分けを考えていましたが、ギブアップして答えを検索。ABS&lt;/div&gt;
&lt;div&gt;は有名らしく色んな人&lt;/div&gt;
&lt;div&gt;が色んな言語で解答をあげています。&lt;/div&gt;
&lt;div&gt;このコードはつまるところ、総当たりをして条件を満たすものをカウントしてるんですね。&lt;/div&gt;
&lt;div&gt;なるほど！ヒトが計算するならこんな面倒なことはしないけれどコンピューターならできる。はっ&lt;/div&gt;
&lt;div&gt;としました。&lt;/div&gt;
&lt;div&gt;・問題７：Kagami Mochi&lt;/div&gt;
&lt;div&gt;：普通の解法&lt;/div&gt;
&lt;div&gt;(&lt;/div&gt;
&lt;div&gt;http://delta114514.hatenablog.jp/entry/2018/03/15/014555&lt;/div&gt;
&lt;div&gt;　より引用)&lt;/div&gt;
&lt;div&gt;入力をリストにしてからセットにして要素数を数える。当然ですね。&lt;/div&gt;
&lt;div&gt;僕はセットの存在を思い出せなかったので、次のようにしました。&lt;/div&gt;
&lt;div&gt;問題文&lt;/div&gt;
&lt;div&gt;X段重ねの鏡餅(X&lt;/div&gt;
&lt;div&gt;≥&lt;/div&gt;
&lt;div&gt;1) とはX枚の円形の餅を縦に積み重ねたものであって、どの餅もそ&lt;/div&gt;
&lt;div&gt;の真下の餅より直径が小さい（一番下の餅を除く）もののことです。例えば、直径10、&lt;/div&gt;
&lt;div&gt;8、6センチメートルの餅をこの順に下から積み重ねると 3 段重ねの鏡餅になり、餅を&lt;/div&gt;
&lt;div&gt;一枚だけ置くと 1 段重ねの鏡餅になります。&lt;/div&gt;
&lt;div&gt;ダックスフンドのルンルンはN枚の円形の餅を持っていて、そのうち i 枚目の餅の直径は&lt;/div&gt;
&lt;div&gt;diセンチメートルです。これらの餅のうち一部または全部を使って鏡餅を作るとき、最&lt;/div&gt;
&lt;div&gt;大で何段重ねの鏡餅を作ることができるでしょうか。&lt;/div&gt;
&lt;div&gt;制約&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;N&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;100&lt;/div&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;di&lt;/div&gt;
&lt;div&gt;≤&lt;/div&gt;
&lt;div&gt;100&lt;/div&gt;
&lt;div&gt;入力値は全て整数である。&lt;/div&gt;
&lt;div&gt;入力&lt;/div&gt;
&lt;div&gt;入力は以下の形式で標準入力から与えられる。&lt;/div&gt;
&lt;div&gt;　N&lt;/div&gt;
&lt;div&gt;d1&lt;/div&gt;
&lt;div&gt;　：&lt;/div&gt;
&lt;div&gt;dN&lt;/div&gt;
&lt;div&gt;出力&lt;/div&gt;
&lt;div&gt;作ることのできる鏡餅の最大の段数を出力せよ。&lt;/div&gt;
&lt;div&gt;1.&lt;/div&gt;
&lt;div&gt;n = int(input())&lt;/div&gt;
&lt;div&gt;2.&lt;/div&gt;
&lt;div&gt;print(len(set(map(int, [input() for i in range(n)]))))&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;

&lt;section class="pdf_page" aria-label="Page 5"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;：僕の解法&lt;/div&gt;
&lt;div&gt;ソートしてからリストのままでなんとか数えあげました。&lt;/div&gt;
&lt;div&gt;明らかに汚いですね。長いですし、n=1&lt;/div&gt;
&lt;div&gt;で場合分けしてますし。こんな初心者じみた答えでも合っ&lt;/div&gt;
&lt;div&gt;てたらいいんです。&lt;/div&gt;
&lt;div&gt;・問題９：Daydream&lt;/div&gt;
&lt;div&gt;問題文の通りに、後ろから４単語のどれかを検索していくのが一番わかりやすいと思われます。が、&lt;/div&gt;
&lt;div&gt;わざわざerase&lt;/div&gt;
&lt;div&gt;という単語を選んできたということは、こういうことでしょう。&lt;/div&gt;
&lt;div&gt;僕の解法：&lt;/div&gt;
&lt;div&gt;1.&lt;/div&gt;
&lt;div&gt;n = int(input())&lt;/div&gt;
&lt;div&gt;2.&lt;/div&gt;
&lt;div&gt;a = sorted(list(map(int, [input() for i in range(n)])))&lt;/div&gt;
&lt;div&gt;3.&lt;/div&gt;
&lt;div&gt;ans = 1&lt;/div&gt;
&lt;div&gt;4.&lt;/div&gt;
&lt;div&gt;if n != 1:&lt;/div&gt;
&lt;div&gt;5.&lt;/div&gt;
&lt;div&gt;for i in range(n-1):&lt;/div&gt;
&lt;div&gt;6.&lt;/div&gt;
&lt;div&gt;if a[i] &amp;lt; a[i+1]:&lt;/div&gt;
&lt;div&gt;7.&lt;/div&gt;
&lt;div&gt;ans += 1&lt;/div&gt;
&lt;div&gt;8.&lt;/div&gt;
&lt;div&gt;print(ans)&lt;/div&gt;
&lt;div&gt;問題文&lt;/div&gt;
&lt;div&gt;英小文字からなる文字列 S が与えられます。 Tが空文字列である状態から始め、以下の&lt;/div&gt;
&lt;div&gt;操作を好きな回数繰り返すことで S=T とすることができるか判定してください。&lt;/div&gt;
&lt;div&gt;Tの末尾にdream dreamer erase eraser のいずれかを追加する。&lt;/div&gt;
&lt;div&gt;制約&lt;/div&gt;
&lt;div&gt;1≦|S|≦105&lt;/div&gt;
&lt;div&gt;Sは英小文字からなる。&lt;/div&gt;
&lt;div&gt;入力&lt;/div&gt;
&lt;div&gt;入力は以下の形式で標準入力から与えられる。&lt;/div&gt;
&lt;div&gt;S&lt;/div&gt;
&lt;div&gt;出力&lt;/div&gt;
&lt;div&gt;S&lt;/div&gt;
&lt;div&gt;=Tとすることができる場合YESを、そうでない場合NOを出力せよ。&lt;/div&gt;
&lt;div&gt;1.&lt;/div&gt;
&lt;div&gt;s = input()&lt;/div&gt;
&lt;div&gt;2.&lt;/div&gt;
&lt;div&gt;a=s.replace("eraser"," ")&lt;/div&gt;
&lt;div&gt;3.&lt;/div&gt;
&lt;div&gt;b=a.replace("erase"," ")&lt;/div&gt;
&lt;div&gt;4.&lt;/div&gt;
&lt;div&gt;c=b.replace("dreamer"," ")&lt;/div&gt;
&lt;div&gt;5.&lt;/div&gt;
&lt;div&gt;d=c.replace("dream"," ")&lt;/div&gt;
&lt;div&gt;6.&lt;/div&gt;
&lt;div&gt;if d.strip() == "":&lt;/div&gt;
&lt;div&gt;7.&lt;/div&gt;
&lt;div&gt;print("YES")&lt;/div&gt;
&lt;div&gt;8.&lt;/div&gt;
&lt;div&gt;else:&lt;/div&gt;
&lt;div&gt;9.&lt;/div&gt;
&lt;div&gt;print("NO")&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;

&lt;section class="pdf_page" aria-label="Page 6"&gt;
&lt;div class="textlayer"&gt;
&lt;div&gt;文字列の後ろからだけでなく、途中から抜いても、抜く単語の順番をうまく決めれば問題ないは&lt;/div&gt;
&lt;div&gt;ずです。&lt;/div&gt;
&lt;div&gt;変数をいちいち置いているのが恥ずかしいですが、通ればいいんです。&lt;/div&gt;
&lt;div&gt;別解答：&lt;/div&gt;
&lt;div&gt;(&lt;/div&gt;
&lt;div&gt;http://delta114514.hatenablog.jp/entry/2018/03/15/014555&lt;/div&gt;
&lt;div&gt;　より引用)&lt;/div&gt;
&lt;div&gt;通ればなんでもいいはずなんですが、これはどうでしょう。&lt;/div&gt;
&lt;div&gt;この解答例だと、”d erase r erase e erase a erase m” という文字列(スペースは抜いてくださ&lt;/div&gt;
&lt;div&gt;い)もYESになってしまうはずなのですが、試しにこのコードを提出してみるとacceptされました。&lt;/div&gt;
&lt;div&gt;(嘘解法なんでしょうか？にしては同じような答えを書いてる人が大勢います。)&lt;/div&gt;
&lt;div&gt;・初学者にとっての競技プログラミング&lt;/div&gt;
&lt;div&gt;解いてみた感想ですが、やはり考えるのは楽しいです。久々に数学的な頭の使い方をして懐かしさ&lt;/div&gt;
&lt;div&gt;も覚えました。&lt;/div&gt;
&lt;div&gt;また、何より、競技プログラミングは初学者にかなり便利なものだと感じました。&lt;/div&gt;
&lt;div&gt;ほんとに基礎的な部分しか学習してなくても解けるというのは取り組みやすいですし、結果がだ&lt;/div&gt;
&lt;div&gt;せることは嬉しいです。過去問ならネット上にたくさん解説があるのでつまってもなんとかなりま&lt;/div&gt;
&lt;div&gt;す。&lt;/div&gt;
&lt;div&gt;他の人のコードを見ることができ、考え方の幅も広がります。上手く書けなかったコードを見直&lt;/div&gt;
&lt;div&gt;したり、異なった方針で書かれたコードを見るのはいい刺激になります。&lt;/div&gt;
&lt;div&gt;特に基礎の文法に慣れるという点では一番だと思います。基礎を洗練させることは必ずこの先モ&lt;/div&gt;
&lt;div&gt;ジュールやパッケージを使っていくにしても、理解して扱えることができ役に立つことでしょう。&lt;/div&gt;
&lt;div&gt;もちろん万能ではありません。競技プログラミングの内容はプログラミング一般から見て偏って&lt;/div&gt;
&lt;div&gt;いるらしいです。「競技プログラミング　デメリット」で調べると批判がたくさん出てきます。&lt;/div&gt;
&lt;div&gt;でも少なくともPython&lt;/div&gt;
&lt;div&gt;会に入ってる初心者の人は、ソフト開発のような能力ではなく、プログラ&lt;/div&gt;
&lt;div&gt;ミングをツールとして扱える能力を求めている人がほとんどでしょうから、うってつけの教材だ&lt;/div&gt;
&lt;div&gt;と思います。&lt;/div&gt;
&lt;div&gt;簡単なブロック崩しのゲームを作ったことがありますが、今回の方がよっぽど練習になりました。&lt;/div&gt;
&lt;div&gt;もし興味があれば皆さんも是非試してみてください。&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;</content><category term="tech_archive"></category><category term="atcoder"></category></entry><entry><title>ベイズ流T検定 BEST</title><link href="http://oumpy.github.io%5Carticles/2019/04/bayesian_T_test.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/bayesian_T_test.html</id><summary type="html"></summary><content type="html">&lt;p&gt;ここ最近pymcを使ったベイズ推論のことをずっと考えています。
pymc3を扱った本(http://amzn.asia/1TWcfTI)が先週発売されて買ってしまったのですが、
まだ前のpymc本(http://amzn.asia/8CPISDp)を読み切っていなかったので急いで読み切りました。
読み切った記念に一個面白そうなものがあったのでまとめました。&lt;/p&gt;
&lt;p&gt;2群の平均値に差があるかどうか比べたいというありがちな問いに対しては一般にt検定が使われます。
当分散性が言えるとき（2郡の分散が同じである確信が持てるとき）はStudent's t-testを使います。
分散については立山さんのノートを参考にどうぞ。
当分散性が言えないときは（自信がないときも保守的に）Welch's t-testを使います。
余談ですが、どちらのt-testも平均値が正規分布に従うことを仮定しているので、
その仮定が怪しいときはノンパラメトリックな検定を選びます。
まあこのへんは誰かがコード付きでまとめてくれると信じてます。&lt;/p&gt;
&lt;p&gt;このt検定ですが、ベイズ風のアレンジの論文が存在するようです。
BEST(Bayesian estimation supersedes the t-test)
というかっこいい名前です。
2群それぞれを独立にt分布に従うと仮定し、それぞれ3つのパラメーター（平均、分散、外れ値）
を推論します。つまり、6つのパラメーターを推論します。
ベイズ推論に落とし込むことで、2群それぞれの平均、分散、外れ値の解釈が容易になります。
ベイズ推論とか統計モデリングってこんなんなんやっていうのもなんとなくわかると思うので、
とりあえず下のnotebookを開いてみてください。&lt;/p&gt;
&lt;p&gt;ipynbはこちら
↓↓↓↓↓
http://nbviewer.jupyter.org/gist/yyoshiaki/255d392ae32d258cfdf19cfad855b8fb
余談に余談を重ねますが、
ipynbの公開方法はhtmlやpdfにexportしたり、いろいろありますが、
少し凝った方法で公開してみました。
githubのgistという機能を用いて、公開し、それをnbviewerに渡してみました。
スマホでもみれていいですね。
&lt;a href="http://kasoutuuka.org/jupyter-notebook"&gt;参考HP&lt;/a&gt;&lt;/p&gt;</content><category term="tech_archive"></category><category term="statistics"></category></entry><entry><title>Improving Breast Cancer Detection using Symmetry Information with Deep Learning</title><link href="http://oumpy.github.io%5Carticles/2019/04/breast_cancer_detection.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>秋山</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/breast_cancer_detection.html</id><summary type="html"></summary><content type="html">&lt;p&gt;&lt;a href="http://arxiv.org/abs/1808.08273"&gt;Improving Breast Cancer Detection using Symmetry Information with Deep Learning&lt;/a&gt;
放射線専門医がするようにマンモグラムの左右差を見て乳がんの判定をするCNNモデルを提案
arxiv 2018.08
MICCAI (医療画像解析のトップ会議) 2018 採択
1st authorは放射線科医&lt;/p&gt;
&lt;p&gt;データセット
マンモグラフィー7k症例, 正常4k, 悪性腫瘍3k
放射線専門医により腫瘍領域マスクをアノテーションした
正常乳房は2年フォローして乳がん発症が無かったことを確認
乳がん乳房は腫瘍領域を生検し悪性腫瘍であるとすべて診断されている
非公開データ&lt;/p&gt;
&lt;p&gt;前処理
従来法の画像特徴量を用いた手法で腫瘍候補点を計算 (Fig.1, 赤点)
候補点を中心に300x300 pixels (6cm x 6cm) を切り出し (Fig.1, 緑枠)
左右差を比較するために反対側の領域を切り出し (Fig.1, 青枠)
切り出した領域に腫瘍のマスク領域が含まれていれば悪性腫瘍のラベルを割り当てる&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-153" src="https://pythonoum.files.wordpress.com/2018/09/2352f582-60c8-486b-a9ec-c247787510f7.png" alt="2352f582-60c8-486b-a9ec-c247787510f7" width="857" height="567" /&gt;&lt;/p&gt;
&lt;p&gt;Fig. 1&lt;/p&gt;
&lt;p&gt;モデル
baseline model: 標準的なCNN (VGG like)
symmetry model: 候補領域とその左右対称となる領域の2画像を入力とするCNN&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-152" src="https://pythonoum.files.wordpress.com/2018/09/67ac70b1-0afe-478b-b046-a2bacb1450f8.png" alt="67ac70b1-0afe-478b-b046-a2bacb1450f8" width="1487" height="470" /&gt;&lt;/p&gt;
&lt;p&gt;結果&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-155" src="https://pythonoum.files.wordpress.com/2018/09/e382b9e382afe383aae383bce383b3e382b7e383a7e38383e38388-2018-09-25-17-28-58.png" alt="スクリーンショット 2018-09-25 17.28.58" width="1516" height="296" /&gt;
AUCがわずかに改善 (有意差なし)&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-151" src="https://pythonoum.files.wordpress.com/2018/09/6aaac880-7ac2-4425-8be3-4d78367088e2.png" alt="6aaac880-7ac2-4425-8be3-4d78367088e2" width="671" height="484" /&gt;&lt;/p&gt;
&lt;p&gt;Fig.3a
FROC曲線(偽陽性率を横軸, 感受性を縦軸) で比較すると有意に提案手法がよかった&lt;/p&gt;
&lt;p&gt;考察&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-154" src="https://pythonoum.files.wordpress.com/2018/09/ef07a0c8-ed1e-4127-b747-f9103aa6095e.png" alt="ef07a0c8-ed1e-4127-b747-f9103aa6095e" width="960" height="360" /&gt;&lt;/p&gt;
&lt;p&gt;Fig. 4
a) baseline modelが正常と誤判定し, symmetry modelが正しく悪性腫瘍と判定した画像の例 (上下の画像が同じ患者の左右の乳房)
b) baseline modelが悪性腫瘍と誤判定し, symmetry modelが正しく正常と判定した画像の例 (上下の画像が同じ患者の左右の乳房)
暗めの悪性腫瘍, 明るい正常像は誤判定しやすいがsymmetry modelは左右の比較によって正しく判定していることが読み取れる&lt;/p&gt;
&lt;p&gt;読んだ感想
性能差がちょっと微妙だけど考察の納得感はある&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>クラスター分析</title><link href="http://oumpy.github.io%5Carticles/2019/04/cluster_analysis.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>柳澤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/cluster_analysis.html</id><summary type="html"></summary><content type="html">&lt;p&gt;現在、クラスター分析の勉強をしています。
勉強し始めて数時間ですが、少しまとめてみたいと思います。&lt;/p&gt;
&lt;p&gt;簡単に言うと、クラスター分析とは異なる性質のものが混ざり合った集団から互いに似た性質を持つものを集める方法のことです。
あらかじめ分類の基準が決まっておらず分類のための外的基準や評価が与えられていない「教師無しの分類法」です。&lt;/p&gt;
&lt;p&gt;グループ分けの対象
 サンプルを分類するのか、変数を分類するのか
分類の形式（種類、生成）
 階層的方法か非階層的方法か
分類に用いる対象間の距離（類似度）
 ユークリッド距離、マハラノビス距離、コサイン距離 ・・・
クラスターの合併方法（クラスター間の距離の測定方法）
 ウォード法、群平均法、最短距離法、最長距離法・・・&lt;/p&gt;
&lt;p&gt;クラスター分類するにはここら辺を決めなくてはいけません。
特に後ろ二つが馴染みがなく難しい。。。&lt;/p&gt;
&lt;p&gt;階層的クラスタリングを可視化する代表的な方法にデンドログラムがあります。
Scikit-learnのirisデータセットで試しにやってみます。
調べたところ、scikit-learnでデンドログラム描写はできないみたいだったので、
Scipyからimportして使います。
（Scipyのクラスタリングアルゴリズムはscikit-learnのアルゴリズムを若干違うみたいです。）
上で書いた後ろ２つを以下で指定しています。
linkage_result = linkage(iris_df, method='ward', metric='euclidean')
 ：ウォード法 x ユークリッド距離&lt;/p&gt;
&lt;p&gt;縦軸がクラスタ間距離です。
setosaは綺麗に分かれますが、versicolorとvirginicaはうまく分けられていないのがわかります。なるほど。&lt;/p&gt;
&lt;p&gt;イメージング画像でクラスタリングしたいなあとか思っているんですが、
なかなかサンプル数とか特徴量の問題で難しそう。&lt;/p&gt;
&lt;p&gt;うまく特徴がつかめるような解析がしたいなあ。&lt;/p&gt;
&lt;p&gt;頑張って勉強してみます。
何かいいサイトや参考資料があったら教えてください。&lt;/p&gt;
&lt;p&gt;参考資料
https://business.nikkeibp.co.jp/atclbdt/15/258678/071500002/?ST=print&lt;/p&gt;
&lt;p&gt;クラスタリングの注意点が書かれてました。
http://www.kamishima.net/jp/clustering/&lt;/p&gt;
&lt;p&gt;Pythonではじめる機械学習 オライリー社&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>Common Workflow Language入門</title><link href="http://oumpy.github.io%5Carticles/2019/04/cwl.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/cwl.html</id><summary type="html"></summary><content type="html">&lt;p&gt;先日&lt;a href="https://github.com/manabuishii/workflow-meetup/wiki/20181126"&gt;workflow-meetup&lt;/a&gt;にお誘いを頂いて参加してきました。そこでThe Common Workflow Language(CWL)というものを習ったので忘れないうちに&lt;strong&gt;医学部生にもわかりやすく&lt;/strong&gt;まとめます。&lt;/p&gt;
&lt;h2&gt;CWLって？&lt;/h2&gt;
&lt;p&gt;&lt;img alt="cwl" src="https://github.com/common-workflow-language/cwl-website/blob/master/site/CWL-Logo-Header.png?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;一言で言うと、bioinformatics処理の自動化です。どういうことかもうちょっと詳しく見てみましょう。&lt;/p&gt;
&lt;p&gt;&amp;gt;ソフトウェアを組み合わせて構成される一連の作業手順 (ワークフロー) を記述するための仕組みや言語、GUI ソフトウェアは既に多く存在します。しかし、それらは特定の実行環境 (ハードウェア、ソフトウェア) に依存したものであり、異なる環境の間でワークフローを共有、再実行することは困難です。この問題を解決するために、異なるワークフロー実行ソフトウェア (実行エンジン) の間で共通してインポート/エクスポートできるフォーマットを目指して、Common Workflow Language (CWL) の開発が始まりました。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/pitagora-galaxy/cwl/wiki/CWL-Start-Guide-JP"&gt;素晴らしい日本語ドキュメント&lt;/a&gt;から取ってきました。要はbioinformaticsなど、複数のソフトの連携が必要な処理を自動化、共有がスムーズになるような仕組みです。ローカルでテストして、サーバーやクラウドに持っていくのも簡単です。最近はSangerやBroad Institute(ハーバードとMITの共同研究施設)などでも使われているとのことです。&lt;/p&gt;
&lt;p&gt;まずは&lt;strong&gt;&lt;a href="https://www.youtube.com/embed/86eY8xs-Vo8?cc_load_policy=1&amp;amp;cc_lang_pref=ja&amp;amp;autoplay=1"&gt;60秒でわかるCWL - youtube&lt;/a&gt;&lt;/strong&gt;をみてください。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.cwl&lt;/code&gt;で記述できるのはtoolとworkflowの二種類です。toolは例えばSTARやkallistoなど一つのツールを一つのcwlファイルに記述します。workflowはそれらのtoolをbindして実際のworkflowにします。更に、workflowをnestして新しいworkflowを作ったりも出来ます。&lt;/p&gt;
&lt;h2&gt;始め方&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/pitagora-galaxy/cwl/wiki/CWL-Start-Guide-JP"&gt;素晴らしい日本語ドキュメント&lt;/a&gt;を読みましょう。10分もあれば読めると思います。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/13K6BKQoimiaOIFSnComw8in3HlCxEm820OASP8_jnDI/edit?usp=sharing"&gt;cwl-intro-gui-workshop スライド&lt;/a&gt;をやってみましょう。1時間ほどです。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.commonwl.org/user_guide/"&gt;user guide&lt;/a&gt;をやりましょう。3時間ほどで終わるように設計されています。(理論値)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;CWLのここがすごい&lt;/h2&gt;
&lt;p&gt;入門は各サイトにお任せするとして、今回は私がCWLをさわってみてすごいと思ったところをまとめてみます。素人目線です。&lt;/p&gt;
&lt;h3&gt;rabix composerのGUIがきれいすぎる&lt;/h3&gt;
&lt;p&gt;&lt;img alt="rabix gif" src="https://github.com/rabix/composer/raw/master/doc/images/workflows.gif"&gt;&lt;/p&gt;
&lt;p&gt;画像はbioinformaticsでお馴染みのSTARをrabix composerで操っているところです。&lt;a href="http://rabix.io/"&gt;rabix composer&lt;/a&gt;を使えば、GUIで直感的にCWLが触れます。更に出来たworkflowをクラウドやサーバーにそのまま持っていってCLI越しに使うことが出来ます。&lt;/p&gt;
&lt;h3&gt;dockerをベースにして完全にreproducibleにできる&lt;/h3&gt;
&lt;p&gt;いかにも今どきなのですが、toolの記述はすべてdockerのコンテナを使って記述することが出来ます。つまり、環境が変わってインストールし直す手間がまったく無いということです。すばらしいですね。さらに&lt;code&gt;--user-space-docker-cmd=udocker&lt;/code&gt;というオプション一つで、udockerというUser権限しか無い環境でも使えるdockerを使って動かすことができるようです。&lt;/p&gt;
&lt;h3&gt;すでにいろいろなソフトのcwlが出来ている&lt;/h3&gt;
&lt;p&gt;Communityで管理されている&lt;a href="https://github.com/common-workflow-language/workflows"&gt;CWL Tools &amp;amp; Workflows&lt;/a&gt;があります。ほかにもDBCLS太田さんの管理されている&lt;a href="https://github.com/pitagora-galaxy/cwl"&gt;Pitagora Workflows in CWL&lt;/a&gt;もいろいろ揃っています。&lt;/p&gt;
&lt;h3&gt;cwltoolの安定感がすごい&lt;/h3&gt;
&lt;p&gt;出来たcwlファイルをCLI環境で使うにはcwltoolを使います。感動したのはヘルプが自動で生成されるところ。しかも、pythonで書かれていてpythonに組み込むことも出来ます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cwltool.factory&lt;/span&gt;
&lt;span class="n"&gt;fac&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cwltool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fac&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;echo.cwl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# result[&amp;quot;out&amp;quot;] == &amp;quot;foo&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;日本人contributerが多い&lt;/h3&gt;
&lt;p&gt;困ったときに助けてくれるやさしいcontributerの方々が日本に何人かいます。また、日本語ドキュメントも多くてとても助かります。更に、開発者の&lt;a href="https://twitter.com/biocrusoe"&gt;Michael R. Crusoe&lt;/a&gt;は来日しており、&lt;a href="https://twitter.com/hashtag/CommonWLjp?src=hash"&gt;#CommonWLjp&lt;/a&gt;などでCWLの輪を広げています。&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="ja"&gt;&lt;p lang="en" dir="ltr"&gt;On my way to the 11th &lt;a href="https://twitter.com/NBDC_info?ref_src=twsrc%5Etfw"&gt;@NBDC_info&lt;/a&gt; / &lt;a href="https://twitter.com/dbcls?ref_src=twsrc%5Etfw"&gt;@dbcls&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/biohack18?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#biohack18&lt;/a&gt; (with a week long stop in Tokyo for &lt;a href="https://twitter.com/hashtag/usegalaxyjp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#usegalaxyjp&lt;/a&gt; meeting and other &lt;a href="https://twitter.com/hashtag/CommonWL?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#CommonWL&lt;/a&gt; presentations and a bilingual workshop) &lt;a href="https://t.co/W4gsO9bnA1"&gt;pic.twitter.com/W4gsO9bnA1&lt;/a&gt;&lt;/p&gt;&amp;mdash; Michael R. Crusoe (@biocrusoe) &lt;a href="https://twitter.com/biocrusoe/status/1069104245100748801?ref_src=twsrc%5Etfw"&gt;2018年12月2日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://platform.twitter.com/widgets.js"&gt;https://platform.twitter.com/widgets.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;kallistoをCWL + Rabix Composerで試してみる&lt;/h2&gt;
&lt;p&gt;まずは実際の作業工程を見てみましょう。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gif" src="https://github.com/yyoshiaki/cwl_user_guide/blob/master/kallisto/kallisto.gif?raw=true"&gt;&lt;/p&gt;
&lt;p&gt;ちゃんとkallistoのoutputが生成されていますね！データは&lt;a href="https://github.com/yyoshiaki/cwl_user_guide/tree/master/kallisto"&gt;github&lt;/a&gt;にまとめておきました。テスト用のシーケンスデータも付けてあるので、クローンして遊んでみてください。&lt;code&gt;kallisto-index.cwl&lt;/code&gt;と&lt;code&gt;kallisto-quant.cwl&lt;/code&gt;は公式の&lt;a href="https://github.com/common-workflow-language/workflows"&gt;CWL Tools &amp;amp; Workflows&lt;/a&gt;から取ってきました。もちろんこれらはdocker imageを使っています。新しいworkflowを作ってみましょう。動画のように直感的にできると思います。&lt;/p&gt;
&lt;p&gt;今回、errorが出て進まなかった場所があったのですが、石井さん、西田さんの応援や、cwlの作者のMichaelやRabixの作者のKaushikがerrorに対処してくれました。&lt;a href="https://github.com/rabix/composer/issues/418#issuecomment-444257454"&gt;issue : kallisto workflow is incompatible with Rabix composer #418&lt;/a&gt;この対応のフレンドリーさはbioinformaticsならではですね。&lt;/p&gt;
&lt;h2&gt;workflow業界のあれこれ&lt;/h2&gt;
&lt;p&gt;ここで一旦workflowについて広く見てみましょう。ハーバードを始めとする海外の研究所ではサーバーを研究所ごとに管理するのに変えて、クラウドの利用が盛んになってきています。そういう時代感もあり、workflowやコンテナなど、reproducibleな環境の整備というのはますます重要視されてきています。workflow業界ではcwlの他に古き良き&lt;a href="http://wiki.pitagora-galaxy.org/wiki/index.php/Workflows"&gt;Galaxy&lt;/a&gt;、Broad Instituteが開発している&lt;a href="https://software.broadinstitute.org/wdl/"&gt;WDL&lt;/a&gt;や&lt;a href="https://www.nextflow.io/"&gt;nextflow&lt;/a&gt;、Pythonで書かれている&lt;a href="https://snakemake.readthedocs.io/en/stable/"&gt;Snakemake&lt;/a&gt;など、さまざまな選択肢があります。どのworkflowが好きか、Cambridgeの&lt;a href="https://twitter.com/@AlbertVilella"&gt;@AlbertVilella&lt;/a&gt;が世界中のbioinformaticianにアンケートをとっていました。&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="ja"&gt;&lt;p lang="en" dir="ltr"&gt;90 responses in &lt;a href="https://t.co/hbaY7ShocR"&gt;https://t.co/hbaY7ShocR&lt;/a&gt; &lt;a href="https://twitter.com/nextflowio?ref_src=twsrc%5Etfw"&gt;@nextflowio&lt;/a&gt; &lt;a href="https://twitter.com/SBGenomics?ref_src=twsrc%5Etfw"&gt;@SBGenomics&lt;/a&gt; &lt;a href="https://twitter.com/commonwl?ref_src=twsrc%5Etfw"&gt;@commonwl&lt;/a&gt; Snamemake &lt;a href="https://t.co/1kc1DaXdBa"&gt;pic.twitter.com/1kc1DaXdBa&lt;/a&gt;&lt;/p&gt;&amp;mdash; Albert Vilella (@AlbertVilella) &lt;a href="https://twitter.com/AlbertVilella/status/1070219898306084865?ref_src=twsrc%5Etfw"&gt;2018年12月5日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://platform.twitter.com/widgets.js"&gt;https://platform.twitter.com/widgets.js&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="ja"&gt;&lt;p lang="en" dir="ltr"&gt;No votes so far for &lt;a href="https://twitter.com/ensembl?ref_src=twsrc%5Etfw"&gt;@ensembl&lt;/a&gt; Hive, Apache Taverna or &lt;a href="https://twitter.com/arvados?ref_src=twsrc%5Etfw"&gt;@arvados&lt;/a&gt; , even though we know they have plenty of users &lt;a href="https://t.co/Db2el8vPDt"&gt;https://t.co/Db2el8vPDt&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/Bioinformatics?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#Bioinformatics&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/Workflows?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#Workflows&lt;/a&gt; &lt;a href="https://t.co/hbaY7ShocR"&gt;https://t.co/hbaY7ShocR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Albert Vilella (@AlbertVilella) &lt;a href="https://twitter.com/AlbertVilella/status/1070579264192462849?ref_src=twsrc%5Etfw"&gt;2018年12月6日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://platform.twitter.com/widgets.js"&gt;https://platform.twitter.com/widgets.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;どうやら一番twitter界隈のbioinformaticianはnextflowが好きなようです。ただ、下のspreadsheetを見ると、githubではGalaxy,bcbioについで三番目に盛んなようです。&lt;/p&gt;
&lt;p&gt;他にも、cwlやnextflowを取り上げたgenome解析の論文も出ていたりします。&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2446-1"&gt;Baichoo, S. et al. Developing reproducible bioinformatics analysis workflows for heterogeneous computing environments to support African genomics. BMC Bioinformatics 19, 457 (2018).&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;結論　みんなでCWLを使おう！&lt;/h2&gt;
&lt;p&gt;医学部生にできるだけわかりやすく書いてみました。みんなでcwlを使ってどんどん解析を楽にしましょう！&lt;/p&gt;
&lt;p&gt;国試も自動化できたらなあ。。。&lt;/p&gt;
&lt;h2&gt;参考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.commonwl.org/"&gt;CWL公式ページ&lt;/a&gt; : リンク集がついている。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/13K6BKQoimiaOIFSnComw8in3HlCxEm820OASP8_jnDI/edit?usp=sharing"&gt;cwl-intro-gui-workshop スライド&lt;/a&gt; : 二階堂研石井さんのスライド。わかりやすいです。&lt;/li&gt;
&lt;/ul&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>(論文まとめ)医師国家試験問題自動生成AI</title><link href="http://oumpy.github.io%5Carticles/2019/04/doctor_exam_ai.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>秋山</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/doctor_exam_ai.html</id><summary type="html"></summary><content type="html">&lt;p&gt;On the Generation of Medical Question-Answer Pairs.
Shen S, Li Y, Du N, Wu X, Xie Y, Ge S, et al. arXiv. 2018.
http://arxiv.org/abs/1811.00681&lt;/p&gt;
&lt;p&gt;上記論文を軽く紹介。
Tensent Mediacal AI lab Internからの論文。
Deep learning技術により質問文に対して回答するAI (question answering, QA)が発展している。しかし、QAを医療に応用するためにはAIを学習させるためのデータが不足している。そこで質問文と解答のペアを自動生成するモデルを提案した。&lt;/p&gt;
&lt;p&gt;手法
Key Phrase Detector
質問文の各フレーズが解答の決め手となるキーフレーズであるかを評価する。キーフレーズであるかどうかは特定の解答に対して高頻度で質問文に出現するフレーズがキーフレーズであるとしてdetectorを学習させる。例えば「日本脳炎」が解答である場合「項部硬直」などがキーフレーズとなる。
Conditional Variational Autoencoder (CVAE)
キーフレーズは維持しつつ、それ以外のフレーズを生成モデルCVAEによって言い換える。これによって答が同じな新たな質問文が作られる。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-427" src="https://pythonoum.files.wordpress.com/2018/12/393E4E28-4B67-4C25-A11B-BE7CA70BB9AC.png" alt="393E4E28-4B67-4C25-A11B-BE7CA70BB9AC" width="2055" height="880" /&gt;&lt;/p&gt;
&lt;p&gt;データ
中国医師国家試験18,798問
中国のWikipedia風医療サイト (http://xywy.com/)
医学辞書19冊
医学論文2,130,128本
医学専門書518冊&lt;/p&gt;
&lt;p&gt;実験結果
アルゴリズムによる評価、人間による評価ともにベースラインを上回った。&lt;/p&gt;
&lt;p&gt;読んだ感想
生成された問題文の例が載ってないのですごいのかよくわからなかった。データの量はすごい。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>LinuxでのBioinformatics環境構築_01</title><link href="http://oumpy.github.io%5Carticles/2019/04/environment_bioinformatics.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>平岡</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/environment_bioinformatics.html</id><summary type="html"></summary><content type="html">&lt;p&gt;お疲れ様です。ただいま、私のMacbook Proが入院しておりまして、古いWindows10をUbuntuとデュアルブートして作業しております。下級生でもWindowsしか持っていない、でもBioinformaticsに関心があるという人が、スムーズに環境構築できるようにと今回の記事を書きます。なお、前提として、Ubuntuのインストールが完了しているものとします。なお、筆者のインストールしたUbuntuは18.04.1 LTSです。&lt;/p&gt;
&lt;p&gt;今回は&lt;strong&gt;＜&lt;em&gt;Kallisto&lt;/em&gt;を用いた&lt;em&gt;RNA-seq&lt;/em&gt;解析パイプライン＞&lt;/strong&gt;で使う、RNA-seq系のツールのインストールを行っていきますが、順次別の解析目的のツールインストールも紹介したいと考えております。今回の環境構築で、&lt;a href="https://pythonoum.wordpress.com/2018/10/16/kallisto%E3%82%92%E7%94%A8%E3%81%84%E3%81%9Frna-seq%E8%A7%A3%E6%9E%90%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3/"&gt;Kallistoを用いたRNA-seq解析パイプライン&lt;/a&gt;に進むことができます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ubuntuではpython2.7がデフォルト&lt;/strong&gt;となっているので、python3をダウンロードし、デフォルトに設定しよう。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;check the version of python.&lt;/h1&gt;
&lt;p&gt;$ python --version&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 2.7.15rc1
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://www.anaconda.com/download/#macos"&gt;Anaconda&lt;/a&gt;のインストーラーをダウンロードします。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ bash ~/Downloads/Anaconda3-4.1.0-Linux-x86_64.sh
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;export PATH=/home/user/anaconda3/bin:$PATH&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt; ~/.bashrc
$ conda -V
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[code lang="text"]
$ python --version&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 3.6.6+
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;バイオインフォマティクスの分野では解析のために様々なツールを利用しますが、インストールのたびにパスを通すなどの作業をしていると大変煩雑ですし、バージョン管理もしにくくなります。パッケージマネージャーを使ってツールを一元管理するのが賢明です。
Homebrewなどのパッケージ管理システムは有名ですが、対応していないツールの多く、現状はBiocondaというパッケージマネージャーがおすすめです。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;Download a Miniconda package for linux python3&lt;/h1&gt;
&lt;p&gt;$ wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh
$ bash Miniconda3-latest-Linux-x86_64.sh
[/code]&lt;/p&gt;
&lt;p&gt;EnterやYesを入力していくとインストールが終了し、パスも通った状態になります。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;condaコマンドが正常に動作していれば成功です。（terminalを開き直しましょう。）&lt;/h1&gt;
&lt;p&gt;$ conda -h
[/code]&lt;/p&gt;
&lt;p&gt;biocondaのチャンネルを追加。biocondaチャンネルが最上位に来るように設定。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ conda config --add channels conda-forge
$ conda config --add channels defaults
$ conda config --add channels r
$ conda config --add channels bioconda
[/code]&lt;/p&gt;
&lt;p&gt;それでは早速ツールをインストールしていきましょう。基本 conda install ???でインストールが完了し正常に動作していきます。非常に便利ですね。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ conda install parallel-fastq-dump
$ conda install fastqc
$ conda install multiqc
$ conda install trimmomatic
$ conda install kallisto
[/code]&lt;/p&gt;
&lt;p&gt;参照：http://imamachi-n.hatenablog.com/entry/2017/01/14/212719&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;R&lt;/em&gt;ツールのインストール&lt;/strong&gt;
Rのコンソールを開いて、Rのツールをインストールしていきます。
Tximportのインストール&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;source("https://bioconductor.org/biocLite.R")
biocLite("tximport")
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DESeq2のインストール&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;source("https://bioconductor.org/biocLite.R")
biocLite("DESeq2")
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参照：
https://bioconductor.org/packages/release/bioc/html/tximport.html
https://bioconductor.org/packages/release/bioc/html/DESeq2.html&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>github desktopアプリの使い方</title><link href="http://oumpy.github.io%5Carticles/2019/04/github_desktop.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/github_desktop.html</id><summary type="html"></summary><content type="html">&lt;p&gt;githubとはなにかの説明は省略しています。githubについて知らない人は先にいろいろ調べてみましょう。今回は&lt;a href="https://desktop.github.com/"&gt;github desktop&lt;/a&gt;についてです。&lt;/p&gt;
&lt;h3&gt;レポジトリの読み込み（プロジェクト開始時の一回のみ。）&lt;/h3&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-284" src="https://pythonoum.files.wordpress.com/2018/10/1.png" alt="1" width="550" height="202" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github上のレポジトリとLocal pathを指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-285" src="https://pythonoum.files.wordpress.com/2018/10/2.png" alt="2" width="900" height="968" /&gt;&lt;/p&gt;
&lt;p&gt;これでうまくcloneされていたらOK&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;毎回の流れ(基本編)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一日の作業の初めにFetchしてきて、最新の状態に同期する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-286" src="https://pythonoum.files.wordpress.com/2018/10/3.png" alt="3" width="928" height="398" /&gt;&lt;/p&gt;
&lt;p&gt;ファイルを変更、加筆すると自動的にアプリに反映される&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-287" src="https://pythonoum.files.wordpress.com/2018/10/4.png" alt="4" width="2144" height="1544" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作業の区切りがついたら左下のSummeryに適当にコメントを付け、commit to master。
コメントはもうちょっと丁寧に付けましょう。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-288" src="https://pythonoum.files.wordpress.com/2018/10/5.png" alt="5" width="620" height="518" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-289" src="https://pythonoum.files.wordpress.com/2018/10/6.png" alt="6" width="2144" height="1544" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pushして変更を反映させる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まとめると、&lt;strong&gt;fetch(pull) -&amp;gt; commit -&amp;gt; push&lt;/strong&gt; のライフライクルです。&lt;/p&gt;
&lt;h3&gt;CLIでの操作&lt;/h3&gt;
&lt;p&gt;デスクトップアプリはwin,macではあるが、Ubuntuでは無いらしいので、同じ作業をCLIでやる必要がある。ただし、基本は同じで&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git pull origin master
$ git add --all
$ git commit -m &lt;span class="s2"&gt;&amp;quot;コメント&amp;quot;&lt;/span&gt;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;って感じでやればOK。branchやmerge、プルリクエストについては触れていません。&lt;/p&gt;</content><category term="tech_archive"></category><category term="github"></category></entry><entry><title>いまさらGoogle Colaboratory入門</title><link href="http://oumpy.github.io%5Carticles/2019/04/google_colaboratory.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>宮崎</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/google_colaboratory.html</id><summary type="html"></summary><content type="html">&lt;p&gt;いまさらGoogle Colaboratory触ってみた感じ、かなり便利なのでまとめておきます。&lt;/p&gt;
&lt;p&gt;動機は、研究室の環境とは別に、趣味のプログラミングの環境が欲しかったからです。&lt;/p&gt;
&lt;p&gt;(あと、PCがクソザコなので、クラウドがいいかなーと思いました)
&lt;h1&gt;対象&lt;/h1&gt;
初学者に非常に向いています。&lt;/p&gt;
&lt;p&gt;pythonの勉強会や趣味レベルまで対応している神環境だと思います。
&lt;h1&gt;特徴&lt;/h1&gt;
一言でいうと：コードの共有に向いています。
&lt;blockquote&gt;・無料
・install不要
・ブラウザさえ使えればどこでもできる
・google driveとの連携が便利
・githubとの連携が簡単(コピーする、というボタンだけでuploadできる)
・しかもGPU使える(TPUも)&lt;/blockquote&gt;
&lt;h1&gt;使用&lt;/h1&gt;
登録：&lt;a href="https://colab.research.google.com/" target="_blank" rel="noopener"&gt;https://colab.research.google.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;標準では書いたノートブックはGoogle Driveに保存されるようになっています。&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-196" src="https://pythonoum.files.wordpress.com/2018/10/e382b9e382afe383aae383bce383b3e382b7e383a7e38383e38388-2018-10-08-12-18-55.png" alt="スクリーンショット 2018-10-08 12.18.55" width="2836" height="1606" /&gt;&lt;/p&gt;
&lt;p&gt;右上の共有コマンドから、Google Documentと同じようにリンクを作ったり、他の人と共有できます。&lt;/p&gt;
&lt;p&gt;ファイルの選択から、Google DriveやGitHubと連携ができます(すごい)。
&lt;h1&gt;感想&lt;/h1&gt;
全部クラウドでできるので良い。&lt;/p&gt;
&lt;p&gt;notebookがGoogle用にチューニングされていて更に使いやすい。&lt;/p&gt;
&lt;p&gt;初学の時はpycharm使ってましたが、今から始めるなら間違いなくこれを使います。
&lt;h1&gt;参考&lt;/h1&gt;
https://www.codexa.net/how-to-use-google-colaboratory/#Google_Colab-4&lt;/p&gt;
&lt;p&gt;https://karaage.hatenadiary.jp/entry/2018/03/21/073000&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>Gene Set Enrichment Analysis (GSEA)入門</title><link href="http://oumpy.github.io%5Carticles/2019/04/gsea.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>西田</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/gsea.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;GSEAとは&lt;/h1&gt;

&lt;p&gt;GSEAは発現差異解析の結果などで得られる遺伝子群がどういった機能のものかを明らかにするために用いられる解析手法です。機能表現として用いられる主なものとしてはKEGGのパスウェイ分類やGene Ontology(GO)があります。
&lt;h1&gt;clusterProfilerでGSEA入門&lt;/h1&gt;
GSEA には様々なGSEAがあります。単に注目する遺伝子のリストをGSEAへの入力とするもの、発現プロファイルを入力とするもの、機能のデータベースやGSEA手法を複数組み合わせたりするもの (EGSEA) など様々です。[余談ですがGeneを代謝物(Metabolite)に置き換えたMSEAもあります。]&lt;/p&gt;
&lt;p&gt;ここでは前述したものの内、最初の「単に注目する遺伝子のリストをGSEAへの入力とするもの」をbioconductorのパッケージ clusterProfiler を用いて体験してみましょう。&lt;/p&gt;
&lt;p&gt;(clusterProfilerのインストールについては省略します。)&lt;/p&gt;
&lt;p&gt;まず注目する遺伝子のリストを下記で用意します。&lt;/p&gt;
&lt;p&gt;※編集注 : 以下はすべてRでの実行になります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;geneList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;DOSE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gene&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;names&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;geneList&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;geneList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gene&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4312&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;8318&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10874&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;55143&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;55388&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;991&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;6280&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2305&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9493&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1062&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3868&amp;quot;&lt;/span&gt;  
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4605&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9833&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9133&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;6279&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10403&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8685&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;597&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;7153&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;23397&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;6278&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;79733&amp;quot;&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;259266&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1381&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3627&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;27074&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;6241&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;55165&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;9787&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;7368&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;11065&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;55355&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;9582&amp;quot;&lt;/span&gt;  
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;34&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;220134&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;55872&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;51203&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;3669&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;83461&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;22974&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10460&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10563&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4751&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;6373&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;8140&amp;quot;&lt;/span&gt;  
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;45&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;79019&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;820&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;10635&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;1844&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4283&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;27299&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;55839&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;27338&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;890&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;9415&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;983&amp;quot;&lt;/span&gt;   
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;56&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;54821&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10232&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4085&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;6362&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9837&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5080&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;7850&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;81930&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;5918&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;81620&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;332&amp;quot;&lt;/span&gt;   
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;55765&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;79605&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;3832&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;6286&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5163&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2146&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3002&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;50852&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;7272&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2568&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;64151&amp;quot;&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;78&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;51806&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;366&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;2842&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9212&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;140578&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;51659&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8715&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4902&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;8208&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1111&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9319&amp;quot;&lt;/span&gt;  
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;89&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;9055&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3833&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;146909&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;23475&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4321&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;11182&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10112&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;3902&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3620&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3887&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;51514&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;6790&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4521&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;891&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;57110&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8544&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1448&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;24137&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;6355&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10578&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4174&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9232&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;111&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;643314&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1307&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;776&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;4129&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;9370&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;196740&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;25924&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8857&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1602&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;51161&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;3708&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;122&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;23090&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10742&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;51760&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;9122&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10699&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8416&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;60598&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;79148&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;64799&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4629&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1556&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;133&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;55096&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;26289&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;6038&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;771&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;51313&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;23704&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;3117&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;80129&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;23158&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;125&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;4958&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;144&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4857&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1311&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5105&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5174&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;730&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;2018&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;81563&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;2532&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1308&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4250&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;23362&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;155&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2167&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;51705&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;2593&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;652&amp;quot;&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;80736&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4036&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;57502&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;5507&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;56521&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;22885&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4137&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;166&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;8483&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;8839&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2066&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4693&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;4148&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;79083&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;1101&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3158&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;3169&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5346&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;1408&amp;quot;&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;177&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;9547&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2922&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;11283&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;64499&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;54829&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;1524&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10234&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;1580&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10647&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;25893&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;24141&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;188&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;10351&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;2330&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5304&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;79846&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;8614&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;2625&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;7021&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;7802&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;79689&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;11122&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;55351&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;199&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;9&amp;quot;&lt;/span&gt;      &lt;span class="s"&gt;&amp;quot;4239&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;5241&amp;quot;&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;10551&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;10974&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;79838&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;79901&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;57758&amp;quot;&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;4969&amp;quot;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;gene&lt;/code&gt;はヒト遺伝子のENTREZのIDです。&lt;/p&gt;
&lt;p&gt;この遺伝子リストを入力としてKEGGを対象としたGSEAを行ってみましょう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clusterProfiler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;kk&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;enrichKEGG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gene&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gene&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;                  &lt;span class="n"&gt;organism&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hsa&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;                  &lt;span class="n"&gt;pvalueCutoff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0.05&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;head&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="n"&gt;ID&lt;/span&gt;                             &lt;span class="n"&gt;Description&lt;/span&gt; &lt;span class="n"&gt;GeneRatio&lt;/span&gt;  &lt;span class="n"&gt;BgRatio&lt;/span&gt;       &lt;span class="n"&gt;pvalue&lt;/span&gt;     &lt;span class="n"&gt;p.adjust&lt;/span&gt;       &lt;span class="n"&gt;qvalue&lt;/span&gt;                                             &lt;span class="n"&gt;geneID&lt;/span&gt; &lt;span class="n"&gt;Count&lt;/span&gt;
&lt;span class="n"&gt;hsa04110&lt;/span&gt; &lt;span class="n"&gt;hsa04110&lt;/span&gt;                              &lt;span class="n"&gt;Cell&lt;/span&gt; &lt;span class="n"&gt;cycle&lt;/span&gt;     &lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt; &lt;span class="m"&gt;123&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7469&lt;/span&gt; &lt;span class="m"&gt;2.135411e-07&lt;/span&gt; &lt;span class="m"&gt;0.0000409999&lt;/span&gt; &lt;span class="m"&gt;4.023565e-05&lt;/span&gt; &lt;span class="m"&gt;8318&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;991&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9133&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;890&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;983&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;4085&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7272&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1111&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;891&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;4174&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9232&lt;/span&gt;    &lt;span class="m"&gt;11&lt;/span&gt;
&lt;span class="n"&gt;hsa04114&lt;/span&gt; &lt;span class="n"&gt;hsa04114&lt;/span&gt;                          &lt;span class="n"&gt;Oocyte&lt;/span&gt; &lt;span class="n"&gt;meiosis&lt;/span&gt;     &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt; &lt;span class="m"&gt;125&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7469&lt;/span&gt; &lt;span class="m"&gt;2.216832e-06&lt;/span&gt; &lt;span class="m"&gt;0.0002128158&lt;/span&gt; &lt;span class="m"&gt;2.088489e-04&lt;/span&gt;    &lt;span class="m"&gt;991&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9133&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;983&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;4085&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;51806&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;6790&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;891&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9232&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;3708&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;5241&lt;/span&gt;    &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;hsa04218&lt;/span&gt; &lt;span class="n"&gt;hsa04218&lt;/span&gt;                     &lt;span class="n"&gt;Cellular&lt;/span&gt; &lt;span class="n"&gt;senescence&lt;/span&gt;     &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt; &lt;span class="m"&gt;160&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7469&lt;/span&gt; &lt;span class="m"&gt;2.014286e-05&lt;/span&gt; &lt;span class="m"&gt;0.0012891427&lt;/span&gt; &lt;span class="m"&gt;1.265113e-03&lt;/span&gt;     &lt;span class="m"&gt;2305&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;4605&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9133&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;890&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;983&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;51806&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1111&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;891&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;776&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;3708&lt;/span&gt;    &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;hsa03320&lt;/span&gt; &lt;span class="n"&gt;hsa03320&lt;/span&gt;                  &lt;span class="n"&gt;PPAR&lt;/span&gt; &lt;span class="n"&gt;signaling&lt;/span&gt; &lt;span class="n"&gt;pathway&lt;/span&gt;      &lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt;  &lt;span class="m"&gt;74&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7469&lt;/span&gt; &lt;span class="m"&gt;2.724093e-05&lt;/span&gt; &lt;span class="m"&gt;0.0013075646&lt;/span&gt; &lt;span class="m"&gt;1.283191e-03&lt;/span&gt;                 &lt;span class="m"&gt;4312&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9415&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;9370&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;5105&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2167&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;3158&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;5346&lt;/span&gt;     &lt;span class="m"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;hsa04914&lt;/span&gt; &lt;span class="n"&gt;hsa04914&lt;/span&gt; &lt;span class="n"&gt;Progesterone&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mediated&lt;/span&gt; &lt;span class="n"&gt;oocyte&lt;/span&gt; &lt;span class="n"&gt;maturation&lt;/span&gt;      &lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt;  &lt;span class="m"&gt;98&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;7469&lt;/span&gt; &lt;span class="m"&gt;1.657604e-04&lt;/span&gt; &lt;span class="m"&gt;0.0063651988&lt;/span&gt; &lt;span class="m"&gt;6.246549e-03&lt;/span&gt;                    &lt;span class="m"&gt;9133&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;890&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;983&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;4085&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;6790&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;891&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;5241&lt;/span&gt;     &lt;span class="m"&gt;7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;kk&lt;/code&gt; がGSEAの結果になります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head(kk)&lt;/code&gt; でGSEAの結果を上から確からしいもの順にトップ5を出力しています。&lt;/p&gt;
&lt;p&gt;もし遺伝子リスト&lt;code&gt;gene&lt;/code&gt;が発現差異解析の結果であるなら、コントロールとターゲット間で&lt;code&gt;Cell cycle&lt;/code&gt;等に異変が起きているだろう、とこの結果から推測できるということになります。&lt;/p&gt;
&lt;p&gt;次に&lt;code&gt;kk&lt;/code&gt;の各列名の意味ですが&lt;/p&gt;
&lt;p&gt;IDはKEGG pathwayのID&lt;/p&gt;
&lt;p&gt;DescriptionはKEGG pathwayの名前&lt;/p&gt;
&lt;p&gt;GeneRatioは入力&lt;code&gt;gene&lt;/code&gt;の遺伝子の内、何個の遺伝子がそのKEGG pathwayにマップされるか&lt;/p&gt;
&lt;p&gt;BgRatioは全KEGG pathwayにマップされる遺伝子の内、何個の遺伝子がそのKEGG pathwayにマップされるか&lt;/p&gt;
&lt;p&gt;p.adjust, qvalueは多重検定に伴う補正後のpvalueになり小さいほど確からしいことを示します。&lt;/p&gt;
&lt;p&gt;入力&lt;code&gt;gene&lt;/code&gt;に含まれる遺伝子がKEGG pathway上のどのgene productにmapされるかを可視化するには下記を実行します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;browseKEGG(kk, &amp;#39;hsa04110&amp;#39;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img title="" src="https://pythonoum.files.wordpress.com/2018/11/null9.png" alt="" width="624" height="481" /&gt;
&lt;h1&gt;終わりに&lt;/h1&gt;
最も簡単なGSEAを体験していただく例を示しました。&lt;/p&gt;
&lt;p&gt;追ってより進んだアンサンブル手法なども紹介できればと思っています。&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>Hamiltonian Descent Methodの要点</title><link href="http://oumpy.github.io%5Carticles/2019/04/hamiltonian_descent_method.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>山本</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/hamiltonian_descent_method.html</id><summary type="html"></summary><content type="html">&lt;p&gt;解説自体は&lt;a href="https://omedstu.jimdo.com/2018/09/26/hamiltonian-descent-methods%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E8%A7%A3%E8%AA%AC/" target="_blank" rel="noopener"&gt;Hamiltonian Descent Methodsの実装についての解説&lt;/a&gt;に書いたのですが、こちらには要点だけまとめておきます。&lt;/p&gt;
&lt;h3&gt;要点のまとめ&lt;/h3&gt;

&lt;p&gt;&lt;img class="aligncenter size-full wp-image-170" src="https://pythonoum.files.wordpress.com/2018/09/1537941381.jpg" alt="1537941381" width="800" height="269" /&gt;
- Hamiltonian Descent法を用いると凸関数最適化が高速かつ高精度で行える。
- 超収束(Super-Convergence, &lt;a href="https://arxiv.org/pdf/1708.07120.pdf"&gt;arxiv&lt;/a&gt;)とは関係ある？論文読んだ限りはなさそう。
- ニューラルネットワークの最適化に応用するには運動エネルギー関数の研究が必要。
- なぜ高速に学習できるのか、なぜSGDと比べてニューラルネットワークの学習が不能なのか不明。でも学習できるならもっと実装あるよなと思っています。&lt;/p&gt;
&lt;h3&gt;アルゴリズム（1つ目の陽解法）&lt;/h3&gt;

&lt;p&gt;パラメータx以外に運動量のパラメータpを用意します。以下の更新式に従ってパラメータを更新します。
&lt;img class="aligncenter size-medium wp-image-168" src="https://pythonoum.files.wordpress.com/2018/09/texclip20180929003048.png?w=600" alt="texclip20180929003048" width="300" height="81" /&gt;
ここでx_tは時刻tにおける解、p_tは時刻tにおける運動量、kは運動エネルギー関数、fは最小化したい関数（位置エネルギー関数）です2回微分が必要ですが、運動エネルギー関数k(p)を解析的に微分可能にしておけば、∇k(p)を定義すれば微分は1回でokです。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>組み込みでDeep Learningにつかえるハードについて</title><link href="http://oumpy.github.io%5Carticles/2019/04/hardware_for_deeplearning.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/hardware_for_deeplearning.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;組み込みでDeep Learningにつかえるハードについて&lt;/h1&gt;

&lt;p&gt;2018/08/01　リレー投稿再掲　安水良明
&lt;h2&gt;Rasberry pi&lt;/h2&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;シングルボードコンピュータ。手のひらサイズで値段も５０００円とリーズナブルだが一人前のコンピューター。Linuxの練習にもうってつけ。クアッドコアだが機械学習としてはすこし非力。GPUもつかえない。電池で動く。何台もつなげてクラスター化する強者も。
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://www.cenav.org/raspi2/"&gt;計算工学ナビ : RaspberryPiでスパコンを作ろう&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://qiita.com/kazunori279/items/bb58f0b3095f3c65b2a1"&gt;Qiita : RasPiとディープラーニングで我が家のトイレ問題を解決する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;スマホ&lt;/h2&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;やはり今の時代にハードとしてスマホに注目しないわけにはいかない。Tensorflowならスマホ組み込みも。まだ開発版のみだが、アンドロイドもiosもどちらも遊べるらしい。
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://www.sejuku.net/blog/55188"&gt;侍エンジニア塾 : 【TensorFlow】スマホで動かせるLiteとは？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;GPU&lt;/h2&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;おなじみ。Deep Learning等は大量の行列演算を必要とする。GPUはもともとグラフィックスにフォーカスして作られていた演算回路だが、グラフィックス自体大量の行列演算だったため、Deep Learningに転用することで超高速な学習が可能になった。Deep learningやるなら必需品。ただ、これ自体を持ち出すのは困難。市販最速のNVIDIA GTX 1080 tiで１０万円くらい。
&lt;h2&gt;FPGA&lt;/h2&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;Field Programmable Gate Arrayの略。デジタル回路を自分で設計できる集積回路。集積回路といえば単一タスクを低電力低コストで高速な演算が可能だが、専門家しか作れなかったし、そもそも作ること自体が大変だった。FPGAは集積回路の設計をソフトで行うことで、柔軟に専門設計が可能になった。ちっちゃいので組み込みにも向いている。最近Scienceにのって話題になったGohst CytometryもFPGA使ってるそうな。（阪大、東大、理研AIPのコラボ。下で書くjetson化も視野に入れているらしい。）最近では各社がFPGAに取り組みだしている。Tensorflowも動かせるらしい。ただしやはり専門外ではとっつきにくい。ピンキリだがやすいので１万５千円くらい。論理回路設計がもとめられるのでぶっちゃけよくわからん。
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://qiita.com/kazunori279/items/a9e97a4463cab7dda8b9"&gt;Qiita : そろそろプログラマーもFPGAを触ってみよう！&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://science.sciencemag.org/content/360/6394/1246.full"&gt;Science : Gohst Cytometry&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jetson&lt;/h2&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;NVIDIA組み込みモジュール。安価かつ高速でポータブルなGPUが使える。NVIDIA製ということで、Tensorflowも使えるのが嬉しい。値段は開発キットが599ドル（1ドル＝114円換算で、6万8286円）で、製品に組み込んで出荷可能なProduction Moduleは1000個ロット時で399ドル（同、4万5486円）。256 CUDAコア（GTX 1080 tiで3584 cuda cores）なので、やはり学習済みモデルの運用がメインと思われる。
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://qiita.com/ababa893/items/57b43e788d684c380866"&gt;Qiita : NVIDIA Jetson TX2でTensorFlowによる人体姿勢推定プログラムを動かせるようになるまで&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
ディープラーニングに限らず、なにか作ったよとか、こんなの面白いよというのがあれば教えてください。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>JuliaとPythonと競技プログラミング</title><link href="http://oumpy.github.io%5Carticles/2019/04/julia_python_competition.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/julia_python_competition.html</id><summary type="html"></summary><content type="html">&lt;p&gt;最近友人と話していて&lt;a href="https://julialang.org"&gt;julia&lt;/a&gt;が話題になったことがあったので、少しだけ調べて試して
みた話。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Juliaってなに?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pythonのような動的型付けのスクリプト言語です。実行時にコンパイルを行いC言語にも迫る実行速度、科学技術系の数値計算もどんと来い、という触れ込みで、人気上昇中らしいです。Pythonを含む他言語のライブラリを読み込む仕組みを備えているのもすごいところ。
&lt;del&gt;ただ、コードの見た目が激しくMatlab風味で思わず目を背けたくなります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AtCoderでのJulia&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ご多分に漏れず、実行速度に惹かれました。半年ほど前から参加している競技プログラミングサイト&lt;a href="https://atcoder.jp" target="_blank" rel="noopener noreferrer"&gt;AtCoder&lt;/a&gt; で、常用しているPython(← Python会だからね!)で実行時間切れ、C/C++に
書き換えると正答、という経験を何度かしてきたので。
そういうわけで、ここでは最近の第121回 &lt;a href="https://atcoder.jp/contests/abc121/" target="_blank" rel="noopener noreferrer"&gt;AtCoder Beginner Contest (ABC121)&lt;/a&gt;
の問題で、Juliaのパフォーマンスを実際に見てみます。
(言語知識0から数十分調べて書いたコードのため、動きはするが思わぬところで非効率、ということはあるかもしれません。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AtCoder Beginner Contest 121 問題A "White Cells"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(問題は&lt;a href="https://atcoder.jp/contests/abc121/tasks/abc121_a" target="_blank" rel="noopener noreferrer"&gt;こちら&lt;/a&gt;)
入力値4個を読み込んで簡単な演算結果を返すだけの問題です。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ABC121-A "White Cells" in Julia
inpl() = map(parse,split(readline()))
(H,W) = inpl()
(h,w) = inpl()
println((H-h)*(W-w))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所要時間が入力にほぼ依存しない問題ですが、、各言語でのAtCoder上実行結果。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;言語&lt;/td&gt;
&lt;td&gt;実行時間&lt;/td&gt;
&lt;td&gt;消費メモリ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Julia&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;360ms&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;110MB&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PyPy3&lt;/td&gt;
&lt;td&gt;180ms&lt;/td&gt;
&lt;td&gt;40MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python3&lt;/td&gt;
&lt;td&gt;17ms&lt;/td&gt;
&lt;td&gt;3MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;1ms&lt;/td&gt;
&lt;td&gt;256kB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;C++にもPythonにも、実行時間と消費メモリ双方で惨敗。
おそらくですが、&lt;strong&gt;実行ごとにまずコンパイルを行う&lt;/strong&gt;ので、簡単な問題だとそれが相対的に巨大なオーバーヘッドになってしまうようです。
Pythonの半コンパイラ型実装であるPyPyはJuliaの半分程度でした。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AtCoder Beginner Contest 121 問題C "Energy Drink Collector"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(問題は&lt;a href="https://atcoder.jp/contests/abc121/tasks/abc121_c" target="_blank" rel="noopener noreferrer"&gt;こちら&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;読み込んだ値の列をソートして、条件判定をしながら順番に足し上げていく問題。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ABC121-C "Energy Drink Collector" in Julia
inpl() = map(parse,split(readline()))
(N,M) = inpl()
A = Array{Int}(N,2)
for i in 1:N
  A[i,:] = inpl()
end
A = sortrows(A, by=x-&amp;gt;x[1])
ans = 0
for i in 1:N
  if A[i,2] &amp;gt;= M
    ans += M*A[i,1]
    break
  else
    M -= A[i,2]
    ans += A[i,1]*A[i,2]
  end
end
println(ans) &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんと、テスト16個中15個でタイムアウト(2000ms以上)。。。
Pythonのコードはこちら:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # ABC121-C "Energy Drink Collector" in Python3
inpl = lambda: list(map(int,input().split()))
N,M = inpl()
A = []
for i in range(N):
  A.append(inpl())
A.sort(key=lambda x: x[0])
ans = 0
for i in range(N):
  if A[i][1] &amp;gt;= M:
    ans += A[i][0]*M
    break
  else:
    M -= A[i][1]
    ans += A[i][0]*A[i][1]
print(ans) &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらは最大466msでクリア(同一コードのPyPy3では733ms)。ここで134msのテストもJuliaではタイムアウト。悲しい。
今回Juliaでタイムアウトになったのは、言語の特性や正しいコーディングの仕方を知らないから、という可能性は高いです。ただ実際にこの問題でJuliaを使って提出されている答案は、最速クリアのものでも1724ms(そもそもJuliaでの提出数自体が少ないですが)。やはり上の安直なPythonコードが圧勝しています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Juliaは競技プログラミングに向かない?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Juliaの実行速度が速いこと自体は(今回検証していませんが、きっと)本当なんだと思います。しかしそれは時間のかかる複雑・大規模な処理の場合であって、競技プログラミングのような高々2-3秒の計算にはコンパイルのオーバーヘッドがやはり大きいのかな、という印象です。
AtCoderなどでは、C++などのあからさまなコンパイル型言語はコンパイル時間が実行時間に算入されず、一方でJuliaに対しては算入されます。やや理不尽な感じはしなくもないけれど、このルール下でJuliaの高速性能を生かすことは(あくまでAtCoderのような短時間型競技プログラミングの話ですが)なかなか難しそう。残念ながら、普通にやるとPythonよりもずっと遅い。
なので、当面の競技プログラミング用言語はやっぱりPython(とC/C++)、と個人的には結論づけたところです。おしまい。&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>Kallistoを用いたRNA-seq解析パイプライン</title><link href="http://oumpy.github.io%5Carticles/2019/04/kallisto_rnaseq_pipeline.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>平岡</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/kallisto_rnaseq_pipeline.html</id><summary type="html"></summary><content type="html">&lt;p&gt;!!!!!!!!!!! 
今回はKallistoを用いたRNA-seq解析パイプラインを紹介しま
す。&lt;a href="https://pythonoum.wordpress.com/2018/10/16/linux%E3%81%A7%E3%81%AEbioinformatics%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89_01/"&gt;LinuxでのBioinformatics環境構築_01&lt;/a&gt;でこの記事への準備はすべて終了している流れになります。&lt;a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%82%B9%E3%83%88_(%E5%B0%8F%E6%83%91%E6%98%9F)"&gt;Kallisto&lt;/a&gt;は小惑星の名前のようです。つっこみどころありましたら、コメントいただけると嬉しいです！それではいきましょう！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;リファレンスのダウンロード&lt;/em&gt;&lt;/strong&gt;
kallistoでは、transcriptにシュードアラインメントするので、リファレンスにはcDNAを用います。今回は&lt;a href="https://www.gencodegenes.org/"&gt;GenCodeGenes&lt;/a&gt;のヒトtranscript sequencesのデータを用いました。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/gencode.v29.transcripts.fa.gz
[/code]&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;FASTQファイルをダウンロードする場合&lt;/em&gt;&lt;/strong&gt;
&lt;a href="https://www.ebi.ac.uk/arrayexpress/"&gt;ArrayExpress&lt;/a&gt;からFASTQファイルをダウンロード、解凍する。今回のデータは、ヒトES細胞と成熟膵島細胞のデータ。single-end readとなっている。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR266/ERR266335/ERR266335.fastq.gz
$ gunzip ERR266335.fastq.gz
[/code]&lt;/p&gt;
&lt;p&gt;ERR266349 ERR266351 ERR266338 ERR266347についても同様に！&lt;/p&gt;
&lt;p&gt;参照：次世代シークエンサーDRY解析教本 (細胞工学別冊)&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SRAファイルをダウンロードする場合&lt;/em&gt;&lt;/strong&gt;
DDBJの&lt;a href="https://ddbj.nig.ac.jp/DRASearch/"&gt;DRA search&lt;/a&gt;からSRAファイルをダウンロード、SRAファイルをFASTQに変換する。pfast-dumpで .sraをペアエンド.fastqに変換。 (&lt;strong&gt;kallistoはsraファイルを扱えない&lt;/strong&gt;ので、pfastq-dumpでfastqに変換する必要がある。）&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;!/bin/bash&lt;/h1&gt;
&lt;h1&gt;download sra files.&lt;/h1&gt;
&lt;p&gt;mkdir sra-fastq
id=(ERR266335 ERR266337 ERR266338 ERR266347 ERR266349 ERR266351)
for item in ${id[@]}
do
echo start download ${item}.sra
wget ftp://ftp.ddbj.nig.ac.jp/ddbj_database/dra/sralite/ByExp/litesra/ERX/ERX182/ERX182652/${item}/${item}.sra
pfastq-dump -s ${item} -t 8 -O sra-fastq
done
[/code]&lt;/p&gt;
&lt;p&gt;pfastq-dumpのオプション
-s: SRAファイルのID
-t: スレッド数
-O: 出力ファイル&lt;/p&gt;
&lt;p&gt;今回はSRAファイルのダウンロードとpfastq-dumpを使ってsraをfastqに変換する処理を&lt;a&gt;シェルスクリプト&lt;/a&gt;を使って行いました。共通項のあるかつ時間のかかるterminalでの処理はシェルスクリプトを使うと便利です。&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;SRAファイルとは？&lt;/p&gt;
&lt;p&gt;Sequence Read Archiveの略。（かつてはNGSにリードが短い特徴があったのでShort Read Archiveと呼ばれていた。）NGSの登場により配列の品質情報を塩基配列とともに記述形式であるFASTQ形式が使用されるようになった時にできたバイナリ形式のデータフォーマット。よってpfastq-dumpなどのツールでFASTQに変換することができる。&lt;a href="https://en.wikipedia.org/wiki/International_Nucleotide_Sequence_Database_Collaboration"&gt;INSDC&lt;/a&gt;、&lt;a href="https://en.wikipedia.org/wiki/European_Bioinformatics_Institute"&gt;EBI&lt;/a&gt;、&lt;a href="https://en.wikipedia.org/wiki/DNA_Data_Bank_of_Japan"&gt;DDBJ&lt;/a&gt;が共同で運営しているデータベース&lt;a href="https://en.wikipedia.org/wiki/Sequence_Read_Archive"&gt;SRA&lt;/a&gt;に保存してある。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ less ERR266335.sra
[/code]&lt;/p&gt;
&lt;p&gt;バイナリデータなので、SRAファイルの中をのぞいてみると下のようになる。
&lt;img class="alignnone size-full wp-image-308" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-19-29-38.png" alt="Screen Shot 2018-10-31 at 19.29.38.png" width="488" height="250" /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;pfastq-dumpとは？
fastq-dumpを並列処理するbashスクリプト。Sequence Read Archive（wiki）からダウンロードされたシーケンスデータ（SRAフォーマット ）をfastq-dumpの並列処理で素早くfastqに変換することができる。&lt;a href="https://github.com/inutanoOhta"&gt;Ohta&lt;/a&gt;さんが公開されている。&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Fastqc&lt;/em&gt;&lt;/strong&gt;
クオリティチェック。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;!/bin/bash&lt;/h1&gt;
&lt;p&gt;id=(ERR266335 ERR266337 ERR266338 ERR266347 ERR266349 ERR266351)
mkdir fastqc
for item in ${id[@]}
do
echo start quality check ${item}
mkdir fastqc/fastqc_${item}
fastqc -t 8 -o fastqc/fastqc_${item} sra-fastq/${item}.fastq -f fastq
done&lt;/p&gt;
&lt;p&gt;[/code]&lt;/p&gt;
&lt;p&gt;sra-fastq/${item}.fastqがインプットファイル。
fastqcのオプションについて
-t: スレッド数。
-O: 解析結果の保存先のディレクトリを指定する。今回はfastqcというディレクトリを作ってそこに入れている。
-f: インプットファイルのフォーマット。bam, samにも対応。.fastq.gzもfastqで指定する。&lt;/p&gt;
&lt;p&gt;実行結果は下記のようになる。
&lt;img class="alignnone size-full wp-image-309" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-19-58-17.png" alt="Screen Shot 2018-10-31 at 19.58.17.png" width="355" height="253" /&gt;&lt;/p&gt;
&lt;p&gt;fastqcディレクトリをのぞいてみる。fastqcのなかにfastqc_${item}というディレクトリが自動生成されている。&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-310" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-20-05-02.png" alt="Screen Shot 2018-10-31 at 20.05.02.png" width="829" height="32" /&gt;&lt;/p&gt;
&lt;p&gt;fastqc_ERR266335の中をのぞいてみると。htmlファイルとzipファイルが生成されている。
&lt;img class="alignnone size-full wp-image-311" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-20-07-03.png" alt="Screen Shot 2018-10-31 at 20.07.03.png" width="358" height="25" /&gt;&lt;/p&gt;
&lt;p&gt;htmlファイルをブラウザでいることができる。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ open ERR266335_fastqc.html
[/code]&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-312" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-20-09-37.png" alt="Screen Shot 2018-10-31 at 20.09.37.png" width="1013" height="554" /&gt;&lt;/p&gt;
&lt;p&gt;参照：次世代シークエンサーDRY解析教本&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Multiqc&lt;/em&gt;&lt;/strong&gt;
クオリティチェックの結果、ログファイルなどをまとめていい感じにレポートにしてくれるツール。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;After analysis, run Multiqc by commands below. You can create report.&lt;/h1&gt;
&lt;p&gt;$ multiqc .
$ open multiqc_report.html
[/code]&lt;/p&gt;
&lt;p&gt;multiqcの実行により、関連ファイルが下記のように自動生成される。
&lt;img class="alignnone size-full wp-image-314" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-22-at-21-20-18.png" alt="Screen Shot 2018-10-22 at 21.20.18.png" width="627" height="138" /&gt;
複数のリードのクオリティチェックの結果を同時に表示できる。
&lt;img class="alignnone size-full wp-image-313" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-31-at-20-02-17.png" alt="Screen Shot 2018-10-31 at 20.02.17.png" width="1065" height="466" /&gt;
参照：https://multiqc.info/&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Trimmomatic&lt;/em&gt;&lt;/strong&gt;
Java で書かれているアダプタートリミングツールである。 Trimmomatic はアダプターの除去のみならず、リードの末端から一定数の塩基をトリムしたりする、簡単なクオリティフィルタリングも行える。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ trimmomatic SE -phred33 ERR266335.fastq output_ERR266335.fastq ILLUMINACLIP:adapters.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36
[/code]&lt;/p&gt;
&lt;p&gt;SEオプションでsingle-end readを指定している。pair-end readでは、オプションでPEとかき、paired outputとunpaired outputの出力先２つを指定する必要がある。&lt;/p&gt;
&lt;p&gt;ILLUMINACLIP: 除去するアダプター配列をFASTA形式で与える。そのあとにミスマッチ許容数、palindrome clip threshold、simple clip thresholdの順に指定していく。&lt;/p&gt;
&lt;p&gt;参照
https://bi.biopapyrus.jp/rnaseq/qc/trimmomatic.html
http://www.usadellab.org/cms/?page=trimmomatic&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Coffee Break&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;Single-end&lt;/strong&gt;, &lt;strong&gt;Pair-end&lt;/strong&gt;ってなに？？
&lt;img class="size-full wp-image-233" src="https://pythonoum.files.wordpress.com/2018/10/img_1051.jpg" width="638" height="479" /&gt;&lt;img class="size-full wp-image-232" src="https://pythonoum.files.wordpress.com/2018/10/img_1050.jpg" width="689" height="445" /&gt;
シーケンスする機器によって、cDNAのかた方のみ読む(single-end read)方法と両端を読む(pair-end read)方法があります。トリミング、アラインメントにおいて、single-endなのか、pair-endなのかを指定しあげる必要があります。&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Kallisto&lt;/em&gt;&lt;/strong&gt;
RNA-Seqデータ、またはより一般的にはハイスループットシーケンシングリードを用いて転写産物の量を定量化するためのプログラムである。&lt;/p&gt;
&lt;p&gt;kallisto や Salmon を利用して定量したデータを使って、edgeR や DESeq2 などで発現量の群間比較を行うことができる。この際に、Bioconductor の tximport パッケージを利用することで、簡単に kallisto/Salmon の定量結果を edgeR/DESEq2 に渡すことができる。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ time kallisto/kallisto index -i hsGRCh38_kallisto Homo_sapiens.GRCh38.rna.fa.gz&lt;/p&gt;
&lt;p&gt;$ time kallisto/kallisto quant -i hsGRCh38_kallisto sra_fastqc/ERR266335.fastq -o ERR266335exp_kallisto
[/code]&lt;/p&gt;
&lt;p&gt;kallisto quantにおいて、&lt;strong&gt;-iと-oのオプションは強制&lt;/strong&gt;である。
-i:作成したインデックスの指定
-o:出力結果の保存先
&lt;strong&gt;デフォルトではペアエンドを読もうとする&lt;/strong&gt;ので、シングルリードの場合は--singleオプションをつける。シングルの時は
-s:Estimated standard deviation of fragment lengthシーケンシング用のライブラリー中のフラグメントの長さの偏差
-l:Estimated average fragment lengthシーケンシング用のライブラリー中のフラグメントの長さの平均
のオプションを追加するのが必須となる。
(kallistoはsraファイルを扱えないので、pfastq-dumpでfastqに変換する必要があった。)
ERR266337 ERR266349 ERR266351 ERR266338 ERR266347も同様に&lt;/p&gt;
&lt;p&gt;kallisto_quant.shというシェルスクリプトを書き実行した。今回に限らず、時間がかかるかつ繰り返しの処理はシェルスクリプトを書くと良い（私もこれから練習します）。&lt;/p&gt;
&lt;p&gt;[code lang="text"]&lt;/p&gt;
&lt;h1&gt;!/bin/bash&lt;/h1&gt;
&lt;p&gt;id=(ERR266335 ERR266337 ERR266349 ERR266351 ERR266338 ERR266347)
for item in ${id[@]}
do
echo start mapping ${item} with Kallisto
result_dir=${item}_exp_kallisto
kallisto/kallisto quant -i hsGRCh38_kallisto -o ${item} --single -l 200 -s 20 -b 100 sra_fastqc/${item}.fastq
done
[/code]&lt;/p&gt;
&lt;p&gt;abundance.tsv, target_id, length, eff_length, est_counts, tpm&lt;/p&gt;
&lt;p&gt;参照：
https://scilifelab.github.io/courses/rnaseq/labs/kallisto
https://bi.biopapyrus.jp/rnaseq/mapping/kallisto/kallisto-single-end-reads.html
http://kazumaxneo.hatenablog.com/entry/2018/07/14/180503
https://scilifelab.github.io/courses/rnaseq/labs/kallisto&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Coffee Break&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPKM&lt;/em&gt;,&lt;em&gt;RPKM&lt;/em&gt;,&lt;em&gt;TPM&lt;/em&gt;とは？
転写産物にマッピングされるリードの数は、サンプル中の総リード数（sequence depth）と転写産物の長さに影響されるので、RNA-Seq データから得られたリードカウントデータは、そのまま転写産物（遺伝子）発現量を表すわけではない。そのため、RNA-Seq データから得られるリードカウントデータを転写産物発現量として利用するには、総リード数や転写産物長で補正する必要がある。&lt;/p&gt;
&lt;p&gt;補正計算として、かつてはFPKM,RPKMが用いられてきたが、現在ではかわりにTPMが用いられている。TPMではサンプルごとの値の合計が同じになるので、比較する目的のためにはTPMの方が都合が良い。&lt;/p&gt;
&lt;p&gt;FPKM/RPKM の計算&lt;/p&gt;
&lt;p&gt;FPKM: Fragments Per Kilobase of exon per Killion reads Mapped&lt;/p&gt;
&lt;p&gt;RPKM: Reads Per Kilobase of exon per Million mapped reads
&lt;img class="alignnone size-full wp-image-265" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-23-at-0-40-05.png" alt="Screen Shot 2018-10-23 at 0.40.05.png" width="341" height="59" /&gt;&lt;/p&gt;
&lt;p&gt;N: リファレンスにマッピングできた全リード数&lt;/p&gt;
&lt;p&gt;Yi: そのうち転写産物 i の領域にマッピングされたリード数&lt;/p&gt;
&lt;p&gt;Li: 転写産物 i の長さ&lt;/p&gt;
&lt;p&gt;TPMの計算&lt;/p&gt;
&lt;p&gt;TPMの計算&lt;/p&gt;
&lt;p&gt;TPM: Transcripts Per Kilobase Million&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone  wp-image-297" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-28-at-21-48-15.png" alt="Screen Shot 2018-10-28 at 21.48.15.png" width="133" height="92" /&gt;&lt;/p&gt;
&lt;p&gt;Yt : 転写産物 t にマッピングされたリードカウント&lt;/p&gt;
&lt;p&gt;Lt:  転写産物 t の長さ&lt;/p&gt;
&lt;p&gt;Tt: 転写産物 t の 1,000 bp あたりのリード数&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone  wp-image-296" src="https://pythonoum.files.wordpress.com/2018/10/screen-shot-2018-10-28-at-21-48-28.png" alt="Screen Shot 2018-10-28 at 21.48.28.png" width="197" height="66" /&gt;&lt;/p&gt;
&lt;p&gt;転写産物長による補正後の総リードカウントが 100 万となるように補正&lt;/p&gt;
&lt;p&gt;参照：
&lt;a href="https://bi.biopapyrus.jp/rnaseq/analysis/normalizaiton/fpkm.html"&gt;bipapyrus fpkm&lt;/a&gt;
&lt;a href="https://bi.biopapyrus.jp/rnaseq/analysis/normalizaiton/tpm.html"&gt;bipapyrus tpm&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Tximport, DESeq2を用いた解析はコメントをいただき、ただ今編集中となっております。少々お待ちください。&lt;/li&gt;
&lt;/ul&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>カプランマイヤー曲線について</title><link href="http://oumpy.github.io%5Carticles/2019/04/kaplan_meier_curve.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>佐藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/kaplan_meier_curve.html</id><summary type="html"></summary><content type="html">&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;a class="anchor-link" href="#はじめに"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="書こうと思ったきっかけ"&gt;書こうと思ったきっかけ&lt;a class="anchor-link" href="#書こうと思ったきっかけ"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

実習中論文を頂いて読む機会が多いが、医学論文は薬は新しい治療方法の成績を比較しているのが多い。
だいたいKaplan-Meier曲線が使われているので(偏見)、論文を読むときにはもちろん、将来自分が論文を執筆するときに、何が行われているのか少しでも理解できていればいいかなと思いまとめてみた。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="Kaplan-Meier-曲線とは"&gt;Kaplan-Meier 曲線とは&lt;a class="anchor-link" href="#Kaplan-Meier-曲線とは"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

&lt;a href="https://ja.wikipedia.org/wiki/%E7%94%9F%E5%AD%98%E7%8E%87%E6%9B%B2%E7%B7%9A"&gt;wikipedia&lt;/a&gt;によると「治療を行った後の患者の生存率をグラフにしたもの」ということらしい。
ただ、実際には問題がいくつかあって
&lt;ul&gt;
    &lt;li&gt;観察期間は限られている(患者さんを何年もフォローすることはできない)&lt;/li&gt;
    &lt;li&gt;観察不能になることがある(病院移った、他の要因で死亡したなど)&lt;/li&gt;
    &lt;li&gt;患者さんによって観察開始時間は様々(みんな一緒に罹患したり治療を開始するわけではない)&lt;/li&gt;
&lt;/ul&gt;
そういった問題をうまく対処してくれるのがKaplan-Meier曲線。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

Kaplan-Meier曲線の縦軸は累積生存率で、

&lt;img class="alignnone  wp-image-383" src="https://pythonoum.files.wordpress.com/2018/11/latex_d0d85f9c2273fc8543f95f5a06327b6d.png" alt="latex_d0d85f9c2273fc8543f95f5a06327b6d" width="264" height="51" /&gt;
で表されます。
ここで  &lt;img class="alignnone  wp-image-381" src="https://pythonoum.files.wordpress.com/2018/11/latex_20e446658086133d641a66355d77e99a.png" alt="latex_20e446658086133d641a66355d77e99a" width="18" height="21" /&gt;  は時間jにおける死亡者数で  &lt;img class="alignnone  wp-image-380" src="https://pythonoum.files.wordpress.com/2018/11/latex_9d756a5b30d4e9ae460c9c2cdedc8280.png" alt="latex_9d756a5b30d4e9ae460c9c2cdedc8280" width="20" height="17" /&gt;  は時間jにおける生存者数です。

pythonのコードでKaplan-Meier曲線を書いていこうと思います。
pythonのライブラリにlifelinesという便利なライブラリがあるのでそれを使っていこうと思います。

&lt;code&gt;pip install lifelines&lt;/code&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="データの準備"&gt;データの準備&lt;a class="anchor-link" href="#データの準備"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

ある病気に対する治療法の予後のKaplan-Meier曲線を描きたいとします。
ある期間内に観察された患者の経過をみることになると思いますが、患者さんによって発症する時間も様々なので、イメージとして下の図のようになると思います。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [256]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pd&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;KaplanMeierFitter&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines.plotting&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;plot_lifetimes&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;numpy.random&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exponential&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="k"&gt;matplotlib&lt;/span&gt; inline
&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="k"&gt;config&lt;/span&gt; InlineBackend.figure_format = 'retina'

&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;
&lt;span class="n"&gt;current_time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;48&lt;/span&gt;
&lt;span class="n"&gt;birth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;actual_lifetimes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exponential&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exponential&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="n"&gt;observed_lifetimes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;minimum&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;actual_lifetimes&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;birth&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;current_time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;observed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;birth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;actual_lifetimes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current_time&lt;/span&gt;

&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vlines&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linestyles&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'--'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'red'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"time"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Births and deaths of our population, at $t=48$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plot_lifetimes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;observed_lifetimes&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;birth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;birthtimes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;birth&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Observed lifetimes at time &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt;:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current_time&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;observed_lifetimes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_png output_subarea "&gt;&lt;img src="http://pythonoum.files.wordpress.com/2018/11/e382abe38397e383a9e383b3e3839ee382a4e383a4e383bce69bb2e7b79ae381abe381a4e38184e381a611.png" width="552" height="455" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;Observed lifetimes at time 48:
 [48 47 27 48 48 40 34  3 46 41 40 48 30 48 40 46 48 34 48 48 15 36 38 31
 46 22 44 16 42 48 45 19 46 44 31 16 33  9 32 42 11 36 48 48 44 48 14 39
 37 45]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

赤線では期間内(t=48)に患者さんが死亡したケース、青線は観測不能になったケースです(観察期間終わったからそれ以上追えない)。

簡単のため、観測不能になったケースは観測期間が終わった場合のみとします。観察期間の長さでソートすると、下の図のようになります。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [237]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;observed_lifetimes&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;birth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort_values&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'time'&lt;/span&gt;
&lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result_lifetimes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;

&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#plt.vlines(22, 0, 30, lw=2, linestyles='--',colors='red')&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"time"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Births and deaths of our population, at $t=22$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plot_lifetimes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result_lifetimes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_png output_subarea "&gt;&lt;img src="http://pythonoum.files.wordpress.com/2018/11/e382abe38397e383a9e383b3e3839ee382a4e383a4e383bce69bb2e7b79ae381abe381a4e38184e381a621.png" width="552" height="455" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="実際の計算"&gt;実際の計算&lt;a class="anchor-link" href="#実際の計算"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

さっき作ったデータを使って、累積生存率を計算していきます。たとえばt=5における累積生存率を計算するとき、

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [238]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt output_prompt"&gt;Out[238]:&lt;/div&gt;
&lt;div class="output_html rendered_html output_subarea output_execute_result"&gt;
&lt;div&gt;
&lt;table class="dataframe" border="1"&gt;
&lt;thead&gt;
&lt;tr style="text-align:right;"&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

Trueが患者さんが死亡したのを観測できた事例、Falseが観察期間終了により観測できなかった事例です。観察期間の短い順に見ていくと、

t=1のとき、50人のうち2人が死亡,1人が打ち切り。

t=2のとき、死亡者、打ち切りなし。
t=3の時は４７人のうち１人が死亡。

t=4の時は46人のうち２人が死亡、２人が打ち切り。

t=5の時は42人中１人死亡、３人が打ち切り。
よって  &lt;img class="alignnone  wp-image-379" src="https://pythonoum.files.wordpress.com/2018/11/latex_1c2bcee94b7caf339ec07fd8bd6b2e53.png" alt="latex_1c2bcee94b7caf339ec07fd8bd6b2e53" width="29" height="17" /&gt;  は
&lt;img class="alignnone size-full wp-image-382" src="https://pythonoum.files.wordpress.com/2018/11/latex_a5574b96513bc29d4f475ee3dd106ce1.png" alt="latex_a5574b96513bc29d4f475ee3dd106ce1" width="2574" height="101" /&gt;
となります。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="結果のプロット"&gt;結果のプロット&lt;a class="anchor-link" href="#結果のプロット"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

ここら辺の計算と描画はライブラリに任せます。

やってることは各期間の点における累積生存率をプロットして線を横に伸ばすだけです。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [233]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="n"&gt;kmf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KaplanMeierFitter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;kmf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result_lifetimes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;kmf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Survival function of political regimes'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_png output_subarea "&gt;&lt;img src="http://pythonoum.files.wordpress.com/2018/11/e382abe38397e383a9e383b3e3839ee382a4e383a4e383bce69bb2e7b79ae381abe381a4e38184e381a631.png" width="549" height="454" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="乳がんデータセットを用いて解析を行った例"&gt;乳がんデータセットを用いて解析を行った例&lt;a class="anchor-link" href="#乳がんデータセットを用いて解析を行った例"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

一応これで生存曲線は描けた訳ですが、もし治療の有効性を示すのであれば、他の治療群と比較して、有効性を示さなければいけません。

ここから使われる統計手法はLog-rank検定、一般化wilcoxon検定など様々ですが、ここではcox比例ハザードを使った回帰分析を例にして解析を進めていきます。

cox比例ハザードモデルに関する説明は&lt;a href="http://www012.upp.so-net.ne.jp/doi/biostat/CT39/Cox.pdf"&gt;ここ&lt;/a&gt;がわかりやすかった。

lifelinesライブラリに乳がんの予後のデータセットがあるのでそれを用います。

乳がんの治療でどのような因子が予後のに影響を及ぼすのか調べてみます。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [263]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="c1"&gt;# hormone therapyの有無で2群に分けKaplan-Meier曲線を描いた例&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines.datasets&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;load_gbsg2&lt;/span&gt;
&lt;span class="n"&gt;df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;load_gbsg2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'horTh'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;kmf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KaplanMeierFitter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;kmf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'time'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'cens'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
            &lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'hormone therapy ='&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# 描画する Axes を指定。None を渡すとエラーになるので場合分け&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kmf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;ax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kmf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Kaplan-Meier Curve'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_png output_subarea "&gt;&lt;img src="http://pythonoum.files.wordpress.com/2018/11/e382abe38397e383a9e383b3e3839ee382a4e383a4e383bce69bb2e7b79ae381abe381a4e38184e381a641.png" width="549" height="454" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [264]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CoxPHFitter&lt;/span&gt;
&lt;span class="n"&gt;cph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CoxPHFitter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_dummies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'horTh'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'menostat'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;drop_first&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'tgrade'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;inplace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cph&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;duration_col&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'time'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_col&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'cens'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;show_progress&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;Out[264]:&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;Iteration 1: norm_delta = 0.63685, step_size = 0.95000, ll = -1788.10474, seconds_since_start = 0.0
Iteration 2: norm_delta = 0.28516, step_size = 0.95000, ll = -1781.26562, seconds_since_start = 0.0
Iteration 3: norm_delta = 0.09501, step_size = 0.95000, ll = -1745.22376, seconds_since_start = 0.1
Iteration 4: norm_delta = 0.02423, step_size = 0.95000, ll = -1740.89966, seconds_since_start = 0.1
Iteration 5: norm_delta = 0.00263, step_size = 0.95000, ll = -1740.66192, seconds_since_start = 0.1
Iteration 6: norm_delta = 0.00015, step_size = 0.95000, ll = -1740.65941, seconds_since_start = 0.1
Iteration 7: norm_delta = 0.00001, step_size = 0.95000, ll = -1740.65940, seconds_since_start = 0.1
Convergence completed after 7 iterations.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [265]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="n"&gt;cph&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_summary&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;Out[265]:&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;n=686, number of events=299

                coef  exp(coef)  se(coef)       z      p  lower 0.95  upper 0.95     
age          -0.0105     0.9896    0.0093 -1.1296 0.2587     -0.0287      0.0077     
tsize         0.0084     1.0084    0.0039  2.1173 0.0342      0.0006      0.0161    *
pnodes        0.0498     1.0511    0.0074  6.7329 0.0000      0.0353      0.0643  ***
progrec      -0.0026     0.9974    0.0006 -4.4522 0.0000     -0.0037     -0.0015  ***
estrec        0.0002     1.0002    0.0005  0.3843 0.7008     -0.0007      0.0011     
horTh_yes    -0.3643     0.6947    0.1284 -2.8371 0.0046     -0.6159     -0.1126   **
menostat_Pre -0.2767     0.7583    0.1822 -1.5191 0.1287     -0.6338      0.0803     
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Concordance = 0.687
Likelihood ratio test = 94.891 on 7 df, p=0.00000
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [266]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;
&lt;pre&gt;&lt;span class="n"&gt;cph&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt output_prompt"&gt;Out[266]:&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_png output_subarea "&gt;&lt;img src="http://pythonoum.files.wordpress.com/2018/11/e382abe38397e383a9e383b3e3839ee382a4e383a4e383bce69bb2e7b79ae381abe381a4e38184e381a651.png" width="623" height="434" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;a class="anchor-link" href="#まとめ"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;

Kaplan-Meier曲線がどのように作られているか分かった。

pythonを用いて割と簡単に統計解析ができた。

統計モデルについても定義からもう少し詳しく説明できたらよかったが、latex使うのめんどくさくて諦めた。リンク参考にしてください。

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;h3 class="text_cell_render border-box-sizing rendered_html"&gt;参考HP&lt;a class="anchor-link" href="#参考文献"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;a href="https://lifelines.readthedocs.io/en/latest/index.html"&gt;lifelines公式HP&lt;/a&gt;
&lt;a href="https://istat.co.jp/sk_commentary/kaplan_meier"&gt;相関、検定の手法別解説&lt;/a&gt;
&lt;a href="http://www.emalliance.org/%E6%9C%AA%E5%88%86%E9%A1%9E/%E7%AC%AC%EF%BC%97%E5%9B%9Eema-jc%E3%80%80%E8%A7%A3%E8%AA%AC%E3%80%80%E3%82%AB%E3%83%97%E3%83%A9%E3%83%B3%E3%83%9E%E3%82%A4%E3%83%A4%E3%83%BC%E7%94%9F%E5%AD%98%E6%9B%B2%E7%B7%9A"&gt;EM Aliance&lt;/a&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content><category term="tech_archive"></category><category term="statistics"></category></entry><entry><title>MACS2とdeepToolsのbigwigファイルの比較</title><link href="http://oumpy.github.io%5Carticles/2019/04/macs2_deeptools.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/macs2_deeptools.html</id><summary type="html"></summary><content type="html">&lt;h3&gt;ChIP-seqとは&lt;/h3&gt;
&lt;p&gt;全身で37兆個あるといわれているヒトの細胞は、基本的にすべて同じDNA配列を有している。しかし、肝細胞、網膜、免疫細胞と細胞にはそれぞれの"個性"がある。更には正常の免疫細胞と暴走している免疫細胞など細胞には"状態"もある。これらを制御する大きな要素としてエピジェネティクスが挙げられ、DNAメチル化やクロマチン修飾などが知られている。ChIP-seq (chromatin immunoprecipitation sequence) は特異的クロマチン修飾を受けている領域を、抗体を用いて沈降、濃縮させ、どの細胞のどの領域でどういう修飾を受けているのかを調べるために用いられる。&lt;/p&gt;
&lt;h3&gt;今回のきっかけ&lt;/h3&gt;
&lt;p&gt;ChIP-seqの解析をする時に便利なフォーマットにbigwigがある。igvで表示したり、coverageを計算したり、様々な用途で使える。詳しくはdrbonobon（第一版）のp118に記載されている。ChIP-seqの解析には&lt;a href="https://github.com/taoliu/MACS"&gt;MACS2&lt;/a&gt;というソフトが良く使われ、bigwigの生成も可能だが、&lt;a href="https://deeptools.readthedocs.io/en/develop/index.html"&gt;deepTools&lt;/a&gt;でも&lt;code&gt;​bamCoverage&lt;/code&gt;や​&lt;code&gt;​bamComapre&lt;/code&gt;機能を使ってbigwigを作ることができる。挙動や使い所の違いを比較しようというのが今回の目的。&lt;/p&gt;
&lt;p&gt;ちなみに、通常のChIP-seq解析ならMACS2,HOMERなどを使ってやるのが無難かと思います。今回はdeeptToolsと戯れたかった。&lt;/p&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ conda install -c bioconda deeptools

$ conda create -n py27_macs2 &lt;span class="nv"&gt;python&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.7.5
$ conda activate py27_macs2
$ conda install -c bioconda macs2
$ conda install -c bioconda bedtools
$ conda install -c bioconda ucsc-bedgraphtobigwig
$ conda install -c bioconda ucsc-bedclip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;condaでmacs2を入れようとするとxonshとdependency conflictしてしまった。諦めて仮想環境を作る。condaは入ってる前提。MACS2はいまだにpython2な時点で腰が引けるが、先に進む。&lt;/p&gt;
&lt;p&gt;※ python2.7.4以前だとエラーを吐くらしいので、python2.7.5にしてある。今考えると2.7.15でも良かったかもしれない。&lt;/p&gt;
&lt;h3&gt;今回使うsample&lt;/h3&gt;
&lt;p&gt;うちのラボの論文のデータを使ってみます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kitagawa, Y. et al. Guidance of regulatory T cell development by Satb1-dependent super-enhancer establishment. Nat. Immunol. 18, (2016).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここからH3K27acのTregとTconvを使ってみます。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SRR ID&lt;/th&gt;
&lt;th&gt;sample&lt;/th&gt;
&lt;th&gt;replicate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SRR5385260&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRR5385344&lt;/td&gt;
&lt;td&gt;Treg H3K27ac&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRR5385345&lt;/td&gt;
&lt;td&gt;Treg H3K27ac&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRR5385346&lt;/td&gt;
&lt;td&gt;Tconv H3K27ac&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SRR5385347&lt;/td&gt;
&lt;td&gt;Tconv H3K27ac&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これらをお馴染みpfastq-dumpをつかって落としてきます。今回はSingle-endなのでsplitはいりません。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ mkdir data
$ prefetch SRR5385260 SRR5385344 SRR5385345 SRR5385346 SRR5385347
$ bash pfd.sh
$ fastqc -t &lt;span class="m"&gt;22&lt;/span&gt; -o data data/*.fastq
$ multiqc -n multiqc_report_raw.html ./data
$ bash make_bam.sh
$ fastqc -t &lt;span class="m"&gt;22&lt;/span&gt; -o data data/*.trimmed.fastq
$ multiqc -n multiqc_report_trimmed.html ./data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pdf.shは&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;sras&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SRR5385260&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385344&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385345&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385346&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385347&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; s in &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;sras&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
pfastq-dump --threads &lt;span class="m"&gt;22&lt;/span&gt; --outdir data ~/ncbi/public/sra/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.sra
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;make_bam.sh&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;sras&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SRR5385260&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385344&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385345&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385346&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SRR5385347&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; s in &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;sras&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
trimmomatic &lt;span class="se"&gt;\&lt;/span&gt;
    SE                  &lt;span class="se"&gt;\&lt;/span&gt;
    -threads &lt;span class="m"&gt;22&lt;/span&gt;         &lt;span class="se"&gt;\&lt;/span&gt;
    -phred33            &lt;span class="se"&gt;\&lt;/span&gt;
    -trimlog log.&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.txt    &lt;span class="se"&gt;\&lt;/span&gt;
    data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.fastq            &lt;span class="se"&gt;\&lt;/span&gt;
    data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.fastq          &lt;span class="se"&gt;\&lt;/span&gt;
    ILLUMINACLIP:adapters.fa:2:10:10  &lt;span class="se"&gt;\&lt;/span&gt;
    LEADING:20 &lt;span class="se"&gt;\&lt;/span&gt;
    TRAILING:20 &lt;span class="se"&gt;\&lt;/span&gt;
    MINLEN:30
bowtie2 -p &lt;span class="m"&gt;22&lt;/span&gt; -x ~/ref_sequence/bowtie2_indexes/mm10 -U data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.fastq -S data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.sam &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; data/out.&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.txt
samtools sort -O bam -o data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.bam data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.sam
samtools index data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.bam data/&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.trimmed.bai
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改行とコメントがうまく共存できなかったので、以下に注釈付きを示す。より詳しいことはおなじみ&lt;a href="https://bi.biopapyrus.jp/rnaseq/qc/trimmomatic.html"&gt;biopnpyrus&lt;/a&gt;を参照。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;trimmomatic \
    SE                  \  # single-end
    -threads 22         \  # スレッド数
    -phred33            \  # phred33 または -phred64 を指定
    -trimlog log.&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.txt    \  # 実行ログの保存先
    data/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.fastq            \  # 入力 FASTQ
    data/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.trimmed.fastq          \  # 出力 FASTQ
    ILLUMINACLIP:adapters.fa:2:10:10  \ # アダプター除去条件の指定
    LEADING:20 \
    TRAILING:20 \
    MINLEN: 30   # 30bp を満たさないリードを除去
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これでbamファイルが出来ているはず。&lt;/p&gt;
&lt;p&gt;igvで表示してみるとこんな感じ。
&lt;img src="https://pythonoum.files.wordpress.com/2018/10/screenshot-from-2018-10-28-20-04-52.png" alt="Screenshot from 2018-10-28 20-04-52.png" width="2015" height="965" class="alignnone size-full wp-image-291" /&gt;&lt;/p&gt;
&lt;h4&gt;補足 prefetchのoutputを変更する方法（Yoshiharaさんより）&lt;/h4&gt;
&lt;p&gt;デフォルトではプロジェクトのディレクトリの外にsraファイルを保存してしまう。また、データ用のストレージを分けている際もそちらに書き出してやりたい。そこでprefetchのoutputを変更したいという話になるわけだが、やり方は2つ。&lt;/p&gt;
&lt;p&gt;1)
&lt;a href="https://github.com/ncbi/sra-tools/wiki/Toolkit-Configuration"&gt;Toolkit-Configuration&lt;/a&gt;をいじる方法。
公式にはこちらが推奨らしいが操作が面倒。&lt;/p&gt;
&lt;p&gt;2)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;echo ‘/repository/user/main/public/root = “/outputDir”‘ &amp;amp;gt; ~/.ncbi/user-settings.mkfg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;こっちのほうが簡単。outputDirに指定してやって下さい。
この例だとpfastq-dumpでは~/ncbi/public/sra/${s}.sraが/outputDir/sra/${s}.sraになりますね。&lt;/p&gt;
&lt;h3&gt;MACS2によるピークコール&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Zhang, Y. et al. Model-based Analysis of ChIP-Seq (MACS). Genome Biol. 9, R137 (2008).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ChIP-seq解析の定番ツールであるMACS2を使う。説明は&lt;a href="https://github.com/taoliu/MACS/wiki"&gt;公式wiki&lt;/a&gt;が詳しい。bigwigはpeakcallの副産物的な扱いで、メインはChIP-seqのピーク情報。bigwigは少し回りくどい作り方が必要。詳しくは&lt;a href="https://github.com/taoliu/MACS/wiki/Build-Signal-Track"&gt;こちら&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;まずはbdg2bwを用意する。&lt;code&gt;~/Programs&lt;/code&gt;はpathの通ったディレクトリとする。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ vim ~/Programs/bdg2bw &lt;span class="c1"&gt;# emacsでも。中身は以下。&lt;/span&gt;
$ chmod &lt;span class="m"&gt;755&lt;/span&gt; ~/Programs/bdg2bw
$ wget http://hgdownload.cse.ucsc.edu/goldenPath/mm10/database/chromInfo.txt.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bdg2bwの中身は以下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="c1"&gt;# check commands: slopBed, bedGraphToBigWig and bedClip&lt;/span&gt;

which bedtools &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt;/dev/null &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;bedtools not found! Download bedTools: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
which bedGraphToBigWig &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt;/dev/null &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;bedGraphToBigWig not found! Download: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
which bedClip &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt;/dev/null &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;bedClip not found! Download: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;# end of checking&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$#&lt;/span&gt; -lt &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Need 2 parameters!  &amp;quot;&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;span class="nv"&gt;G&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;

bedtools slop -i &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; -g &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;G&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; -b &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; bedClip stdin &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;G&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.clip

&lt;span class="nv"&gt;LC_COLLATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C sort -k1,1 -k2,2n &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.clip &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.sort.clip

bedGraphToBigWig &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.sort.clip &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;G&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="p"&gt;/bdg/bw&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;

rm -f &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.clip &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;F&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.sort.clip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これで実行準備が整った。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ conda activate py27_macs2
$ mkdir macs2 &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; macs2
$ macs2 callpeak -t ../data/SRR5385344.trimmed.bam -c ../data/SRR5385260.trimmed.bam -g mm -n Treg_H3K27ac_1 -p 1e-5 -f BAM -B --nomodel &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; macs.SRR5385344.out &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; bdg2bw Treg_H3K27ac_1_treat_pileup.bdg ../chromInfo.txt
$ macs2 callpeak -t ../data/SRR5385345.trimmed.bam -c ../data/SRR5385260.trimmed.bam -g mm -n Treg_H3K27ac_2 -p 1e-5 -f BAM -B --nomodel &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; macs.SRR5385345.out &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; bdg2bw Treg_H3K27ac_2_treat_pileup.bdg ../chromInfo.txt
$ macs2 callpeak -t ../data/SRR5385346.trimmed.bam -c ../data/SRR5385260.trimmed.bam -g mm -n Tconv_H3K27ac_1 -p 1e-5 -f BAM -B --nomodel &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; macs.SRR5385346.out &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; bdg2bw Tconv_H3K27ac_1_treat_pileup.bdg ../chromInfo.txt
$ macs2 callpeak -t ../data/SRR5385347.trimmed.bam -c ../data/SRR5385260.trimmed.bam -g mm -n Tconv_H3K27ac_2 -p 1e-5 -f BAM -B --nomodel &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; macs.SRR5385347.out &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&amp;amp;&lt;/span&gt;amp&lt;span class="p"&gt;;&lt;/span&gt; bdg2bw Tconv_H3K27ac_2_treat_pileup.bdg ../chromInfo.txt
$ &lt;span class="nb"&gt;cd&lt;/span&gt; ..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-B&lt;/code&gt;でbdgというbedgraphファイルを保存するかどうか。
&lt;code&gt;--nomodel&lt;/code&gt;はshifting modelを作るかどうか。defaultでshiftは100。
実際はigvにはbdgファイルも読み込めてしまうので、特にbigwigにする必要はなかった。&lt;/p&gt;
&lt;h3&gt;deepToolsによるbwファイルの生成&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2018/10/start_workflow1.png" alt="start_workflow1" width="1852" height="645" class="alignnone size-full wp-image-259" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ramírez, F. et al. deepTools2: a next generation web server for deep-sequencing data analysis. Nucleic Acids Res. 44, W160–W165 (2016).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MAX PLANCK INSTITUTE製のツールで、ChIP-seq, RNA-seq, MNase-seqなどに使えるツールとされている。多サンプルの比較などに向いている。QCや美しいvisualizationが可能。さらにdeepBlueの大量のデータも使える。CLIではもちろんのこと、Galaxyにも対応しているので、そちらでもいいし、Pythonで書かれていてAPIのドキュメントも手厚いのでそちらを使ってもいい。（ちょっとむずかしい。）&lt;/p&gt;
&lt;p&gt;今回はinputがあるので&lt;code&gt;bamCompare&lt;/code&gt;を使う。log2ratioがbwファイルに出力される。果たしていけるのか。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bamCompare&lt;/code&gt;は&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;サンプルごとのスケーリング、depthの正規化&lt;/li&gt;
&lt;li&gt;operation(defaultはlog2ratio)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を行う。binはdefaultで50bp。log2ratioの代わりにlog2, ratio, subtract, add, mean, reciprocal_ratio, first, secondを取得することもできる。今回はsubtract(差分)も合わせて取得してみる。macs2と違ってmultiprocessも動くが、bamのindexが先に必要。macs2に比べるととてもsimpleでよい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ mkdir deepTools    
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; -b1 ./data/SRR5385344.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Treg_H3K27ac_1_log2ratio.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; -b1 ./data/SRR5385345.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Treg_H3K27ac_2_log2ratio.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; -b1 ./data/SRR5385346.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Tconv_H3K27ac_1_log2ratio.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; -b1 ./data/SRR5385347.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Tconv_H3K27ac_2_log2ratio.bw

$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; --operation subtract -b1 ./data/SRR5385344.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Treg_H3K27ac_1_subtract.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; --operation subtract -b1 ./data/SRR5385345.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Treg_H3K27ac_2_subtract.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; --operation subtract -b1 ./data/SRR5385346.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Tconv_H3K27ac_1_subtract.bw
$ bamCompare -p &lt;span class="m"&gt;22&lt;/span&gt; --operation subtract -b1 ./data/SRR5385347.trimmed.bam -b2 ./data/SRR5385260.trimmed.bam -o deepTools/Tconv_H3K27ac_2_subtract.bw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;※ 181107 subtractのoutput fileが間違えていたので修正しました。（Yoshiharaさんより）&lt;/p&gt;
&lt;h3&gt;igvによる比較&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2018/10/screenshot-from-2018-10-28-20-36-19.png" alt="Screenshot from 2018-10-28 20-36-19.png" width="2009" height="957" class="alignnone size-full wp-image-294" /&gt;&lt;/p&gt;
&lt;p&gt;上からmacs2, deepTools subtract, deepTools log2 fold changeになっている。macs2の結果はdeepToolsのsubtractに近いことがわかる。&lt;/p&gt;
&lt;p&gt;macs2のsummits.bedとnarrowPeakも表示してみた（下2つ）。これはこれで取り回しが効いて良い。narrowPeakはp valueに応じて色が変わっている。&lt;/p&gt;
&lt;p&gt;deepToolsが少しギザギザしているように見えるが、binを変えると細かくできる。&lt;/p&gt;
&lt;h3&gt;おまけ：deepToolsによる可視化&lt;/h3&gt;
&lt;p&gt;最後に、deepToolsの豊富な可視化機能の一部を試してみる。まず、&lt;a href="http://genome.ucsc.edu/cgi-bin/hgTables"&gt;UCSC&lt;/a&gt;よりmm10の遺伝子のbedを取得する。bigwigを用いた可視化は&lt;code&gt;computeMatrix&lt;/code&gt;した後&lt;code&gt;plotHeatmap&lt;/code&gt;などである。log2 fold changeのbigwigを用いて全遺伝子についてH3K27acのheatmapを書き、クラスタリングも同時にしてみる。全遺伝子についてなので&lt;code&gt;computeMatrix&lt;/code&gt;がとても重たくなってしまった。Tconvについては今回は省略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ computeMatrix scale-regions &lt;span class="se"&gt;\&lt;/span&gt;
-S Treg_H3K27ac_1_log2ratio.bw Treg_H3K27ac_2_log2ratio.bw &lt;span class="se"&gt;\&lt;/span&gt;
-R mm10.genes.bed &lt;span class="se"&gt;\&lt;/span&gt;
--beforeRegionStartLength &lt;span class="m"&gt;3000&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--regionBodyLength &lt;span class="m"&gt;5000&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--afterRegionStartLength &lt;span class="m"&gt;3000&lt;/span&gt; --skipZeros -o matrix.mat.Treg.gz -p &lt;span class="m"&gt;8&lt;/span&gt;

&lt;span class="c1"&gt;# 赤が正になってほしいので_rでリバースする。&lt;/span&gt;
$ plotHeatmap -m matrix.mat.Treg.gz -out Heatmap.png &lt;span class="se"&gt;\&lt;/span&gt;
--colorMap RdYlBu_r --zMin -3 --zMax &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--kmeans &lt;span class="m"&gt;4&lt;/span&gt; --samplesLabel Treg_H3K27ac_1  Treg_H3K27ac_2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2018/10/heatmap-3.png" alt="Heatmap.3.png" width="777" height="2288" class="alignnone size-full wp-image-304" /&gt;&lt;/p&gt;
&lt;p&gt;plotHeatmapのクラスタリングは複数のサンプルがある時は１つ目のサンプルでクラスタリングするみたい。せっかく他のサンプルもあるのだから、いろいろ混ぜてクラスタリングできたらいいな。
colormapは&lt;a href="https://matplotlib.org/examples/color/colormaps_reference.html"&gt;matplotlibでおなじみのもの&lt;/a&gt;である。fontsizeは変更する方法は見つからなかった。これは結構困りどころ。強いて言うならissueで自分で書いてみてねとの&lt;a href="https://github.com/deeptools/deepTools/issues/444"&gt;回答&lt;/a&gt;があった。&lt;/p&gt;
&lt;p&gt;deepToolsに関して、いつもお世話になっている&lt;a href="http://kazumaxneo.hatenablog.com/entry/2018/06/25/210934"&gt;macでインフォマティクス&lt;/a&gt;さんにも記事があった。とても詳しい。他にもいろいろな機能があったので是非。&lt;/p&gt;
&lt;h3&gt;感想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;macs2はpeakcallを目的にしていて、副産物としてbigwigやbdgが出力される。deepToolsは複数のChIP-seqデータなどを扱うのに長けている。逆にdeepToolsはpeak call機能がない。&lt;/li&gt;
&lt;li&gt;deepToolsはIHECのQCに使われていたり、bw作成後のdownstream解析もできたり、&lt;a href="https://www.nature.com/articles/s41467-018-02866-0"&gt;RamDA-seq&lt;/a&gt;の解析に使われていたりと、頼れるツールの様なので、早いうちにマスターしようと思う。&lt;/li&gt;
&lt;li&gt;TregとTconvのデータを用意した割にはTreg-specific peaksを見るところまでは手が回らなかった。（論文読めば書いてあるが。)特異的ピーク検出をするなら&lt;a href="http://homer.ucsd.edu/homer/ngs/index.html"&gt;HOMER&lt;/a&gt;が安定感があって良さそうな。&lt;/li&gt;
&lt;li&gt;ChIP-seq解析のいい練習になりました。&lt;/li&gt;
&lt;li&gt;multi-omics人材になるぞ！&lt;/li&gt;
&lt;/ul&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>Bioinformatics春合宿@三島</title><link href="http://oumpy.github.io%5Carticles/2019/04/mishima.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水　平岡</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/mishima.html</id><summary type="html"></summary><content type="html">&lt;p&gt;平岡と安水は2019/03/04-09の一週間、静岡県三島市の国立遺伝学研究所にある&lt;a href="https://dbcls.rois.ac.jp/"&gt;DBCLS&lt;/a&gt;にてbioinformatics合宿をしていました。定量、アセンブリを始めとするトランスクリプトーム解析やjuliaの入門、データベースのコツなど、たくさんのことを学びました。bioinformatics意外にも、坊農さんのグルメツアーや温泉、富士山など、季節ならではの三島を堪能することができました。詳しくは以下の日誌をご覧ください。&lt;/p&gt;
&lt;p&gt;平岡
&lt;a href="https://github.com/yuna06/mishima2019/blob/master/README.md"&gt;mishima2019&lt;/a&gt;
 &lt;/p&gt;
&lt;p&gt;安水
&lt;a href="https://github.com/yyoshiaki/mishima_gassyuku/blob/master/README.md"&gt;三島合宿日誌&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後に、合宿を快諾いただいた坊農さんはじめ、仲里さん、内藤さん、小野さん、大田さんには心よりお礼申し上げます。生涯忘れることない、大切な経験になりました。&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>Mockinbirdを用いたPAR-CLIP解析</title><link href="http://oumpy.github.io%5Carticles/2019/04/mockinbird_parclip.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>平岡</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/mockinbird_parclip.html</id><summary type="html"></summary><content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mockinbirdを用いたPAR-CLIP解析&lt;/em&gt;&lt;/strong&gt;
５年　平岡　悠&lt;/p&gt;
&lt;p&gt;今回はPAR-CLIP解析のAll-in-oneパイプラインソフトウェアである、&lt;a href="//wwwuser.gwdg.de/~compbiol/mockinbird/doc/intro.html)”"&gt;Mockinbird&lt;/a&gt;を紹介します。日本語での情報がほぼなく、説明が長くなってしまいそうなので、２回に分けて書きます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PAR-CLIP&lt;/strong&gt;って何？
PAR-CLIPは photoactivatable ribonucleoside-enhanced crosslinking and immunoprecipitationの略でRNAやmicroRNA結合タンパクやの結合サイトを特定するために使います。&lt;/p&gt;
&lt;p&gt;実験法としては、まず4SU（4-チオウリジン）を細胞培地中に添加し、4SUによるラベル標識を行います。次にUVの照射を行い、RNA結合タンパクとRNAの間で架橋反応を起こします。その後、RBPと結合したリードの抽出を行い、サンプルとして用います。&lt;/p&gt;
&lt;p&gt;サンプルRNAを逆転写するときに、4SUがシトシン( C )に置換されます(misread)。そのため、リードがピークを形成し、かつT -&amp;gt; C置換が入っていた場合、RBPと結合していた可能性が高いということになります。これによりあるタンパクが、RNAのどの領域に結合するのか？結合領域間でどのような相互作用があるのかを知ることができます。特に一塩基という高い解像度での解析ができることが特徴です。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://lh6.googleusercontent.com/554iMVEXLP3Hq6U6C8FeveBV1FeMT19zXQuj-728Db4UxDU7JDSnzpF-RvezYq0DW3z2kQjDiOlZkeQLJRZhwNm4SqkaeJnBYyOV7yUbmuV0peAaJ4TcKazkJaqvRMF65Rgldk2l"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mockinbird&lt;/strong&gt;とは？&lt;/p&gt;
&lt;p&gt;&lt;a href="//wwwuser.gwdg.de/~compbiol/mockinbird/doc/intro.html”"&gt;公式ドキュメント&lt;/a&gt;、&lt;a href="//github.com/soedinglab/mockinbird)”"&gt;GitHub&lt;/a&gt;に詳細は記載されていますが、日本語での情報が少ない、というか全くない。のでまとめていきたいと思います。&lt;/p&gt;
&lt;p&gt;PAR-CLIPの解析は生のFASTQデータから、Quality Check -&amp;gt; Trimming -&amp;gt; Mapping -&amp;gt; Downstream Analysisという流れで行いますが、それらすべての解析をMockinbirdでは一気に行ってくれます。また、MockinbirdModule（詳細は後述）を使うことでmock PAR-CLIP experimentを考慮に入れた解析を行うことができるのも大きな特徴です。&lt;/p&gt;
&lt;p&gt;このソフトでは、２つにパイプラインが分かれており、preprocessing phaseとpostprocessing phaseと呼ばれています。タンパク結合サイトの情報が書かれたテーブルを出力するまでが、preprocessing phaseでそれ以降のDownstream解析をpostprocessing phaseと呼んでいます。それぞれにYAMLファイルが用意されており、ユーザーはYAMLファイルで解析したいサンプルデータ、使いたいリファレンスデータ、使いたいモジュール（Mappingの時にSTARやBowtieを選べたりする。）閾値などのパラメータを指定します。最後にコマンドを一行実行するだけで、解析がすべて自動で流れていきます。あるモジュールで出力されたファイルのパスが次のモジュールに自動で設定されていくシステムになっているので、慣れると非常に便利です。&lt;/p&gt;
&lt;p&gt;ただ、ドキュメントでも、既存の解析手法に完全に取って代わるものではなく、PAR-CLIP実験のコンディションのトラブルシューティングを再現可能性が高い状態で行なったり、研究の最初の仮説づくりを短時間で行うために使ってもらうことが目的と書かれていました。&lt;img alt="" src="https://lh6.googleusercontent.com/rd3A2Nm8czl8cdPu_47SuddQXr-i-ac0ThA-ZupDlDIa67geEayilGTo2Bp3VnJXt6UXNe9b7Rq6EckkNigvg68OCJ9Wk2XrKfQ-FwJu5I_HjkwXXrpMUR7x-0pBojlg6E1EtlH2"&gt;&lt;/p&gt;
&lt;p&gt;環境構築&lt;/p&gt;
&lt;p&gt;前置きが長くなりましたが、実際に環境構築から進めていきます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda create -n mockinbird -c bioconda -c conda-forge python=3.6 mockinbird&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Anacondaでmockinbirdという名前の仮想環境を作ります。mockinbirdが仮想環境にインストールされることになり、これにより、下記のライブラリとツールが環境内で使えるようになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;source activate mockinbird&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;でmockinbirdの仮想環境を立ち上げ、&lt;/p&gt;
&lt;p&gt;&lt;code&gt;source deactivate mockinbird&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;で仮想環境を閉じます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda remove --all -n mockinbird&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;で環境を削除します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone [https://github.com/soedinglab/mockinbird.git](https://github.com/soedinglab/mockinbird.git)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;でgithubからクローンします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd mockinbird/mockinbird/data&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;とディレクトリを進めていくと、&lt;code&gt;preprocess.yaml&lt;/code&gt;, &lt;code&gt;postprocess.yaml&lt;/code&gt;というファイルがあります。基本はこの二つのYAMLファイルを調整していくことになります。terminalでコマンドを出すときも &lt;code&gt;mockinbird/mockinbird/data&lt;/code&gt;ディレクトリで実行するのが個人的にはおすすめです（ファイルの構成が綺麗になる。パスの調整も楽）。&lt;/p&gt;
&lt;p&gt;&lt;a href="//wwwuser.gwdg.de/~compbiol/mockinbird/mockinbird_tutorial_nomock.tar.gz”"&gt;Tutorialデータ&lt;/a&gt;がドキュメントの方に書かれていましたが、私が見たときはリンクがNotFoundになっていました。ので、私は&lt;a href="//wwwuser.gwdg.de/~compbiol/mockinbird/doc/intro.html”"&gt;公式ドキュメント&lt;/a&gt;、&lt;a href="//github.com/soedinglab/mockinbird)”"&gt;GitHub&lt;/a&gt;を参考にYAMLファイルの調整などを行いました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;preprocess&lt;/code&gt;, &lt;code&gt;postprocess&lt;/code&gt;の実行のコードは以下のようになっています。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mockinbird&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;preprocess&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parclip_fastq&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;output_dir&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;config_file&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mockinbird&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;preprocess&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nrd1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fastq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nrd1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nrd1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;preprocess&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yaml&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mockinbird&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;postprocess&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;genomefasta&lt;/span&gt;&lt;span class="err"&gt;}}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;output_dir&lt;/span&gt;&lt;span class="err"&gt;}}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;output_dir&lt;/span&gt;&lt;span class="err"&gt;}}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;script_dir&lt;/span&gt;&lt;span class="err"&gt;}}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mockinbird&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;postprocess&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nrd1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nrd1_pp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;postprocess&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yaml&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ですが、コードの実行はYAMLの設定ができてからになります。ということでYAMLの中身について説明していきます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;preprocess.yaml&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;preprocess.yamlの４つの区画から構成されています。&lt;/p&gt;
&lt;p&gt;① 変数設定。
② general. 必須情報の設定。
③ reads. リードについての情報。
④ pipeline. 使うモジュールと各引数の設定。&lt;/p&gt;
&lt;p&gt;① 変数設定
下記のスクショはドキュメントから引用していますが、モジュールで使う、ディレクトリの変数化と、mock_processing をFalseに設定しています。（ここ重要！）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://lh5.googleusercontent.com/axBM--SAveLQ5WpApwgiK3VmRPCEywGRY1ap3jXUNrp1ejgabu7k_3yMrnFT5dEA6xO5j2wBdjLh4UFNdJ5zbtwjq4nndYXoBVOBQyRRT7VskRhZUiruBhH8CK-AeFxu4Fv3bX3i"&gt;&lt;/p&gt;
&lt;p&gt;② general. 必須情報の設定
アダプター配列の指定、リファレンスデータの指定、UMI(Unique molecular identifiers)の有無、スレッド数の指定。&lt;/p&gt;
&lt;p&gt;③ reads. リードについての情報
リードの最短長、T -&amp;gt; C mutationの指定&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://lh3.googleusercontent.com/STLDXYeF8NC-rqiRjaW4rArxJNHYNNcpDkrpj-OkX6W0Ltr7eo0FkqMd6VXWM6asWlMQMDhkg0l0pViKfzpFpXKFhN_KN1tyJkLDYeNt2fRqyNMVNQvp6rhwyF0LOZN7W_mJaSxy"&gt;&lt;/p&gt;
&lt;p&gt;④ pipeline. 使うモジュールと各引数の設定
クオリティチェック -&amp;gt; トリミング -&amp;gt; マッピング
&lt;img alt="" src="https://lh5.googleusercontent.com/KASBpB_VhdJ80ZHeIyOucHGZShtPan6lgSWzCcrKl6qGoQahRudn5Gq9n5gu--xl2o3bWuOh7u8y4huuc6adxcis-BLRJhW9iczYI2tREs8MRWkpzoWsx_WtQXIvtlxskNRaZK2h"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://lh4.googleusercontent.com/7vAyDIsxenmYiwISI6p1k6mjbbw1HESriPeyla17MOvM8dPjJxYxD5cLF8OWPXtO7AHCt4AvDjXPZmndQ7p6sNUkME4BIdM-CsmRfKyf0L7ni1nQY3LXoHXDdv6cNY9Xg_EGQyWb"&gt;
MockinbirdModuleを使うことでmock PAR-CLIP experimentを考慮に入れた解析ができますと、すでに書きましたが、Mock Experimentの結果をバックグラウンドとして処理して、PAR-CLIP Experimentの結果を出すことができます。&lt;/p&gt;
&lt;p&gt;具体的な方法としては、まず
&lt;code&gt;mock_processing = True&lt;/code&gt;とし、
&lt;code&gt;mockinbird preprocess nrd1_mock.fastq nrd1_mock nrd1_mock preprocess.yaml&lt;/code&gt;を実行します。これで&lt;code&gt;{% if not mock_processing %}&lt;/code&gt;までで解析がストップします。&lt;/p&gt;
&lt;p&gt;PileupModule, BamStatisticsModuleによって、Mock Experimentの.mpileupファイルと_stat.jsonファイルがそれぞれ生成されます。（この二つのファイルを次に使うことになります。）&lt;/p&gt;
&lt;p&gt;次に&lt;code&gt;mock_processing = False&lt;/code&gt;に戻し、
&lt;code&gt;$ mockinbird preprocess nrd1.fastq nrd1 nrd1 preprocess.yaml&lt;/code&gt;を実行します。すると下記のコードも一緒に実行されます。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://lh4.googleusercontent.com/hKqjVPmLLGnF0bhn637a_19_gZZ6KJBDceofpi8TVC_NfnhM1rZiZVb8MiBz-TmVv0FtStVpck_3IdL_CmYS52kpQqm0uzGbDWK5xyw1InCRVyLE8ne99FQIuAFm4VkuvpEkEtC-"&gt;&lt;/p&gt;
&lt;p&gt;これによって、Mock Experimentの&lt;code&gt;.mpileupファイル&lt;/code&gt;と&lt;code&gt;_stat.jsonファイル&lt;/code&gt;を受け取りつつ、最終的なCLIP-seqのテーブルを作ることができ、preprocessは終了となります。下記のようなテーブルが出力され、これをもとにpostprocessに進んでいくことになります。
&lt;img alt="" src="https://lh3.googleusercontent.com/yb1p70EaelwH-dEGIRhTLnjUoDLgKHSNzqD6dpG9IT9y5fM0LApdvtHKNgmKA73G6HgfflmWkEnoFvm_HEjpIxf4T6Uk15uG4ovIJsG2ILHRGGpXELLQ381BWMkFU6k8AxtSgocl"&gt;&lt;img alt="" src="https://lh4.googleusercontent.com/3bwU07uRrmxRkOJxVPU8N-S11uYBRU3NrRFFrkoDyz_RlXjHgClXH2aDfJ2IU10yV-kURjSGBOR5nsdyaUBrh6C2lkMW3u8C128ktZXIWXniOzjGyIoD68ArK3awsfazmT4bRr2Z"&gt;&lt;/p&gt;
&lt;p&gt;長くなってしまったので、モジュールとpostprocessの説明は次回に回したいと思います。長い間お付き合いいただきありがとうございました。&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>必要n数の決定～研究計画～</title><link href="http://oumpy.github.io%5Carticles/2019/04/n_number.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>依藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/n_number.html</id><summary type="html"></summary><content type="html">&lt;p&gt;&lt;span style="font-weight:400;"&gt;実験計画(シングルセル解析)を考えるときに、臨床研究だとどうだったかなと思うことがあります。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;〈シングルセル解析〉group Aの1000細胞　と　group Bの1000細胞をサブタイピング&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;〈臨床研究〉介入Aの結果、心血管イベントありの1000人　と　心血管イベントなしの1000人&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;細胞はヒトの数ほど多彩であり、それを分類するのがシングルセル解析であり、(勿論、データ量の桁が異なりますし、結果を見ているのか背景を見ているのかという違いはありますが)臨床研究のデータ解析の考え方を活かせるように思います。今回はサンプル調整に必要な細胞数(n)の決定に関して、臨床研究での症例数(n)の決定と比較してみました。&lt;/span&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style="font-weight:400;"&gt;シングルセル解析での細胞数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span style="font-weight:400;"&gt;①実現可能性：金銭面、使用機器のスループットを考慮した細胞数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;②検出力：統計学的検討により細胞種間の差が充分に検出される症例数であるか&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;③倫理面：ヒトサンプル、あるいはモデル動物サンプルの取り扱い&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;とくに②に関して：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;分類するclusterに関して過去の文献から予測する。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;想定されるcluster数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;1clusterあたりの最低細胞数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;上記の見積もりができれば、&lt;a href="https://satijalab.org/howmanycells" target="_blank" rel="noopener noreferrer"&gt;ウェブサイト&lt;/a&gt;での計算が可能。&lt;/span&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style="font-weight:400;"&gt;臨床研究での症例数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span style="font-weight:400;"&gt;①実現可能性：それだけの症例数を集めることができるか&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;②検出力：統計学的検討によりoutcomeの差が充分に検出される症例数であるか&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;③倫理面：不必要に多くの被験者を研究に参加させるべきではない&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;とくに②に関して：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;症例数の予測に必要なものを過去の文献やパイロット研究を行うことで予測する。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;　outcomeの差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;　データのばらつき(標準偏差)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;上記の見積もりができれば、ソフトウェアでの計算が可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://biostat.mc.vanderbilt.edu/wiki/Main/PowerSampleSize" target="_blank" rel="noopener noreferrer"&gt;Power and Sample Size Calculation (PS)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;　シングルセル解析では、やはり値段や機器の問題が大きくなってくるでしょうか。特に細胞種がかなり希少な場合に、細胞数(n)をどんどん増やすしかないとなると、その点が一番気になります。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;　一方で臨床研究では、単施設で可能なのか、多施設共同でないと症例数(n)が集まらないのかという問題は切実です。そしてヒトを対象にする以上、症例数決定の明確な理由が必要です。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.consort-statement.org/media/default/downloads/consort%202010%20checklist.pdf"&gt;CONSORT2010 checklist&lt;/a&gt;&lt;span style="font-weight:400;"&gt;にも記載があります。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;いずれにせよ、事前の文献調査やプレ実験・パイロット研究によって着地点を明確にしておかないと、途中で頓挫してしまい、出るはずの結果がでない事態になりそうです。今後はシングルセル解析で前提となる統計手法に関しても勉強していこうと思っています。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;【参考文献】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;今日から使える医療統計　(新谷歩, 2015年, 医学書院)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;Tutorial: guidelines for the experimental design of single-cell RNA sequencing studies　(Atefeh Lafzi et el., Nature Protocols volume 13, pages2742–2757 (2018))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content><category term="tech_archive"></category><category term="statistics"></category></entry><entry><title>阪医Python会特製 RNA-seq pipeline ver. 1.0 リリース</title><link href="http://oumpy.github.io%5Carticles/2019/04/original_rnaseq_pipeline.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>菅波 西田 大森 安水 小川 山田 川島 川崎 平岡 廣瀬 柳澤 淡田 中村 依藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/original_rnaseq_pipeline.html</id><summary type="html"></summary><content type="html">&lt;p&gt;阪医Python会のbioinformaticsチームの一つの成果として、RNA-seqのパイプラインのv1.0がリリースとなったので記事とさせていただきます。SRR idから遺伝子✕サンプルのテーブルにするまでには意外に大変ですが、それをすべて自動化しました。ダウンロード、詳細等は以下にあります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/yyoshiaki/auto_counttable_maker"&gt;https://github.com/yyoshiaki/auto_counttable_maker&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;特徴&lt;/h2&gt;
&lt;p&gt;今回、自分たちの使いやすさを考えてツールの設計を行いました。他サンプルのファイル名の管理など、煩わしいところをすべて自動化することで、ミスも減らせると思います。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;準備するのは簡単なCSVファイル（テーブルだけ）で、極力パラメーターを減らした。&lt;/li&gt;
&lt;li&gt;すべてdocker上で動くため、ツールを各々インストールする必要がないし、バージョンに苦しむこともない。&lt;/li&gt;
&lt;li&gt;udockerにも対応しているため、ユーザー権限しかないサーバー上でも実行可能。&lt;/li&gt;
&lt;li&gt;outputは&lt;a href="http://bioinformatics.sdstate.edu/idep/"&gt;idep&lt;/a&gt;に対応。&lt;/li&gt;
&lt;li&gt;もちろんマルチスレッド対応。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;必要なテーブルは&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;SRR or fastq&lt;/th&gt;
&lt;th&gt;Layout&lt;/th&gt;
&lt;th&gt;condition1&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Treg_LN_1&lt;/td&gt;
&lt;td&gt;SRR5385247&lt;/td&gt;
&lt;td&gt;SE&lt;/td&gt;
&lt;td&gt;Treg&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Treg_LN_2&lt;/td&gt;
&lt;td&gt;SRR5385248&lt;/td&gt;
&lt;td&gt;SE&lt;/td&gt;
&lt;td&gt;Treg&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;のような形式で、前3列が必須です。簡単ですね！データの集め方は、論文についているaccession number等をたどるのでもいいし、新しくなって爆速になった&lt;a href="http://sra.dbcls.jp/"&gt;DDBJ Search&lt;/a&gt;もおすすめ。&lt;/p&gt;
&lt;p&gt;コマンドはオプションが指定でき、リード数を100000に絞ったテストモードやマルチプロセスにも対応。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;Usage&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MakeCountTable_Illumina_trimgalore_SRR&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;experiment_table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spiece&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;--test, --help, --without-docker, --udocker&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;--threads [VALUE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;human&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mouse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nl"&gt;Options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;--test test mode(MAX_SPOT_ID=100000).(dafault : False)&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--udocker&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--without-docker&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--threads&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--help Show usage.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;なお、自前のfastq filesからの実行はv1.1で載せようと思っています。また、出力はscaled TPMを採用。(Soneson, C., Love, M. I. &amp;amp; Robinson, M. D. Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research 4, 1521 (2015).)。&lt;/p&gt;
&lt;h2&gt;pipelineの構成&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;fasterq-dump : シーケンスデータの取得&lt;/li&gt;
&lt;li&gt;fastqc : QC&lt;/li&gt;
&lt;li&gt;trim-galore : トリミング&lt;/li&gt;
&lt;li&gt;salmon : RNA定量&lt;/li&gt;
&lt;li&gt;multiqc : QCログの回収、可視化&lt;/li&gt;
&lt;li&gt;tximport : 遺伝子テーブルの生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;となっています。各ツールの説明は省きますが、今時のツールの選定になっていると思います。&lt;/p&gt;
&lt;h2&gt;idep&lt;/h2&gt;
&lt;p&gt;本ツールは&lt;a href="http://bioinformatics.sdstate.edu/idep/"&gt;idep&lt;/a&gt;を意識した設計になっています。idepはRNA-seqの解析をinteractiveに行えるプラットフォームで、Differential expressed genes(DEGs)の検出だけではなく、遺伝子、サンプルのクラスタリング、パスウェイ解析、可視化などが行えます。idepについては以下がとても参考になります。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kazumaxneo.hatenablog.com/entry/2018/12/29/153838" target="_blank" rel="noopener noreferrer"&gt;macでインフォマティクス : インタラクティブなRNA seq解析webアプリケーション iDEP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2019/03/screenshot-from-2019-03-19-23-14-31.png" class="alignnone size-full wp-image-493" alt="Screenshot from 2019-03-19 23-14-31.png" width="820" height="805"&gt;&lt;/p&gt;
&lt;h2&gt;githubを用いたチーム開発&lt;/h2&gt;
&lt;p&gt;今回、githubを用いてチーム開発を行いました。githubはエンジニアの間では当たり前のツールで、チームでのソフト開発によく用いられます。bioinformatics界隈でチーム開発を経験できることは意外に少なく、非常にいい経験になりました。&lt;img src="https://pythonoum.files.wordpress.com/2019/03/e382b9e382afe383aae383bce383b3e382b7e383a7e38383e38388-2019-03-16-17.53.58.png" class="alignnone size-full wp-image-490" alt="スクリーンショット 2019-03-16 17.53.58.png" width="1436" height="874"&gt;&lt;/p&gt;
&lt;p&gt;雑多にはなりましたが、阪医Python会bioinformaticsチームの成果をアナウンスさせていただきました。完成までには3ヶ月ほどを要し、各人のアイデアや努力が詰まっております。今後もどんどん開発を進めていこうと思います。また、皆様のissue, Pull Requestもお待ちしております。
Enjoy bioinformatics life!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2019/03/ios-e381aee794bbe5838f.jpg" class="alignnone size-full wp-image-492" alt="iOS の画像.jpg" width="3088" height="2316"&gt;&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>pandasのpivot_tableを用いた高速データ処理</title><link href="http://oumpy.github.io%5Carticles/2019/04/pandas_pivot_table.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>金子</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/pandas_pivot_table.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;pandasのpivot_tableを用いた高速データ処理&lt;/h1&gt;

&lt;h2&gt;概要&lt;/h2&gt;

&lt;p&gt;pandasのpivot_tableは強力な機能で、カテゴリごとの集計や計算を高速に行うことができます。&lt;/p&gt;
&lt;p&gt;pivot_tableを使った計算で個人的によく使う処理をまとめたものをkaggle の&lt;strong&gt;&lt;a href="https://www.kaggle.com/nadare/feature-engenieering-with-pivot-table"&gt;kernel&lt;/a&gt;&lt;/strong&gt;で公開しました。&lt;/p&gt;
&lt;p&gt;このkernelでは簡単なダミーデータでpivot_tableに対する計算の仕方をまとめた後、実例として&lt;a href="https://www.kaggle.com/c/PLAsTiCC-2018"&gt;PLAsTiCC コンペ&lt;/a&gt;の&lt;a href="https://www.kaggle.com/michaelapers/the-plasticc-astronomy-starter-kit"&gt;Starter Kit&lt;/a&gt;にあった特徴量の計算をpandasのpivot_tableを用いて高速化しました。
&lt;h2&gt;どんなことができるようになるの？&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;カテゴリごとに組み込みの集計関数より高度な関数を適用できる&lt;/li&gt;
    &lt;li&gt;カテゴリごとの移動平均をかけるようになる&lt;/li&gt;
    &lt;li&gt;未来のデータを含まないmean_encodingがかける&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;どれくらい早くなるの？&lt;/h2&gt;
上記のkernelはEDA中に実際に僕が書いたコードに少し修正を加えたものですが、&lt;/p&gt;
&lt;p&gt;愚直なコード(1時間以上)→groupbyでの処理(2分半)→pivot_table(4秒)&lt;/p&gt;
&lt;p&gt;という感じで早くなりました。
 &lt;/p&gt;</content><category term="tech_archive"></category><category term="kaggle"></category></entry><entry><title>Parameter Tuning</title><link href="http://oumpy.github.io%5Carticles/2019/04/parametaer_tuning.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>佐藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/parametaer_tuning.html</id><summary type="html"></summary><content type="html">&lt;p&gt;機械学習を行う際に大事なのがパラメーターの調整です。
今まで適当にデフォルトの値でそのままやったりGridearchで探したりしていましたが、結構時間かかるので他の有効な方法を探して、手元で実際に動かして見ました。&lt;a href="http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html"&gt;こちら&lt;/a&gt;の資料がわかりやすかったです。(図もこちらのものを引用しました)&lt;/p&gt;
&lt;h2&gt;Bayesian Optimization&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Bayesian Optimization&lt;/strong&gt;はパラメーターを&lt;strong&gt;x&lt;/strong&gt;、評価値(精度とか)をyとして&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/suushiki0.png?raw=true" alt="suushiki0" /&gt;&lt;/p&gt;
&lt;p&gt;という関数を指定します(ブラックボックス関数)。中身は良くわかりませんが、この関数を最適化するパラメーターを見つけたいと思います。そこでBaysian Optimizationはこの関数が&lt;a href="http://www.yasuhisay.info/entry/20091011/1255189429"&gt;ガウス過程&lt;/a&gt;に従うと仮定します。&lt;/p&gt;
&lt;p&gt;下の図ではパラメーターの組み合わせをそれぞれ2,3個とって来て、その評価値を計算して結果をプロットしたグラフです。青い曲線はこの二点から導かれる関数の事後分布で、青い部分はこの分布の95%信頼区間です。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://neupy.com/_images/gaussian-process-example.png" alt="Baysian Optimization" /&gt;&lt;/p&gt;
&lt;p&gt;このグラフを見ると、観測点から離れた部分は信頼区間の幅が広い(=σが大きい)ことがわかります。&lt;/p&gt;
&lt;h3&gt;獲得関数(Acquisition Function)&lt;/h3&gt;

&lt;p&gt;獲得関数は、次にどこの点を観測するか決める関数です。これにはいろいろな関数がありますが、よく使われるのが&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/suushiki2.png?raw=True" alt="suushiki2" /&gt;&lt;/p&gt;
&lt;p&gt;という&lt;strong&gt;Expected Improvement&lt;/strong&gt;[Mockus,1978]であったり、
&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/suushiki1.png?raw=True" alt="suushiki1" /&gt;&lt;/p&gt;
&lt;p&gt;のような&lt;strong&gt;Mutual Information&lt;/strong&gt;[Contal+2014]がよく使われます。後者は特に直感的にわかりやすいと思うのですが、私たちも次にどの点を選ぶかというときに&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;観測した点から推測して精度が良さそうな点を選びたい(μが大きい)&lt;/li&gt;
&lt;li&gt;まだ観測していない場所から選びたい(σが大きい)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということを考えて選びそうなものです。よくできてますね。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://neupy.com/_images/expected-improvement-example.png" alt="acquisition function" /&gt;&lt;/p&gt;
&lt;p&gt;実装には&lt;a href="https://github.com/fmfn/BayesianOptimization"&gt;Bayesian Optimization&lt;/a&gt;を使いました。&lt;/p&gt;
&lt;p&gt;使用するデータはkaggleの&lt;a href="https://www.kaggle.com/c/otto-group-product-classification-challenge#evaluation"&gt;Otto Group Product Classification Challenge&lt;/a&gt;のデータで評価指標はmulti-class loglossです。定番のXGBoostのパラメータを最適化します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install bayesian-optimization&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[code lang="text"]
import pandas as pd
import xgboost as xgb
from sklearn.preprocessing import LabelEncoder
from bayes_opt import BayesianOptimization
[/code]&lt;/p&gt;
&lt;p&gt;調整したいパラメーターを引数にとる評価関数の指定、クロスバリデーション。bayesian-optimizationには評価関数の最大化のライブラリしかないので、小さい値ほどいいloglossは返り値に-1をかけます。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
def xgb_evaluate(min_child_weight,
colsample_bytree,
max_depth,
subsample,
gamma,
alpha):&lt;/p&gt;
&lt;p&gt;params[&amp;#039;min_child_weight&amp;#039;] = int(min_child_weight)
params[&amp;#039;cosample_bytree&amp;#039;] = max(min(colsample_bytree, 1), 0)
params[&amp;#039;max_depth&amp;#039;] = int(max_depth)
params[&amp;#039;subsample&amp;#039;] = max(min(subsample, 1), 0)
params[&amp;#039;gamma&amp;#039;] = max(gamma, 0)
params[&amp;#039;alpha&amp;#039;] = max(alpha, 0)&lt;/p&gt;
&lt;p&gt;cv_result = xgb.cv(params, xgtrain, num_boost_round=num_rounds, nfold=5,
seed=random_state,
callbacks=[xgb.callback.early_stop(50)])&lt;/p&gt;
&lt;p&gt;return -cv_result[&amp;#039;test-mlogloss-mean&amp;#039;].values[-1]
[/code]&lt;/p&gt;
&lt;p&gt;いよいよ最適化！&lt;/p&gt;
&lt;p&gt;[code lang="text"]
if &lt;strong&gt;name&lt;/strong&gt; == &amp;#039;&lt;strong&gt;main&lt;/strong&gt;&amp;#039;:
xgtrain = prepare_data()&lt;/p&gt;
&lt;p&gt;num_rounds = 3000
random_state = 2016
num_iter = 25
init_points = 5
params = {
&amp;#039;eta&amp;#039;: 0.1,
&amp;#039;silent&amp;#039;: 1,
&amp;#039;eval_metric&amp;#039;: &amp;#039;mlogloss&amp;#039;,
&amp;#039;verbose_eval&amp;#039;: True,
&amp;#039;seed&amp;#039;: random_state,
&amp;#039;num_class&amp;#039;:9
}&lt;/p&gt;
&lt;p&gt;xgbBO = BayesianOptimization(xgb_evaluate, {&amp;#039;min_child_weight&amp;#039;: (1, 20),
&amp;#039;colsample_bytree&amp;#039;: (0.1, 1),
&amp;#039;max_depth&amp;#039;: (5, 15),
&amp;#039;subsample&amp;#039;: (0.5, 1),
&amp;#039;gamma&amp;#039;: (0, 10),
&amp;#039;alpha&amp;#039;: (0, 10),
})&lt;/p&gt;
&lt;p&gt;xgbBO.maximize(init_points=init_points, n_iter=num_iter)
[/code]&lt;/p&gt;
&lt;p&gt;結果です&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/result.png?raw=true" alt="result" /&gt;
&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/result2.png?raw=true" alt="result2" /&gt;&lt;/p&gt;
&lt;p&gt;だいたい15回くらいの試行でloglossが0.46136まで下がりました。やってから気づいたんですが、max_depthとかって整数の値しかとらないですね、、、&lt;/p&gt;
&lt;p&gt;ただし、ベイズ最適化には弱点もいくつかあって、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;カテゴリー変数の場合にうまくいかない。&lt;/li&gt;
&lt;li&gt;偶然性に左右されたり、再現性が取れないことがある&lt;/li&gt;
&lt;li&gt;バラメーターが増えてきたら時間かかる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;みたいなことになるらしいです。&lt;/p&gt;
&lt;h2&gt;Tree-structured Parzen Estimator(TPE)&lt;/h2&gt;

&lt;p&gt;このような弱点を修正したのがTPEという最適化手法です。ベイズとコンセプトは似ていますが、手法は全く異なります。一般的な方法として、まずRandom Searchを用いていくつか点をとってきます。プロットすると下の図のようになりました。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://neupy.com/_images/tpe-observation-groups.png" alt="TPE" /&gt;&lt;/p&gt;
&lt;p&gt;次に精度が良かったもの(図では上位20%)とそうでなかったものに分けます。この2群の尤度関数を求めます。あまり尤度と言っても馴染みのない人が多いと思いますが、サンプリングされたデータは様々な確率分布のうち、どの分布から得られたものとするのが一番尤もらしいかを決めようとするものです。これにより2群の確率分布が出来上がります。&lt;/p&gt;
&lt;p&gt;TPEでもExpected Improvement関数の下のように定義します。精度良かったものをl,そうではなかったものをgとして、&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/suushiki3.png?raw=True" alt="suushiki3" /&gt;
これをそれぞれの観測点に対して適用し、最もEIの値が大きかった場所が次の観測点になります。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://neupy.com/_images/tpe-sampled-candidates.png" alt="prob dist" /&gt;
&lt;img src="http://neupy.com/_images/tpe-expected-improvement.png" alt="acq" /&gt;&lt;/p&gt;
&lt;p&gt;こっちも実装してみます。Pythonではhyperoptというライブラリがあってpipで入ります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install hyperopt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[code lang="text"]
import hyperopt
from hyperopt import hp, tpe, Trials, fmin
[/code]&lt;/p&gt;
&lt;p&gt;最適化するパラメータはbayesian optimizationと同じやつにしてみました。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
hyperopt_parameters = {&amp;#039;min_child_weight&amp;#039;: hp.uniform(&amp;#039;min_child_weight&amp;#039;,1,20),
&amp;#039;colsample_bytree&amp;#039;: hp.uniform(&amp;#039;colsample_bytree&amp;#039;,0.1, 1),
&amp;#039;max_depth&amp;#039;: hp.choice(&amp;#039;max_depth&amp;#039;,np.arange(5, 15)),
&amp;#039;subsample&amp;#039;: hp.uniform(&amp;#039;subsample&amp;#039;,0.5, 1),
&amp;#039;gamma&amp;#039;: hp.uniform(&amp;#039;gamma&amp;#039;,0, 10),
&amp;#039;alpha&amp;#039;: hp.uniform(&amp;#039;alpha&amp;#039;,0, 10),
}
[/code]&lt;/p&gt;
&lt;p&gt;最適化する関数の指定&lt;/p&gt;
&lt;p&gt;[code lang="text"]
def objective(args):
classifier = xgb.XGBClassifier(**args)
stratifiedkfold = StratifiedKFold(n_splits=5)
result = cross_val_score(classifier, train.drop([&amp;#039;id&amp;#039;,&amp;#039;target&amp;#039;],axis = 1), train.target, cv=stratifiedkfold,scoring=&amp;#039;neg_log_loss&amp;#039;)
return -result.mean()
[/code]&lt;/p&gt;
&lt;p&gt;実行！&lt;/p&gt;
&lt;p&gt;[code lang="text"]
max_evals = 50
trials = Trials() # 実行結果を格納するインスタンス&lt;/p&gt;
&lt;p&gt;best = fmin(
objective,
hyperopt_parameters,
algo = tpe.suggest,
max_evals =max_evals,
trials = trials,
verbose = 1)
[/code]&lt;/p&gt;
&lt;h3&gt;結果&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/loss.jpg?raw=true" alt="loss" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/jun-sato/parameter_tuning/blob/master/best_param.png?raw=true" alt="best_param" /&gt;&lt;/p&gt;
&lt;p&gt;logloss最小値は0.4749でした。あれ、bayesian optimizaationより悪い、、、bayesianではmax_depthを整数に限定しなかったからかも、、
でも自分で手動でやった時は0.6とかだったんで、パラメーターチューニングの時にはこれからこれ使っていこうと思います。あとこのxgboost動かすのに8コアCPU使ってそれぞれ半日くらい回しました。GPU使ってたらもうちょい早かったと思うのですが、きちんとbuildとmakeしてもうまくいきませんでした。また挑戦します。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>particle filter</title><link href="http://oumpy.github.io%5Carticles/2019/04/particle_filter.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>柳澤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/particle_filter.html</id><summary type="html"></summary><content type="html">&lt;p&gt;こんばんは。
今回はパーティクルフィルターの紹介をしたいと思います。
といってもやり始めたばっかなので、間違っていたらご指摘お願いします。
（画像は&lt;a href="https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3%E6%9C%80%E5%85%88%E7%AB%AF%E3%82%AC%E3%82%A4%E3%83%891-CVIM%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E5%80%89%E7%88%AA-%E4%BA%AE/dp/4915851346"&gt;コンピュータビジョン最先端ガイド&lt;/a&gt;って有名な本の図から、イメージはこんな感じ）&lt;/p&gt;
&lt;p&gt;・手順
基本は以下の４つのサイクルを繰り返すだけです。
1.リサンプリング
2.予測
3.観測
4.尤度計算 重みの更新
と言っても分かりにくかったんで、イメージで話すと
まず粒子（パーティクル）を全体に振りかけます→振りかけたなかで、あってそうな粒子だけ生き残ってもらい、それ以外は消えてもらいます。→あってそうなものは、尤度（確からしさ）を計算して其れに（おおよそ）従い新たに粒子を撒きなおします（ちょっとランダムウォークさせます）→ってかんじで対象の動きを推定してくれます&lt;/p&gt;
&lt;p&gt;なんでいきなりパーティクルフィルターの話をしたかというと、こいつは画像解析の分野ではノイズや予想外の動きによって影響を受けにくく、しっかりと標的のものを追ってくれるかなり有用な方法らしいからです。&lt;/p&gt;
&lt;p&gt;まあとりあえずやってみよう。
ということでpython3+opencvをつかいました。
Opencvをpythonで使えるようになったのは結構最近なので、なかなか良い本がないのですが、公式のチュートリアルが結構役に立ちます。
http://labs.eecs.tottori-u.ac.jp/sd/Member/oyamada/OpenCV/html/py_tutorials/py_tutorials.html
でも、やってたら結構間違いもあるので、注意してください。
あと、有料ですがUdemyでもopencv+pythonの講座があるので、試してみても良いかもしれません。
先ほど紹介したコンピュータビジョン最先端ガイドも理論がわからない時便利です。&lt;/p&gt;
&lt;p&gt;うまくいった例はネットに大量にあるので、興味のある方は検索してみてください。&lt;/p&gt;
&lt;p&gt;ちなみにパーティクルフィルターでの一番の肝は、↑の4．尤度関数の設定の仕方です。
今回は色の尤度の他に、距離でも尤度を設定して（つまりある時点で散らばっている粒子の重心からの距離を考えるということ）それらをかけたものを最終の尤度のしました。
ブラウン運動ではなく、今回のように細胞の動きを追う場合では、次のフレームで動きそうなところの尤度を大きくすればもっと正確に動きを追いかけられるみたいです。
難しい。。。
べんきょうしたいですねー&lt;/p&gt;
&lt;p&gt;以上です
以下、&lt;a href="https://www.udemy.com/pythonopencv/"&gt;「Udemy 【Pythonで学ぶ】OpenCVでの画像処理入門」&lt;/a&gt;のコードを参考にさせていただきました。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
import cv2
import numpy as np
import os
import sys
import matplotlib.pyplot as plt
from tqdm import tqdm
import time&lt;/p&gt;
&lt;p&gt;for i in tqdm(range(100)):
time.sleep(0.1) #プログレスバーの表示&lt;/p&gt;
&lt;p&gt;args = sys.argv #コマンドライン引数&lt;/p&gt;
&lt;p&gt;cap = cv2.VideoCapture("/movie/lps.avi")
if cap.isOpened() == False:
sys.exit&lt;/p&gt;
&lt;p&gt;ret,frame = cap.read()
h, w =frame.shape[:2]#大きさを取得&lt;/p&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*"mp4v")
output_dst = cv2.VideoWriter("/output/test[{0},{1}].m4v".format(args[1],args[2]),fourcc,5.0,(w,h))#動画出力の設定&lt;/p&gt;
&lt;p&gt;np.random.seed(100)#乱数の初期化,毎回同じ乱数になる
Np = 50#粒子の数
obj = [int(float(args[1])),int(args[2])] #目的の（追いかける）標的の座標0~512
WD = 100&lt;/p&gt;
&lt;p&gt;px = np.zeros((Np),dtype=np.int64)#粒子のx座標
py = np.zeros((Np),dtype=np.int64)#粒子のy座標
lc = np.zeros((Np))#粒子の色の尤度
ls = np.zeros((Np))#粒子の空間の尤度
lt = np.zeros((Np))#粒子の尤度total
index = np.arange(Np)&lt;/p&gt;
&lt;h1&gt;objの周りに撒く&lt;/h1&gt;
&lt;p&gt;d = 10
px = np.random.normal(obj[0], d, Np).astype(np.int)
py = np.random.normal(obj[1], d, Np).astype(np.int)&lt;/p&gt;
&lt;p&gt;j = 0
artists = []
while True:
ret, frame = cap.read()#１枚読み込み
if ret == False:
break#最後になったらループから抜ける&lt;/p&gt;
&lt;p&gt;gx = np.average(px)
gy = np.average(py)#１フレーム前の粒子の重心&lt;/p&gt;
&lt;p&gt;for i in range(Np):
lc[i] = frame[py[i],px[i]][1] / 255.0#色の尤度
ls[i] = np.exp(-((px[i] - gx) &lt;strong&gt; 2 + (py[i] - gy) &lt;/strong&gt; 2)/(WD ** 2))
lt[i] = lc[i] * ls[i]
lt = lt / lt.sum()&lt;/p&gt;
&lt;p&gt;pnew_index = np.array(random.choices(population=index,weights=lt,k=Np))
pxnew = px[pnew_index] + np.random.randint(-15,15,Np)
pynew = py[pnew_index] + np.random.randint(-15,15,Np)&lt;/p&gt;
&lt;p&gt;plt.hist(lt)&lt;/p&gt;
&lt;h1&gt;リサンプリングした,ある程度ランダムウォーク&lt;/h1&gt;
&lt;p&gt;px = np.where(pxnew &amp;gt; w-1, w-1, pxnew)
py = np.where(pynew &amp;gt; h-1, h-1, pynew)
px = np.where(px &amp;lt; 0, 0, px)
py = np.where(py &amp;lt; 0, 0, py)#ランダムウォークで画面外に出る場合の処理
for i in range(Np):#画像の中に粒子を描く
cv2.circle(frame,(px[i],py[i]),1,(255,255,255),1)&lt;/p&gt;
&lt;p&gt;cv2.imwrite("/output/test_tiff/test" + str(j) + ".tif" ,frame) #tiffでも保存
j = j + 1&lt;/p&gt;
&lt;p&gt;output_dst.write(frame)
[/code]&lt;/p&gt;
&lt;p&gt;こんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;img class="alignnone size-full wp-image-192" src="https://pythonoum.files.wordpress.com/2018/10/untitled.gif" alt="Untitled" width="300" height="250" /&gt;&lt;/p&gt;
&lt;p&gt;ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー&lt;/p&gt;
&lt;p&gt;最初は尤度を計算するとき以下のようにやってました。
'''
pxnew = np.array(random.choices(population=px,weights=lt,k=Np)) + np.random.randint(-15,15,Np)
pynew = np.array(random.choices(population=py,weights=lt,k=Np)) + np.random.randint(-15,15,Np)
'''&lt;/p&gt;
&lt;p&gt;これではxとyを別々に計算してしまっているので、微妙に結果がおかしい感じになってました。（点が四角っぽくなる）
確かにそれはそうか。ランダムに選ぶのは１回でいいはず。。。。&lt;/p&gt;
&lt;p&gt;こういうとき、適当にindexとかおいてやるとうまくいくんですね。
今回もpnew_indexをおいてしまうという感じでやってます。&lt;/p&gt;
&lt;p&gt;pnew_index = np.array(random.choices(population=index,weights=lt,k=Np))
pxnew = px[pnew_index] + np.random.randint(-15,15,Np)
pynew = py[pnew_index] + np.random.randint(-15,15,Np)&lt;/p&gt;
&lt;p&gt;ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>Pythonの変数と代入について</title><link href="http://oumpy.github.io%5Carticles/2019/04/python_value.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/python_value.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Pythonの変数、ふだん何気なく使っていますが、やっていることは実は結構複雑です。主にC/C++と対比しつつ簡単にまとめてみます。&lt;/p&gt;
&lt;p&gt;実際のところ、よく知らなくてもあまり影響がない場合が殆どです。が、複雑な操作を行ったり何か変数の挙動が不審な場合などは、思い出してみるのもよさそうです。&lt;/p&gt;
&lt;h2&gt;変数は参照である&lt;/h2&gt;
&lt;p&gt;一言でいえば表題の通り。
Pythonでの&lt;strong&gt;変数への代入とは、変数の参照するメモリ（インスタンス）を切り替えること&lt;/strong&gt;であり、&lt;strong&gt;メモリの内容を書き換えることではない&lt;/strong&gt;。これが多くの言語（C/C++など）と大きく違うところです。&lt;/p&gt;
&lt;h2&gt;変数の代入(1)&lt;/h2&gt;
&lt;p&gt;例えばこんなコード。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C++で書き換えると、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;なのか？？
（#include\とかint main(void){...}とかは全部省略。）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;実は違う&lt;/strong&gt;のです。&lt;br&gt;
C++の方では&lt;code&gt;a&lt;/code&gt;で表されるメモリ領域を一つ確保し、そこにまず&lt;code&gt;0&lt;/code&gt;をセット、次に&lt;code&gt;1&lt;/code&gt;を、&lt;strong&gt;同じメモリ領域を書き換えて&lt;/strong&gt;セットしています。  &lt;/p&gt;
&lt;p&gt;Pythonの方はそうではありません。まず&lt;code&gt;0&lt;/code&gt;の値を持つメモリ領域を確保し、&lt;strong&gt;変数&lt;code&gt;a&lt;/code&gt;がそこを指すように&lt;/strong&gt;します。次に&lt;code&gt;1&lt;/code&gt;の値を持つ&lt;strong&gt;別のメモリ領域を確保&lt;/strong&gt;し、変数&lt;code&gt;a&lt;/code&gt;がそこを指すように切り替えます。&lt;/p&gt;
&lt;p&gt;C++で無理矢理それっぽいものを書くと、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;のようになります。&lt;br&gt;
（C++に参照定数はあるが参照変数がないため、ポインタで書いた。）&lt;/p&gt;
&lt;p&gt;実はこのC++コード、2行目で確保した&lt;code&gt;int(0)&lt;/code&gt;メモリを3行目の&lt;code&gt;int(1)&lt;/code&gt;代入時に&lt;strong&gt;放棄&lt;/strong&gt;していて、&lt;strong&gt;メモリリーク&lt;/strong&gt;が起こっています。C++では、これを処理（メモリ解放）するためのコードを本当は書き加えないといけません。&lt;br&gt;
しかし、Pythonではそれを&lt;strong&gt;ガベージコレクタ&lt;/strong&gt;という仕組みが&lt;strong&gt;勝手に代行&lt;/strong&gt;してくれます。逆にこれがないと、Pythonではメモリリークが頻繁に起こって大変なことになります。&lt;/p&gt;
&lt;h2&gt;変数の代入(2)&lt;/h2&gt;
&lt;p&gt;問題です。次のコードは何を出力するでしょうか。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 何が出る？&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;答えは「&lt;code&gt;0&lt;/code&gt;」&lt;/strong&gt;です。&lt;br&gt;
C++で書いた似たようなコード、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 出力は「0」&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;も結果は同じなのですが、内部動作は全く異なります。&lt;strong&gt;Pythonでの変数代入は参照の切り替え&lt;/strong&gt;であることがやはりポイントです。&lt;/p&gt;
&lt;p&gt;一方で、過程は違えどPythonもC++も結果は変わりません。&lt;strong&gt;気にしなくても大抵はうまくいく&lt;/strong&gt;、というのも大事なところです(笑)。&lt;/p&gt;
&lt;h2&gt;関数引数はすべて参照渡し&lt;/h2&gt;
&lt;p&gt;「変数が全て参照」であることから、関数引数もまた&lt;strong&gt;参照渡し&lt;/strong&gt;となります。C/C++のデフォルトである&lt;strong&gt;値渡し&lt;/strong&gt;と異なり、メモリのコピーなどは行われません。&lt;/p&gt;
&lt;p&gt;では再び問題。次のコードは何を出力するでしょう？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# ここまで。このprint()は何を出力するか？0？1？&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;「参照渡し」を知っている人ほど、「1」と答えたくなりそうですが、、  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答えは「0」&lt;/strong&gt;です。何故か？&lt;br&gt;
&lt;code&gt;func(a)&lt;/code&gt;を呼び出した時点では、&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の指すメモリは同じ&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;ですが、&lt;code&gt;x = 1&lt;/code&gt;で&lt;code&gt;x&lt;/code&gt;の指すメモリは&lt;strong&gt;別に確保された&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;に切り替わります。&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;および、&lt;code&gt;a&lt;/code&gt;の指す&lt;code&gt;0&lt;/code&gt;には何の変化も無い&lt;/strong&gt;のです。このあたりは前項の問題とほとんど同じです。&lt;/p&gt;
&lt;h2&gt;「変数への代入」ではない場合&lt;/h2&gt;
&lt;p&gt;例えばこんなとき。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 出力は[2,1]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3行目で&lt;code&gt;b&lt;/code&gt;と&lt;code&gt;a&lt;/code&gt;は同じリストを参照するようになります。4行目では、そのリスト（これも参照の列みたいなもの）の最初の成分を、&lt;code&gt;0&lt;/code&gt;でなく&lt;code&gt;2&lt;/code&gt;のメモリを参照するように切り替えます。全体として見れば&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;が同じリストを参照していることに変わりはないので、この変更は&lt;code&gt;b&lt;/code&gt;にも反映されています。&lt;/p&gt;
&lt;p&gt;これは、前項の関数引数で若干の問題を引き起こします。&lt;br&gt;
次のコード、前項で見たものにそっくりですが、、、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;前項とは違い、この出力は「&lt;code&gt;1&lt;/code&gt;」&lt;/strong&gt;です。&lt;br&gt;
関数が呼び出されると&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の指すリストは一貫して同じ&lt;/strong&gt;で、その一部が書き換えられるからです。これは&lt;strong&gt;リストでなくnumpy配列の場合もほぼ同じ&lt;/strong&gt;です。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;以上見てきたように、Pythonの変数は全て参照、関数引数は全て参照渡しです。これらが組み合わさると、結果的に全てを値渡しにした場合（C/C++）と殆ど違いが見えなくなり、あまり意識することなくプログラムを書けるようになっています。&lt;/p&gt;
&lt;p&gt;しかし、リストや配列（や、もっと複雑なクラスオブジェクトなど）のように部分的に書き換え可能なものを扱う場合などには、この違いはかなり重要になってきます。怪しいと思ったら、各変数が何を参照しているか、互いに同じか違うかなどを、その都度考えてみてください。&lt;/p&gt;
&lt;p&gt;ひとまず今回はここまで。おしまい。
※画像は&lt;a href="https://www.python.org/"&gt;公式&lt;/a&gt;のものです。&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>Pythonで可視化入門</title><link href="http://oumpy.github.io%5Carticles/2019/04/python_visualization.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>宮崎</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/python_visualization.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Pythonでいい感じのグラフを書いてみたい！でも面倒！よくわからない！&lt;/p&gt;
&lt;p&gt;これを読めばそんなあなたも簡単にいい感じのグラフがかける！&lt;/p&gt;
&lt;p&gt;この記事では、Pythonのライブラリーである、定番のmatplotlibとseaborn、pandasを使った可視化、インタラクティブなplotly、複数グラフ表示が簡単にできるラッパーであるholoviewsの簡単な解説をします。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;
&lt;h3&gt;matplotlib：&lt;u&gt;&lt;a href="https://seaborn.pydata.org/"&gt;https://matplotlib.org/&lt;/a&gt;&lt;/u&gt;(公式)&lt;/h3&gt;
定番のmatplotlibです。まずはギャラリー ( &lt;u&gt;&lt;a href="https://matplotlib.org/gallery/index.html"&gt;https://matplotlib.org/gallery/index.html&lt;/a&gt;&lt;/u&gt;)でいろいろなグラフを見てみましょう。グラフがたくさん並んでいて楽しいですね！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;
&lt;h3&gt;seaborn：&lt;u&gt;&lt;a href="https://seaborn.pydata.org/"&gt;https://seaborn.pydata.org/&lt;/a&gt;&lt;/u&gt;(公式)&lt;/h3&gt;
matplotlibをベースにしたseabornです。こちらもギャラリー(&lt;u&gt;&lt;a href="https://seaborn.pydata.org/examples/index.html"&gt;https://seaborn.pydata.org/examples/index.htm&lt;/a&gt;&lt;a href="https://seaborn.pydata.org/examples/index.html"&gt;l&lt;/a&gt;&lt;/u&gt;)を見てみましょう。ヒートマップがおしゃれですね！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;
&lt;h3&gt;pandas：&lt;u&gt;&lt;a href="https://pandas.pydata.org/index.html"&gt;https://pandas.pydata.org/index.html&lt;/a&gt;&lt;/u&gt;(公式)&lt;/h3&gt;
表計算で便利なpandasです。DataFrame形式のデータをpandas.DataFrame.plot(&lt;u&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/visualization.html"&gt;http://pandas.pydata.org/pandas-docs/stable/visualization.html&lt;/a&gt;&lt;/u&gt;)でグラフを書くのが一番手間がかからない気がします。bar(棒グラフ)やhistogramやscatter(散布図)を作るならこれで十分なことが多いです。DataFrameの.describe (&lt;u&gt;&lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html"&gt;https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html&lt;/a&gt;&lt;/u&gt;)で統計量が簡単に計算できるので、グラフがあっているかの確認も一連の流れでできます。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;
&lt;h3&gt;plotly：&lt;u&gt;&lt;a href="https://plot.ly/"&gt;https://plot.ly/&lt;/a&gt;&lt;/u&gt;(公式)&lt;/h3&gt;
インタラクティブに動かせるplotlyです。&lt;u&gt;&lt;a href="https://plot.ly/python/"&gt;https://plot.ly/python/&lt;/a&gt;&lt;/u&gt;(Python用) を見てみると、なんとグラフを動かせます！楽しい！Kaggleでもよく見ます。データ構造を調べるのに便利だからかもしれないですね。(例&lt;u&gt;&lt;a href="https://www.kaggle.com/andresionek/what-makes-a-kaggler-valuable?utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=Weekly-Kernel-Awards"&gt;https://www.kaggle.com/andresionek/what-makes-a-kaggler-valuable?utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=Weekly-Kernel-Awards&lt;/a&gt;&lt;/u&gt;) Dashと組み合わせると ( &lt;u&gt;&lt;a href="https://plot.ly/products/dash/"&gt;https://plot.ly/products/dash/&lt;/a&gt;&lt;/u&gt;) 簡単にWebアプリにできます。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;
&lt;h3&gt;holoview：&lt;u&gt;&lt;a href="http://holoviews.org/"&gt;http://holoviews.org/&lt;/a&gt;&lt;/u&gt;(公式)&lt;/h3&gt;
Pythonの可視化ツールはHoloViewsが標準になるかもしれない(&lt;u&gt;&lt;a href="https://qiita.com/driller/items/53be86cea3c3201e7e0f"&gt;https://qiita.com/driller/items/53be86cea3c3201e7e0f&lt;/a&gt;&lt;/u&gt;)とまで言われるholoviewは、matplotlibやplotly、bokehを簡単に使えるようにするラッパーです。特筆すべき機能として、introduction(&lt;u&gt;&lt;a href="http://holoviews.org/getting_started/Introduction.html"&gt;http://holoviews.org/getting_started/Introduction.html&lt;/a&gt;&lt;/u&gt;)をみるとわかるのですが、複数グラフ表示は足し算(例：Compositional Layouts layout =scatter +hv.Histogram)、オーバーレイは掛け算(例：Compositional Overlays image +image *points)で定義できとてもシンプルに書くことができます。&lt;/p&gt;
&lt;p&gt;可視化のまとめ(kaggle：&lt;u&gt;&lt;a href="https://www.kaggle.com/maheshdadhich/strength-of-visualization-python-visuals-tutorial"&gt;https://www.kaggle.com/maheshdadhich/strength-of-visualization-python-visuals-tutorial&lt;/a&gt;&lt;/u&gt;)もよくまとまっていて非常に勉強になります。&lt;/p&gt;
&lt;p&gt;そのほかにも、tensorflowの embedding &lt;u&gt;&lt;a href="https://www.tensorflow.org/guide/embedding"&gt;https://www.tensorflow.org/guide/embedding&lt;/a&gt;&lt;/u&gt;から Mnist や Word2Vecのデモ &lt;u&gt;&lt;a href="http://projector.tensorflow.org/"&gt;http://projector.tensorflow.org/&lt;/a&gt;&lt;/u&gt;(重いかも) や &lt;u&gt;&lt;a href="https://distill.pub/"&gt;https://distill.pub/&lt;/a&gt;&lt;/u&gt;も動かしてみると楽しいです！
&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
holoview最強説(plotlyも使えるラッパーなので)&lt;/p&gt;
&lt;p&gt;楽にしたいならpandasのplot、動かしたければplotly！&lt;/p&gt;
&lt;p&gt;keywordでググると詳しい記事がたくさん出てきます。&lt;/p&gt;
&lt;p&gt;上記以外の可視化手法や面白いものあれば教えてください！&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>pythonで使える正規表現まとめ</title><link href="http://oumpy.github.io%5Carticles/2019/04/regular_expression.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>西垣</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/regular_expression.html</id><summary type="html"></summary><content type="html">&lt;p&gt;O'REILLYの著書で「正規表現」について記載されているところをまとめたノートです。
正規表現はCtrl-Fのテキスト検索でも気軽に使えて大変便利なので、以下のまとめはpython3での正規表現の初歩的な使い方をまとめたものですが、知らなかった人は見てみてもいいかもです。&lt;/p&gt;
&lt;p&gt;要点
・?は、直前のグループの0回か1回の出現にマッチする。（任意のマッチ）
・&lt;em&gt;は、直前のグループの0回以上の出現にマッチする。
・+は、直前のグループの1回以上の出現にマッチする。
・{n}は、直前のグループのn回の出現にマッチする。
・{n,}は、直前のグループのn回以上の出現にマッチする。
・{,m}は、直前のグループの0~m回の出現にマッチする。
・{n,m}?、&lt;/em&gt;?、+?は直前のグループの非貪欲マッチを行う。&lt;/p&gt;
&lt;p&gt;▶文字集合
\d：0~9の数字
\D：0~9の数字以外
\w：文字、数字、下線（単語wordのw）
\W：文字、数字、下線以外
\s：スペース、タブ、改行（空白spaceのs）
\S：スペース、タブ、改行以外&lt;/p&gt;
&lt;p&gt;▶正規表現マッチのまとめ
・reモジュール
・re.compile()関数
・search()メソッド
・group()メソッド
・findall()メソッド&lt;/p&gt;
&lt;p&gt;実践&lt;/p&gt;
&lt;pre&gt;In [1]:
#! python 3
#正規表現モジュールのインポート
import re&lt;/pre&gt;

&lt;pre&gt;In [2]:
#'\d'は1文字の数字を表す正規表現
#'\d'を用いて、あるtextから、電話番号パターンにマッチする部分を検索しましょう。
#re.compile()に正規表現パターンを表す文字列を渡すと、Regexオブジェクトが返る

phone_num_regex = re.compile(r'\d\d\d-\d\d\d\d-\d\d\d\d')

#文字列の前のrはraw文字列を指定し、文字をエスケープせずに簡潔に表現しています&lt;/pre&gt;

&lt;pre&gt;In [3]:
#Regexオブジェクトのsearch()メソッドは、渡された文字列の中から正規表現にマッチするパターンが見つかれば、Matchオブジェクトを返します。
#Matchオブジェクトにはgroup()メソッドがあり、実際にマッチしたテキストを返します

mo = phone_num_regex.search('私の電話番号は080-1111-22222です。')
print('電話番号が見つかりました：' + mo.group())
電話番号が見つかりました：080-1111-2222
&lt;/pre&gt;

&lt;pre&gt;In [4]:
#'()'を用いたグルーピング

phone_num_regex = re.compile(r'(\d\d\d)-(\d\d\d\d-\d\d\d\d)')
mo = phone_num_regex.search('私の電話番号は080-1000-2000です。')
&lt;/pre&gt;

&lt;pre&gt;In [5]:
mo.group(1)
Out[5]:
'080'&lt;/pre&gt;

&lt;pre&gt;In [6]:
mo.group(2)
Out[6]:
'1000-2000'
&lt;/pre&gt;

&lt;pre&gt;In [7]:
mo.group(0)
Out[7]:
'080-1000-2000'&lt;/pre&gt;

&lt;pre&gt;In [8]:
mo.groups()
Out[8]:
('080', '1000-2000')
&lt;/pre&gt;

&lt;pre&gt;In [15]:
#'|'を使って複数のグループとマッチする。
#"r'Batman|Spiderman'"という正規表現は、'Batman'or'Spiderman'にマッチします。

hero_regex = re.compile(r'Batman|Spiderman')
mo1 = hero_regex.search('Batman and Yasmizuman')
mo1.group()
Out[15]:
'Batman'&lt;/pre&gt;

&lt;pre&gt;In [16]:
#両方ある場合は最初に出現したほうが返ります。

mo2 = hero_regex.search('The Spiderman fights Batman and Yasumizuman')
mo2.group()
Out[16]:
'Spiderman'&lt;/pre&gt;

&lt;pre&gt;In [19]:
#丸カッコと縦線とを応用

yasumizu_regex = re.compile(r'Yasumizu(man|woman|hotel)')
mo = yasumizu_regex.search('Yasumizuman lost his way back to Yasumizuhotel.')
mo.group(1)
Out[19]:
'man'&lt;/pre&gt;

&lt;pre&gt;In [20]:
#'?'を用いた任意のマッチ

yasu_regex = re.compile(r'Yasumizu(wo)?man')
mo1 = yasu_regex.search('The Adveture of Yasumizuman')
mo1.group()
Out[20]:
'Yasumizuman'
&lt;/pre&gt;

&lt;pre&gt;In [21]:
mo2 = yasu_regex.search('The Adveture of Yasumizuwoman')
mo2.group()
Out[21]:
'Yasumizuwoman'
&lt;/pre&gt;

&lt;pre&gt;In [22]:
#'*'を用いた0回以上のマッチ

yasu_regex = re.compile(r'Yasu(mi)*zu')
mo1 = yasu_regex.search('The Adventure of Yasuzu')
mo1.group()
Out[22]:
'Yasuzu'
&lt;/pre&gt;

&lt;pre&gt;In [24]:
mo2 = yasu_regex.search('The Adventure of Yasumimimimimimimizu')
mo2.group()
Out[24]:
'Yasumimimimimimimizu'
&lt;/pre&gt;

&lt;pre&gt;In [26]:
#'+'を用いた1回以上のマッチ

yasu_regex = re.compile(r'Yasu(mi)+zu')
mo1 = yasu_regex.search('The Adventure of Yasumimimimimizu')
mo1.group()
Out[26]:
'Yasumimimimimizu'
&lt;/pre&gt;

&lt;pre&gt;In [28]:
mo2 = yasu_regex.search('The Adventure of Yasuzu')
mo2 == None
Out[28]:
True&lt;/pre&gt;

&lt;pre&gt;In [30]:
#'{}'を用いて繰り返し回数を指定する
#(Ha){3} = (HaHaHa) , (Ha){3,5} = (HaHaHa|HaHaHaHa|HaHaHaHaHa)

ha_regex = re.compile(r'(Ha){3,5}')
mo1 = ha_regex.search('HaHaHaHaHa')
mo1.group()
Out[30]:
'HaHaHaHaHa'
&lt;/pre&gt;

&lt;pre&gt;In [34]:
mo2 = ha_regex.search('Ha')
mo2 == None
Out[34]:
True&lt;/pre&gt;

&lt;pre&gt;In [35]:
#貪欲マッチ：ジャガビーは一番長いものをとる
#Pythonの正規表現は、デフォルトでは貪欲マッチです。つまり、複数の可能性があると最も長い方にマッチします。

greedy_Ha_regex = re.compile(r'(Ha){3,5}')
mo1 = greedy_Ha_regex.search('HaHaHaHaHaHaHaHaHaHaHa')
mo1.group()
Out[35]:
'HaHaHaHaHa'&lt;/pre&gt;

&lt;pre&gt;In [36]:
#非貪欲マッチ：遠慮して一番短いものをとる
#閉じカッコの後に'?'

nongreedy_Ha_regex = re.compile(r'(Ha){3,5}?')
mo2 = nongreedy_Ha_regex.search('HaHaHaHaHaHaHaHaHaHaHa')
mo2.group()
Out[36]:
'HaHaHa'&lt;/pre&gt;

&lt;pre&gt;In [38]:
#findall()メソッド
#search()が最初に見つかった文字列を返すのに対し、findall()は見つかったすべての文字列を返します。
#findall()はタプルのリストを返すことに注意
phone_num_regex = re.compile(r'\d\d\d-\d\d\d\d-\d\d\d\d')
phone_num_regex.findall('Cell: 415-5555-9999 Work: 212-5555-0000')
Out[38]:
['415-5555-9999', '212-5555-0000']
&lt;/pre&gt;

&lt;pre&gt;In [39]:
phone_num_regex = re.compile(r'(\d\d\d)-(\d\d\d\d)-(\d\d\d\d)')
phone_num_regex.findall('Cell: 415-5555-9999 Work: 212-5555-0000')
Out[39]:
[('415', '5555', '9999'), ('212', '5555', '0000')]
&lt;/pre&gt;

&lt;p&gt;続きはありますが、あまり出しすぎるとネタが無くなるので、今回はここまでにしておきます。
また書きます。&lt;/p&gt;
&lt;p&gt;↑をうまく利用して、自分で電子メールアドレスの正規表現を作ってみてもおもしろいと思います。&lt;/p&gt;
&lt;p&gt;正規表現について、さらに詳しく↓&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.jp/3/library/re.html"&gt;6.2. re — 正規表現操作 — Python 3.6.3 ドキュメント&lt;/a&gt;
6.2.1. 正規表現のシンタックス ¶ (原文) 正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表しています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッチするか (または指定の正規表現がある文字列にマッチするか、つまりは同じことですが) を検査できます。 正規表現を連結すると新しい正規表現を作れます。 A と B がともに正規表現であれば AB も正規表現です。一般的に、文字列 p が A とマッチし、別の文字列 q が B とマッチすれば、文字列 pq は AB にマッチします。ただし、この状況が成り立つのは、 A と B との間に境界条件がある場合や、番号付けされたグループ参照のような、優先度の低い演算を A や B が含まない場合だけです。かくして、ここで述べるような、より簡単でプリミティブな正規表現から、複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細については上記の Friedl 本か、コンパイラの構築に関する教科書を調べて下さい。 以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な...&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/dongri/items/2a0a18e253eb5bf9edba"&gt;よく使う正規表現はもうググりたくない！ - Qiita&lt;/a&gt;
タイトル通りによく使う正規表現を毎回ググるのが効率悪いのでまとめてみました。各言語で正規表現のサンプルを書いてみました。 # 正規表現式 * Emailアドレス `^\w+([-+.]\w+)&lt;em&gt;@\w+([-.]\w+)&lt;/em&gt;.\w...&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>シェルスクリプト入門(1)</title><link href="http://oumpy.github.io%5Carticles/2019/04/shellscript_1.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>水野</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/shellscript_1.html</id><summary type="html"></summary><content type="html">&lt;p&gt;python会なのにpythonまだ触ったことありません。勉強せねば。&lt;/p&gt;
&lt;p&gt;データ整形の流れって、教わる機会なくないですか？
つまらないものですが、僕のやり方を紹介してみます。
始めたばかりの人は参考にしてください。
経験者の方、変なとこあったらどしどし突っ込みください！
そして皆さんの自己流も教えてもらえると嬉しいです。&lt;/p&gt;
&lt;h2&gt;1) scriptに起こす前&lt;/h2&gt;
&lt;p&gt;shell scriptに書き起こす前に、プロンプト画面（Mac,Ubuntuならterminal）でテストします。
僕はいつもcatでファイルにつないで、パイプの後に試したいコマンドを打ちます。
その後にパイプでheadにつないで、頭だけ出力してみます。たいていファイル重いので。
圧縮ファイルの時は、解凍する前にzcatでつないで試します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;cat hogehoge.txt | sed 1d（試したいコマンド）| head&lt;/span&gt;
&lt;span class="err"&gt;zcat hoge.gz | cut –f1（試したいコマンド）| head&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一行が長くて確認しづらい！と思ったら、headからless –Sにつなぎます。
別画面で折り返しなしで見ることができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;cat hogehoge | sed 1d（試したいコマンド）| head | less -S&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2) scriptを書く&lt;/h2&gt;
&lt;p&gt;うまくいきそうで、だいたい流れが思い描けたらshell scriptに書き起こします。
結局他のファイルも同じ処理をするはめになり、scriptに残しておけば・・と後悔することが多いからです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;touch test.sh # ファイルつくって、&lt;/span&gt;
&lt;span class="err"&gt;emacs test.sh # emacsで開く。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#!/bin/bash # おまじない。&lt;/span&gt;
&lt;span class="err"&gt;$1=filename # ファイルはいつも外から入れれるようにしてます。&lt;/span&gt;
&lt;span class="err"&gt;rm –r ./folder # 一発で上手くいくことはないので、やり直しやすいように消去コマンド。&lt;/span&gt;
&lt;span class="err"&gt;mkdir ./folder # 散らからないように専用フォルダを作成。&lt;/span&gt;
&lt;span class="err"&gt;dir1=&amp;quot;./folder&amp;quot; # フォルダ名をいつでも変えやすいようにパスを変数にいれる。&lt;/span&gt;
&lt;span class="err"&gt;cat &amp;quot;$filename&amp;quot; | sed 1d &amp;gt; &amp;quot;$dir1&amp;quot;/hogehoge2.txt #目的のコマンドで処理して保存。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;3) 実行&lt;/h2&gt;
&lt;p&gt;書けたら、処理したいファイルを渡して実行してみます。
&amp;amp;はバックグラウンド実行です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;bash ./test.sh ./hogehoge.txt &amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;時間がかかりそうで家に帰りたいときは、nohupでサーバーと切れても大丈夫なように。
screenを使うこともあります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;nohup bash ./test.sh ./hogehoge.txt &amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4)　修正&lt;/p&gt;
&lt;p&gt;scriptを修正するときは、元の文は#をつけてコメントアウトしときます。
そうすれば、後でやり直しやすいです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# cat &amp;quot;$filename&amp;quot; | sed 1d &amp;gt; &amp;quot;$dir1&amp;quot;/hogehoge2.txt # コメントアウトして置いておく。&lt;/span&gt;
&lt;span class="err"&gt;cat &amp;quot;$filename&amp;quot; | grep &amp;quot;blahblah&amp;quot; &amp;gt; &amp;quot;$dir1&amp;quot;/hogehoge2.txt # 新しい文。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;どこでバグってるか分からない時は、とりあえずechoで変数を出してみたりしてチェックしてます。&lt;/p&gt;
&lt;h2&gt;5) 応用編&lt;/h2&gt;
&lt;p&gt;あとはひたすらコマンドを駆使して書き上げていきます。
以下の基本コマンドでだいたいのことはできるかと。
特にawkはたくさんのことができます。joinも重宝します。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;command&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;ファイルを縦につなぐ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;paste&lt;/td&gt;
&lt;td&gt;ファイルを横につなぐ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sed&lt;/td&gt;
&lt;td&gt;指定行抜き出すor削除or文字置換&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cut&lt;/td&gt;
&lt;td&gt;指定列抜き出すor削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;awk&lt;/td&gt;
&lt;td&gt;抜き出し方をいろいろカスタマイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tr&lt;/td&gt;
&lt;td&gt;文字置換&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort&lt;/td&gt;
&lt;td&gt;整列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uniq&lt;/td&gt;
&lt;td&gt;重複行を削除or抜き出す&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;join&lt;/td&gt;
&lt;td&gt;2つのファイルを同じ項目で合わせる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;特定の文字が入った行を出す&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各コマンドのオプションの使い方が重要ですが、長くなってきたので詳細はまたの機会に。&lt;/p&gt;</content><category term="tech_archive"></category><category term="shell"></category></entry><entry><title>シェルスクリプト入門(2)</title><link href="http://oumpy.github.io%5Carticles/2019/04/shellscript_2.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>水野</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/shellscript_2.html</id><summary type="html"></summary><content type="html">&lt;p&gt;※　編集注：前作&lt;a href="https://pythonoum.wordpress.com/2018/11/01/%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E5%85%A5%E9%96%801/"&gt;シェルスクリプト入門（1）&lt;/a&gt;の続編です。まだ読み終わってない方はそちらを先にどうぞ。&lt;/p&gt;
&lt;p&gt;テーブルファイルの操作と言えばRです。 (※　編集注：Pythonでもできます。)
が、そこまでbashで書いてきたのに、R呼び出して変数再設定して…面倒くさいから嫌だ！！
ってことないでしょうか。&lt;/p&gt;
&lt;p&gt;Rの機能を代替するのは無理ですが、せめてほんの少し、
例えば、テーブル中の値をそれぞれbashの変数に入れれたら、
Rを呼び出さずに完結できたりします。&lt;/p&gt;
&lt;p&gt;要は、&lt;code&gt;$ mat_i_j=i行j列目の要素&lt;/code&gt;で変数を格納していきます。&lt;/p&gt;
&lt;p&gt;対象ファイル名を、table.txtで、タブ区切り、中身は以下みたいの。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;a    b    c&lt;/span&gt;
&lt;span class="err"&gt;1    2    3&lt;/span&gt;
&lt;span class="err"&gt;d    e    f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これの各要素を、&lt;code&gt;$mat_i_j&lt;/code&gt; に格納していきます。
一例として、以下のスクリプトでできます。
配列つかったりしてもっといいスクリプトもきっとあります。&lt;/p&gt;
&lt;p&gt;bashは汚いスクリプトでもたいてい速く動いてくれるので成長しないですね。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;row&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;## 行番号に使う変数の設定。&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; x1 x2 x3 &lt;span class="c1"&gt;## 解説①&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nv"&gt;row&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;expr &lt;span class="nv"&gt;$row&lt;/span&gt; + &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt; &lt;span class="c1"&gt;## 1行ずつ読んでくので、1ずつ足していく。&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; col in &lt;span class="sb"&gt;`&lt;/span&gt;seq &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt; &lt;span class="c1"&gt;## 今読んでる行での列番号をfor文で回す。&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt;
        &lt;span class="nb"&gt;eval&lt;/span&gt; mat_&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;row&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;_&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;col&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="nv"&gt;$x&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;col&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt; &lt;span class="c1"&gt;## 解説②&lt;/span&gt;
    &lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;lt&lt;span class="p"&gt;;&lt;/span&gt;table.txt

&lt;span class="c1"&gt;### 変数mat_$i_$j を使った処理が続く。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;時間のある人用に解説です。
少し小技があります。&lt;/p&gt;
&lt;h3&gt;1) while readの使い方&lt;/h3&gt;
&lt;p&gt;よく見かけるのは、&lt;code&gt;cat&lt;/code&gt;からパイプで&lt;code&gt;while read&lt;/code&gt;につなぐやつです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat table.txt &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; x1 x2 x3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ファイルを一行ずつ読んで、各列の要素を&lt;code&gt;read&lt;/code&gt;の後ろに置いた変数名&lt;code&gt;（x1,x2,x3）&lt;/code&gt;に格納していきます。変数名の個数は任意です。ここでは列の数に合わせてます。
各行ごとに、&lt;code&gt;do&lt;/code&gt;～&lt;code&gt;done&lt;/code&gt;の間で、&lt;code&gt;$x1&lt;/code&gt;,&lt;code&gt;$x2&lt;/code&gt;,&lt;code&gt;$x3&lt;/code&gt;が使えるようになります。&lt;/p&gt;
&lt;p&gt;が、しかし、パイプで&lt;code&gt;while&lt;/code&gt;に入ってしまうと、パイプ内はパイプ内で完結するため、
&lt;code&gt;do&lt;/code&gt;~&lt;code&gt;done&lt;/code&gt;の中で変数操作をしても、&lt;code&gt;done&lt;/code&gt;の後では、その中身が空っぽになっちゃいます。&lt;/p&gt;
&lt;p&gt;これを回避するためには、パイプを使わないということで、リダイレクトで、
&lt;code&gt;done&lt;/code&gt;の後ろに&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;done&lt;/span&gt;&amp;lt;table.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;を書きます。
読みにくいですよねー。&lt;/p&gt;
&lt;h3&gt;2) evalの使い方&lt;/h3&gt;
&lt;p&gt;今回の&lt;code&gt;mat_$i_$j&lt;/code&gt;のように、変数名に変数&lt;code&gt;($i,$j)&lt;/code&gt;を使って値を格納する時には、&lt;code&gt;eval&lt;/code&gt;を使います。
&lt;code&gt;eval&lt;/code&gt;は、その後に書いた文をもってきて、bashスクリプトとして評価（evaluate）します。&lt;/p&gt;
&lt;p&gt;なので、&lt;code&gt;i=2, j=3&lt;/code&gt; として、&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eval mat_${i}_${j}=aaa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;は、
&lt;code&gt;mat_2_3=aaa&lt;/code&gt; をスクリプトとして評価しろ、ということになり、
&lt;code&gt;mat_2_3&lt;/code&gt;という変数名に、&lt;code&gt;aaa&lt;/code&gt;が入ります。
（ちなみに、どこまでが変数名か分からなくなる状況では、変数名を{}でくくります。ここではiとj。）&lt;/p&gt;
&lt;p&gt;変数を使った変数名の中身を出力させる場合には、echoとevalを組み合わせます。
&lt;code&gt;col=1&lt;/code&gt;として、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="se"&gt;\$&lt;/span&gt;x&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;col&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;と書けば、まず、&lt;code&gt;eval&lt;/code&gt;が&lt;code&gt;$col&lt;/code&gt;の中身を出してからスクリプトとして評価するので、
（xの$には\がかかってるので無視されます）
&lt;code&gt;echo $x1&lt;/code&gt;
と書いていることになり、通常の&lt;code&gt;echo&lt;/code&gt;で書いたように、&lt;code&gt;$x1&lt;/code&gt;の中身が出力されます。
xの$にかかってた\は、&lt;code&gt;eval&lt;/code&gt;での評価で消費されて、&lt;code&gt;echo&lt;/code&gt;内にはなくなります。ここ重要。&lt;/p&gt;
&lt;p&gt;やりたいことは、&lt;code&gt;eval echo&lt;/code&gt;で出してきた値を、変数を使った変数名に格納することです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eval mat_${i}_${j}=aaa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;の&lt;code&gt;aaa&lt;/code&gt;部分に&lt;code&gt;eval echo&lt;/code&gt;を直接もってきても、機能しません。
&lt;code&gt;eval echo&lt;/code&gt;のままでは、まだ値ではなくスクリプトだからです。&lt;/p&gt;
&lt;p&gt;なので、そのスクリプトを実行させて値を出力させたものを、&lt;code&gt;aaa&lt;/code&gt;の部分に書きます。
そういう時は、アクサングラーブ（` シフト押しながら＠）でくくります。&lt;/p&gt;
&lt;p&gt;アクサングラーブは、その中にあるスクリプトの実行結果を出力します。
なので、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;test&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$k&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;とすれば、&lt;code&gt;$k&lt;/code&gt;の中身が出力されて、&lt;code&gt;test&lt;/code&gt;に格納されます。
&lt;code&gt;row&lt;/code&gt;に1ずつ足していくとこでも使ってます。よく見る方法です。
&lt;code&gt;for&lt;/code&gt;文使わなくていいので、見た目がすっきりします。&lt;/p&gt;
&lt;p&gt;では、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;eval mat_&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;_&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;=`eval echo \&lt;span class="nv"&gt;$x&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;と書けば、&lt;code&gt;mat_2_3&lt;/code&gt;に&lt;code&gt;$x1&lt;/code&gt;の中身が代入されるはず！
となるのですが、不完全です。&lt;/p&gt;
&lt;p&gt;アクサングラーブでの評価で、&lt;code&gt;\&lt;/code&gt;が一個消費されてしまうので、実行する&lt;code&gt;eval echo&lt;/code&gt;の文が、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$x&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;col&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;となるので、&lt;code&gt;eval&lt;/code&gt;での評価時に&lt;code&gt;$x&lt;/code&gt;の中身（設定してないので空っぽ）と&lt;code&gt;$col&lt;/code&gt;が出されてしまって、
&lt;code&gt;echo (空)1&lt;/code&gt;
となって、最終的に、&lt;code&gt;mat_2_3&lt;/code&gt;には&lt;code&gt;$x1&lt;/code&gt;ではなく、&lt;code&gt;$col&lt;/code&gt;の中身である1が代入されてしまいます。&lt;/p&gt;
&lt;p&gt;なので、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;eval mat_&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;_&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;=`eval echo \\&lt;span class="nv"&gt;$x&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;と、\を一個増やして書けば、目的達成です。
めでたしめでたし。&lt;/p&gt;
&lt;p&gt;※ 編集注 : 記事はめでたく終わりましたが、アクサングラーブがマークダウンと干渉してしまいました。試行錯誤の結果、ところどころテキストが混じって読みにくくなってしまいました。すみません。&lt;/p&gt;</content><category term="tech_archive"></category><category term="shell"></category></entry><entry><title>5年次海外実習</title><link href="http://oumpy.github.io%5Carticles/2019/04/study_abroad.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>宮崎　佐藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/study_abroad.html</id><summary type="html"></summary><content type="html">&lt;p&gt;&lt;span style="font-weight:400;"&gt;1月末から3月中旬までオーストラリアのメルボルンに海外実習に行ってました、５年生の佐藤です。基礎系の研究室に行ったのですが、僕がまだまだ勉強不足なところも多くこれからの勉強のモチベーションにもなりました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;僕の実習内容についてはまだまとまっていないので、去年行った先輩の資料をもらいました。&lt;/p&gt;
&lt;p&gt;[slideshare id=135802981&amp;amp;doc=rlfhhaarhsceewdyrtxz-signature-e54772a31b57df6de43cc9594331c021bf0f3832af3fbc67ab36dc5b03a0726b-poli-190312064228]&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;海外での生活は旅行も含めて初めてだったので本当に不安でしたが、寮の友達が親切に接してくれて本当に助かりました。ここでその暮らしぶりを少し書かせてもらおうと思います。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;英語について&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;僕を含めて多くの人が海外留学する際に懸念していることかもしれません。IELTSはギリギリ6.0でかつ直前まで英語の勉強をサボっていたので非常に心配でした。なんとかなるかなーと割と楽観的だったのですが、空港でコーヒー頼む時に全然通じなくて絶望しました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;ただ、僕が滞在していた寮は留学生が多く住んでいる寮で英語を母国語としている人はそこまで多くなかったので助かりました。それでも最初は聞き取れませんでしたが、周りの人が割と根気強く伝えようとしてくれたのでありがたかったです。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;日本に帰ってからもちゃんと英語勉強します。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;寮生活について&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;今回僕は大学内にある寮的なところに滞在しました。朝晩食事付きで週34000円くらいです。オーストラリアにしてはだいぶ良心的ですが、それでも１ヶ月半いるとなるとばかにならないし、行かせてくれた親には超感謝してます。朝晩バイキング形式で食べるので、必然的に他の住人と話すことになるわけですが、結果的にこれがよかったです。用事を作らずとも自然に人と話す機会があるし、色々な人の色々な人生が聞けてすごく楽しいです。ここでたくさんの友達ができました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;部屋も結構快適で落ち着きます。風呂とトイレは共同と聞いていて結構ビビってたんですが、全然不快な感じはなかったです。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;寮というものに住んだことがなかったので、とても新鮮でした。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[gallery ids="518,519" type="rectangular"]&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;メルボルンという町について&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;ぶっちゃけ日本より住みやすい気がします。気温の年較差は小さく(冬でも10度前後)、日較差は大きいです(今は夏ですが、最低気温18度くらい)。昼間はラボに行っているので、外に出る時は5月くらいの気候で超気持ちいいです。日差しは強いのでオーストラリア来る時は日焼け止め必須です。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;メルボルンはアートとスポーツの町です。そこらかしこに美術館や記念館があり、とても全部は行けないほどです。古い建築物が多く残っており、伝統的な西洋建築が立ち並ぶかと思いきや、流線形のドーム状の病院や路地裏にはストリートアート的なものがそこら中に描かれ、それらがいい意味で混じり合い独特の景観を形成しています。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;先日全豪オープンが開かれたのもこの町です。ちょうど中之島のように中心地のすぐ近くにヤラ川という川が流れており、ボート競技も盛んに行われていました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;オーストラリアは移民の国で、色々な人種の人たちがいます。だいたい３割がアジア系(中国が最多)、アフリカ系の人も結構います。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[gallery ids="520,521" type="rectangular"]&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;海外の留学生について&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;アジア系の人たちが結構多かったです。特に中国はチャイナタウンもあるからなのか、非常に多くの学生が来ています。話を聞いていると、中国の学生の20%くらいの人が海外で修士、あるいは博士を取るらしく、英語は使えて当然のような雰囲気が伺えました。日本は自国の大学や研究機関以外の選択肢があまりないというか、海外に行く人が(少なくとも僕の周りには)少ないので驚きました。当然、speakingやlisteningの能力も程度の差こそあれ、日本人は劣っていると思います。カナダ人から「日本人ってシャイだしあんまり英語も喋れないよねー」って言われて、確かに、、、と納得してしまいました。海外に渡り、技術や知識を取り入れるのがスタンダードになろうとしている他のアジア諸国の人たちを見ていると、日本の将来を考えずにはいられませんでした。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;まとめ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;海外での生活は予想よりもはるかに楽しかったです。これは寮の友達によるところが大きかったです。毎日誰かが寮のどこかでボードゲームなどで遊んでおり、それを見ているだけでも楽しく、また一緒にやろうぜと気軽に誘ってくれました。休日はみんなで出かけ、それぞれの故郷の料理を交互に食べ、文化について語り合う。考え方は人それぞれなのはもちろん、国や宗教に大きく影響を受けていることを知りました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;旅行ではなかなか味わえないたくさんの貴重な経験をさせてもらいました。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-weight:400;"&gt;海外に行ってみたい、というミーハーな理由で海外実習を選びましたが、行って本当によかったです。皆さんも是非！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[gallery ids="523,522" type="rectangular"]&lt;/p&gt;</content><category term="tech_archive"></category><category term="paper"></category></entry><entry><title>寿司打タイピング自動化</title><link href="http://oumpy.github.io%5Carticles/2019/04/sushi_typing.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/sushi_typing.html</id><summary type="html"></summary><content type="html">&lt;p&gt;[youtube https://www.youtube.com/watch?v=SqOO9I1tFjk&amp;amp;w=560&amp;amp;h=315]&lt;/p&gt;
&lt;p&gt;寿司打の自動化についてです。上の動画のようになりました。寿司打は結構昔からあるタイピング練習サイトです。寿司打は&lt;a href="http://typing.sakura.ne.jp/sushida/"&gt;こちら&lt;/a&gt;です。
1万円コースで1万円超えない人はタイピング遅いので特訓しましょう。&lt;/p&gt;
&lt;p&gt;自動化の流れとしては
- スクリーンショットを取る(PIL)
- OCRで文字認識をする(pyocr)
- キーボード入力(pyautogui)&lt;/p&gt;
&lt;p&gt;です。
ご認識を防ぐため、調整用のところでできるだけ正確にローマ字部分が入るようにスクリーンショットの座標をあわせないといけません。
今回はMBPをつかって一万円コース63120 円でした。OCRの部分が律速になっていそうなので、リソースかアルゴリズムでここを高速化するとプラトーになるのではと考えています。
一晩中自動でゲームを繰り返してスコアをメモし続けるように書き直したので、少し冗長なコードになっています。
ところで、ランキングをチェックすると、抜かれていたので、だれかリベンジしてください。&lt;/p&gt;
&lt;p&gt;https://gist.github.com/yyoshiaki/a9a2eea1105a654e6b9beaaf2b854871&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>Twitter自動投稿あれこれ</title><link href="http://oumpy.github.io%5Carticles/2019/04/twitter_automation.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>川崎</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/twitter_automation.html</id><summary type="html"></summary><content type="html">&lt;p&gt;突如TwitterのBotを作ってみたくなり試行錯誤した結果をまとめてみました。&lt;/p&gt;
&lt;h2&gt;☆きっかけ&lt;/h2&gt;

&lt;ol&gt;
    &lt;li&gt;講義棟の音出し禁止時間を毎日6時に通知してくれるBOTが欲しい。&lt;/li&gt;
    &lt;li&gt;幸い音出し禁止時間はネット上に記載されているので、毎日取得して呟くだけなら実装は簡単そう。&lt;/li&gt;
    &lt;li&gt;何よりPython会の記事のネタになる。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;☆Twitter APIの取得&lt;/h2&gt;

&lt;p&gt;Botを作るにはAPI （アプリケーション・プログラミング・インタフェイス）が必要です。&lt;/p&gt;
&lt;p&gt;まあアカウント作ったら一発やろーと高を括っていたのですが、最近Twitter APIの使用申請が厳格化されたらしくなんだか不安。&lt;/p&gt;
&lt;p&gt;https://developer.twitter.com/&lt;/p&gt;
&lt;p&gt;とりあえずここにアクセスし、利用登録を進めていきます。&lt;/p&gt;
&lt;p&gt;慣れない英語を読みすすめるとどうやら必要なのが&lt;/p&gt;
&lt;p&gt;・使用用途を英語で入力(400字程度)&lt;/p&gt;
&lt;p&gt;大学入試以来の英作文です。&lt;/p&gt;
&lt;p&gt;しかしそんな英語力は無いので適当に文章作ってGoogle翻訳(https://translate.google.co.jp/?hl=ja)にぶち込みます。小学生並みの文章が出来上がりました。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.I decided to use the Twitter API to study programming.In order to know what many people are interested in, I would like to learn what kind of program to write. 2....&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;若干嘘が混じっている気もしますが気にしません。早速フォームに入力して送信しました。&lt;/p&gt;
&lt;p&gt;なお事前に調べた情報ではここでTwitter社からなかなか返信が返って来ず断念するケースが多いみたいです。緊張します。&lt;/p&gt;
&lt;p&gt;しかしドキドキする間もなく一瞬で申請が通りました。どうしてでしょうか。&lt;/p&gt;
&lt;p&gt;実は「chat bot」など自動化に関する単語が含まれていると検閲に引っかかりやすいらしく、婉曲表現を用いて危険なワードを巧みに回避していたのでした。下調べは大切ですね。&lt;/p&gt;
&lt;p&gt;晴れて使用権限を得たので早速使っていきます。BOT作成に必要な値は次の4つです。ログインすれば見ることができます。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="602"&gt;CONSUMER_KEY = "***********************************************"
CONSUMER_SECRET = "********************************************"
ACCESS_TOKEN = "**********************************************"
ACCESS_TOKEN_SECRET = "******************************************"&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上のようにしてconfig.pyとしてまとめておくと後々楽です。&lt;/p&gt;
&lt;h2&gt;☆書く&lt;/h2&gt;

&lt;p&gt;事前にpip install requestsとpip install requests_oauthlibしておきます。&lt;/p&gt;
&lt;p&gt;先ほど取得した4つのKeyはconfig.pyとして同じ階層に忘れずに置いておきます。&lt;/p&gt;
&lt;p&gt;内容は1.取ってきて 2.整形して 3.ツイートする という流れです。シンプルですね。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="602"&gt;import requests　#スクレイピング
import json, config #jsonモジュールとconfig.pyの読み込み
from requests_oauthlib import OAuth1Session #OAuthのライブラリの読み込みURL = "hoge"
UserAgent = "huga"

headers = {"User-Agent": UserAgent}
s = requests.Session()
resp = s.get(URL, timeout=10, headers=headers) #HTML取得

lines = resp.text.split("\n")

(中略)(HTMLから整形する作業)

CK = config.CONSUMER_KEY
CS = config.CONSUMER_SECRET
AT = config.ACCESS_TOKEN
ATS = config.ACCESS_TOKEN_SECRET
twitter = OAuth1Session(CK, CS, AT, ATS) #認証処理

url = "https://api.twitter.com/1.1/statuses/update.json"

tweet = u"おはようッピ！\n{}月{}日({})の音出し禁止時間をお知らせするッピ！\n\n『{}』\n\n今日も一日がんばるッピ！！".format(m,d,w,notify)

params = {"status" : tweet}

res = twitter.post(url, params = params) #post送信
#print(tweet) #テスト表示

if res.status_code == 200: #成功した場合
print("Success.")
else:
print("Failed. : %d"% res.status_code)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;☆実行結果&lt;/h2&gt;

&lt;p&gt;&lt;img class="alignnone size-full wp-image-458" src="https://pythonoum.files.wordpress.com/2019/01/picture1.png" alt="picture1" width="939" height="527" /&gt;&lt;/p&gt;
&lt;p&gt;成功です。語尾は適当です。&lt;/p&gt;
&lt;p&gt;(この後自動投稿するまでの流れがありますが締め切りが来てしまったので一旦提出します。)&lt;/p&gt;</content><category term="tech_archive"></category><category term="python"></category></entry><entry><title>超高速次元圧縮アルゴリズムUMAP</title><link href="http://oumpy.github.io%5Carticles/2019/04/umap.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>安水</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/umap.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;超高速次元圧縮アルゴリズムUMAP&lt;/h1&gt;

&lt;p&gt;世間では、高性能な次元圧縮アルゴリズムとしてtSNEがよく使われています。 tSNEは便利ですが、少し遅いです。（パラメーターも意外に面倒。 &lt;a href="https://deepage.net/machine_learning/2017/03/08/tsne.html"&gt;tsneのパラメータについて&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;そこで今回紹介するのはUMAP。 arxivで今月publishされたばかりのアルゴリズムです(記事執筆時 2018年2月時点)。 試しにMNIST(手書き数字画像。28*28=764次元)70000枚の次元圧縮をしてみました。&lt;/p&gt;
&lt;p&gt;tSNEではちょうど1時間30分でしたが、UMAPではたったの1分でした。&lt;/p&gt;
&lt;p&gt;詳細はこちら。 https://github.com/lmcinnes/umap&lt;/p&gt;
&lt;p&gt;インストールは $ pip install umap&lt;/p&gt;
&lt;p&gt;こちらが今回のソースコード。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;from sklearn import datasets
import matplotlib.pyplot as plt
%matplotlib inline

digits = datasets.fetch_mldata('MNIST original')

print(digits['data'].shape)

import umap
embedding = umap.UMAP().fit_transform(digits.data)
plt.figure(figsize=(12,8))
plt.scatter(embedding[:,0],embedding[:,1],c=digits.target, s=0.1)
plt.title('UMAP')
plt.savefig('umap.png')

from sklearn.manifold import TSNE
model = TSNE(n_components=2)
tsne_result = model.fit_transform(digits.data)
plt.figure(figsize=(12,8))
plt.scatter(tsne_result[:,0],tsne_result[:,1],c=digits.target, s=0.1)
plt.title('tSNE')
plt.savefig('tsne.png')&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img title="" src="https://pythonoum.files.wordpress.com/2018/09/null1.png" alt="" width="334" height="222" /&gt;&lt;img title="" src="https://pythonoum.files.wordpress.com/2018/09/null.png" alt="" width="333" height="221" /&gt;&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>VELOCYTO</title><link href="http://oumpy.github.io%5Carticles/2019/04/velocyto.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>廣瀬</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/velocyto.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Velocyto は、RNAseq の結果に含まれるイントロンの割合からその細胞の分化指向性を
算出するという解析手法です。&lt;/p&gt;
&lt;h3&gt;RNAseq でイントロン??&lt;/h3&gt;

&lt;p&gt;RNAseq においては totalRNA のうち 99%ともいわれる rRNA を除き mRNA のみを効率
よく Sequence する目的で、Poly(A)で成熟 mRNA を濃縮することがしばしば行われてい
ます。しかし、そのようなサンプルにおいても、実際の Sequence 結果ではイントロンに
あたる配列が読まれてくることが指摘されており、この原因は Poly(A)類似モチーフの存
在であると推察されています。&lt;/p&gt;
&lt;p&gt;結果の例
概日時間の検討ではとてもきれいな結果が得られています。関連遺伝子の unspliced(u) とspliced(s)を観察していくと、circadian timeの経過とともにu がs に変化していきます。
また、未分化細胞からの分化の方向性を見積もることも可能と報告されています。マウス
のオリゴデンドロサイト前駆体細胞がオリゴデンドロサイトへ分化する方向に Velocity を
持っていることが示されました。&lt;/p&gt;
&lt;p&gt;実践編
Developer の WEB(http://velocyto.org/)の tutorial を参考に手持ちの BAM で挑戦しま
す。R 用と Python 用とあるようですが、もちろん Python です。二部構成となっており、
前半はCommand lineでBAMファイルから.loomファイルを作成、後半では作成した.loom
ファイルから解析を行うとのことです。&lt;/p&gt;
&lt;p&gt;準備&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ conda install numpy scipy cython numba matplotlib scikit-learn h5py click
$ pip install velocyto
$ pip install scanpy
$ pip install -U scvelo
[/code]&lt;/p&gt;
&lt;p&gt;※pysam は Windows 環境下では仮想環境下であってもインストールできないそうです。
(https://qiita.com/chaoi/items/6d7702cd70430610f844)これに気付かず数日はまりまし
た。。
Genome annotation file のダウンロード
GENCODE のサイトから GTF ファイルをダウンロードし、適当な場所に保存して
gunzip。
実行
Sequence の手法ごとに Command を選べます。今回は smart-seq2 で行います。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
$ velocyto run-smartseq2 -e hogehoge /*.bam annotation.gtf
[/code]&lt;/p&gt;
&lt;p&gt;オプション
-o, --outputfolder ¶:出力ディレクトリを作成・指定
-e, --sampleid ¶:出力ファイル名
-m, --repmask ¶:リピート配列をマスクする場合
-t, --dtype ¶:出力ファイルのデータ型(default は unit32)
-d, --dump ¶
-v, --verbose¶
サンプルごとに BAM があることを想定して複数ファイルを*で受け付けてくれます。
BAM と GTF ファイルは必須です。なお、BAM の代わりに SAM を入れてもエラーは吐か
ないようです。これにより、hogehoge.loom ファイルが得られました。この中には、各分
子のスプライシング状態が格納されています。
※TOPHAT でアラインメントしたデータはそのままではうまく行かないようです。
→TopHat-Recondition で unmap のデータを拾ってくればいけるかもしれません。今回は
HISAT2 でアラインメントし直してから velocyto をかけ、改めて hogehoge.loom ファイル
を得ました。
描画
Scanpy と組み合わせて使用するために scvelo を用いました。&lt;/p&gt;
&lt;p&gt;[code lang="text"]
import scanpy as sc
import scvelo as scv
[/code]&lt;/p&gt;
&lt;p&gt;データ読み込み&lt;/p&gt;
&lt;p&gt;[code lang="text"]
adata = sc.read("hogehoge.loom", cache=True)
[/code]&lt;/p&gt;
&lt;p&gt;次元圧縮&lt;/p&gt;
&lt;p&gt;[code lang="text"]
sc.tl.pca(adata, n_comps=10)
[/code]&lt;/p&gt;
&lt;p&gt;速度計算&lt;/p&gt;
&lt;p&gt;[code lang="text"]
scv.pp.moments(adata)
scv.tl.velocity(adata)
[/code]&lt;/p&gt;
&lt;p&gt;描画&lt;/p&gt;
&lt;p&gt;[code lang="text"]
scv.pl.velocity_embedding(adata)
[/code]&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2019/03/picture1.png" alt="Picture1.png" width="359" height="351" class="alignnone size-full wp-image-506" /&gt;&lt;/p&gt;
&lt;p&gt;※それぞれの細胞における特定遺伝子の発現レベルを色で表したり、PCA 以外の次元圧縮
法を用いることもできます。この場合は tSNE のほうがきれいに見えるようです。パラメ
ータはたくさん用意されているので、各データセットで最適な条件を検討する必要がある
でしょう。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2019/03/picture2.png" alt="Picture2.png" width="415" height="361" class="alignnone size-full wp-image-507" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pythonoum.files.wordpress.com/2019/03/picture3.png" alt="Picture3.png" width="416" height="362" class="alignnone size-full wp-image-508" /&gt;&lt;/p&gt;
&lt;p&gt;https://www.nature.com/articles/s41586-018-0414-6
http://velocyto.org/velocyto.py/index.html
catway.jp/bioinformatics/qc/rmrepeat.html
https://github.com/theislab/scvelo&lt;/p&gt;</content><category term="tech_archive"></category><category term="bioinformatics"></category></entry><entry><title>NTT corevoチャレンジ: 話者の性別・年代識別</title><link href="http://oumpy.github.io%5Carticles/2019/04/voice_recognition.html" rel="alternate"></link><published>2019-04-14T00:00:00+09:00</published><updated>2019-04-14T00:00:00+09:00</updated><author><name>佐藤</name></author><id>tag:oumpy.github.io\articles,2019-04-14:/2019/04/voice_recognition.html</id><summary type="html"></summary><content type="html">&lt;p&gt;&lt;a href="https://signate.jp" target="_blank" rel="noopener noreferrer"&gt;signate&lt;/a&gt;内で開催されていた上記のコンペティションに参加してきました。以下試してみたこと、感想のまとめです。&lt;/p&gt;
&lt;p&gt;[slideshare id=138387330&amp;amp;doc=nttsignate-190327050047]&lt;/p&gt;
&lt;p&gt;思っていたよりも良い成績を残すことができて満足です。医学とはあまり関係なさそうですが、音声は脳波や心電図等と同じく時系列データなので、その扱いに慣れたことは良かったです。コンペなどに定期的に参加することで、機械学習を学ぶモチベーションになっているので、この調子で色々なコンペに参加していきたいと思います。&lt;/p&gt;
&lt;p&gt;2stage制なのになぜかstageごとにメダルをもらい、signate総合ランキング52位に入りました。ランキングはあんまり当てにならない気がします。&lt;/p&gt;</content><category term="tech_archive"></category><category term="deeplearning"></category></entry><entry><title>論文抄読で便利なサイト</title><link href="http://oumpy.github.io%5Carticles/2019/03/article_reading.html" rel="alternate"></link><published>2019-03-25T23:00:00+09:00</published><updated>2019-03-25T23:00:00+09:00</updated><author><name>柳澤</name></author><id>tag:oumpy.github.io\articles,2019-03-25:/2019/03/article_reading.html</id><summary type="html"></summary><content type="html">&lt;h1&gt;論文抄読で便利なサイト&lt;/h1&gt;
&lt;p&gt;英語論文を読むのにものすごいハードルがある人（＝僕）や英語見るだけでなんとなく気持ちがのらない人（＝僕）でも、論文を読まなければみたいな状況は訪れます。結局大事なことは英語で書いてあるし今後嫌でも読まなければいけないので、なんとか楽して読めないものか…ということで、いつも論文を読む時にどんなサイトを使っているかを一度書き起こしてみました。とりあえずハードルを下げることメインなので、「普通に読めるやろ」みたいな人はスルーでお願いします笑。5年の免疫内科の実習で論文の効率的な読み方を習って、もっと早く知ってればなあと思ったので、もし先生に「〇〇に関する論文読んできてねー」みたいなことを言われた時とかに参考にしてみてください。 &lt;a href="http://www.imed3.med.osaka-u.ac.jp/education/education01.html"&gt;大阪大学免疫内科のホームページ&lt;/a&gt;と被っていることも多いです。こちらも是非見てみてください。&lt;/p&gt;
&lt;h2&gt;論文を（ざっと）読む&lt;/h2&gt;
&lt;p&gt;とりあえずわからない単語が多すぎて全然読み進められない、いちいち単語を調べているとテンポが悪く全然頭に入らないみたいな時は、是非ライフサイエンス辞書の&lt;a href="https://lsd-project.jp/ja/service/etoj_v/index.html"&gt;EtoJ Vocabulary&lt;/a&gt;を使ってみてください。論文の英語の文章を丸ごと一本コピー&amp;amp;ペーストして青くなっている単語をクリックすると下にその単語の日本語訳がでます。オプション設定で「ライフサイエンス辞書 + ejdic」にして使うことが多いです。論文一本読むか迷うような場合はとりあえずアブストだけe to jに入れて読むと数分でなんとなく何が書いてあるのかわかるのでおすすめ。なんか変に訳されていることもおおいので、そういう時はガシガシググりまくってます。ググると日本語ページなんかもあったりして大抵なんとかなります。よく英語の構造がわかんない時は&lt;a href="https://translate.google.co.jp/?hl=ja"&gt;google 翻訳&lt;/a&gt;に文章ごと突っ込んで雰囲気を理解します。略語に関しては、正式名称が論文のどこにも見当たらない時は&lt;a href="http://allie.dbcls.jp/ja"&gt;略語検索Allie&lt;/a&gt;っていうサイトを使います（かなり便利）。成句がわからない時もググるのですが、アルク社の英辞郎の方がweblioよりうまくいく気がします。あと免内のHPにも書いてありますが&lt;a href="https://www.ncbi.nlm.nih.gov"&gt;NCBI&lt;/a&gt;では遺伝子とかタンパクのデータを調べるとバックグラウンドが理解でき、今読んでいる論文がどんなことをしたいかがよくわかることが多いです。（余談ですが予算が減らされたらしくNCBIのサイトのアップデートできないみたいな話を聞いたんですがどうなったんだろう） https://www.ononavi1717.jp/translation 個人的にはアブストを読んだ後、イントロを読もうとして途中で心が折れることが多いのでイントロは飛ばしてResultsに行くようにしてます。とりあえずResultsの題名だけ読んでFigureをみて全体像を掴む→よくわからんところがあったら本文を見ていくって感じにすると意外と早く大体の内容が把握できます。&lt;/p&gt;
&lt;h2&gt;論文と（とりあえず）身近になる&lt;/h2&gt;
&lt;p&gt;有名な雑誌（Impact Factorの高い雑誌）に関しては免内のサイトをみてください。 日本語でいいから論文に触れる。を目標にして行きたい。 Nature とNEJMは題名とアブストを日本語で読める。興味のある記事が一目でわかります。Natureには日本語のご利用ガイドまで。ありがたいです。 AASJはほぼ毎日日本語で面白い論文を解説してくれています。&lt;a href="http://aasj.jp/watch.html"&gt;AASJ&lt;/a&gt;おすすめ あと&lt;a href="http://first.lifesciencedb.jp"&gt;ライフサイエンス新着論文レビュー&lt;/a&gt;, &lt;a href="http://leading.lifesciencedb.jp"&gt;領域融合レビュー&lt;/a&gt;もお世話になってます。論文執筆者がその論文について解説してくれていたり、その領域について概説してくれています。（DBCLSのサービスの一つなのですが、他にも前述のAllie含め色々なサービスがあります。うまく使いこなせるようになりたい。使いこなしてるって人は教えてください。サイトは→ http://dbcls.rois.ac.jp/services ）&lt;/p&gt;
&lt;h2&gt;（有名どころの）論文を探す&lt;/h2&gt;
&lt;p&gt;せっかく読むんならたくさん引用されているすごい論文を読んだ方がかコスパがいい気がする！ 　ということでその領域の代表的な論文を読みたいって時、結構pubmedでは検索しにくかったりします。キーワード入れたけどこれはどれくらいすごい論文なのかわからないという時はISI web of knowledgeを使ってます。ある領域で被引用回数の多い順に論文を見ることができたりいろいろ便利な機能があります。おおきな括りで調べる時（autophagyとかsepsisとか）は最近3年くらいで、何個か検索ワードを並べて検索する時には最近10年分くらいで検索するとうまく行くことが多いです。被引用回数の多い順に検索結果を並べかえて上位のものからいくつかアブストを読んでみて、面白いなあと思ったものの論文を実際に読むっていう感じにしてます。。論文がどこにあるかわからなければ下の方に書いてあるpubmed idをコピーしてpubmedの検索のところにその番号を直接ペーストすると、お目当の論文が出てきます。阪大のwifiに繋がないと見れないですが、本当に役立ちます。あとはやっぱりgoogle scholarも使うことが多いです。&lt;/p&gt;</content><category term="tech_archive"></category><category term="paper"></category></entry></feed>