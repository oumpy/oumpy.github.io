<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>大阪大学医学部 Python会 (テスト用ページ) - 小川</title><link href="/previews/refs/heads/feature/category_pages/" rel="alternate"></link><link href="/previews/refs/heads/feature/category_pages/feeds/author.xiao-chuan.atom.xml" rel="self"></link><id>/previews/refs/heads/feature/category_pages/</id><updated>2019-12-23T00:00:00+09:00</updated><subtitle>Now is better than never.</subtitle><entry><title>バイオインフォマティクス技術者認定試験2019 解答速報？</title><link href="/previews/refs/heads/feature/category_pages/blog/2019/12/bioinfoexam2019_answer.html" rel="alternate"></link><published>2019-12-11T00:00:00+09:00</published><updated>2019-12-23T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2019-12-11:/previews/refs/heads/feature/category_pages/blog/2019/12/bioinfoexam2019_answer.html</id><summary type="html">&lt;p&gt;先日受験したバイオインフォマティクス認定試験をあらためて復習して、ついでに解答速報（全然速くない）と備忘録程度の解説を書きました。&lt;/p&gt;</summary><content type="html">&lt;p&gt;先日受験したバイオインフォマティクス認定試験をあらためて復習して、ついでに解答速報（全然速くない）と備忘録程度の解説を書きました。&lt;/p&gt;
&lt;h2&gt;模範解答 (?)&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;40&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;50&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;60&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;em&gt;4&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;(問題番号 = 縦列番号 + 横列番号)&lt;/p&gt;
&lt;p&gt;(2019.12.23 公式解答と全問一致でした。ただ問74は取消になりませんでした。)&lt;/p&gt;
&lt;h2&gt;解説&lt;/h2&gt;
&lt;h3&gt;バイオ（問1-20）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;問1：答4：はい&lt;/li&gt;
&lt;li&gt;問2：答4：核小体で合成されるのはrRNA。なおさらにリボソームの組み立ても行われる。&lt;/li&gt;
&lt;li&gt;問3：答3：G1→S→G2なのでG2で倍になっている。&lt;/li&gt;
&lt;li&gt;問4：答3：mRNAにポリAが付加されるのは真核生物。
  （注：教科書的には多分そうなのだが、原核生物やミトコンドリアのmRNAでも大抵はポリA鎖が見られるらしい。ただ持たない例もあり、二次的に失われたと考えられている。一方、真核生物でそのような例は知られていない。いずれにせよ一般に正しいとまでは言えないという意味で、選択肢3が正解となる。消去法的に解けるとはいえ、実は難問。）&lt;/li&gt;
&lt;li&gt;問5：答2：リボソームの小サブユニットは1種、大サブユニットは真核で3種、原核（真正および古細菌）で2種のrRNAを含む。よって合計4種ないし3種である。&lt;/li&gt;
&lt;li&gt;問6：答2：ジスルフィド結合でなくリン酸エステル結合。&lt;/li&gt;
&lt;li&gt;問7：答4：引っ掛けに近いが、グリシンの側鎖はHのみである。&lt;/li&gt;
&lt;li&gt;問8：答1：1回膜貫通で普通チャネルはできない。&lt;/li&gt;
&lt;li&gt;問9：答2：ユビキチンはタンパク質なので糖鎖修飾ではない。&lt;/li&gt;
&lt;li&gt;問10：答2：これもちょっとした引っ掛け。解糖系で酸素は消費しない。&lt;/li&gt;
&lt;li&gt;問11：答2：はい&lt;/li&gt;
&lt;li&gt;問12：答1：はい&lt;/li&gt;
&lt;li&gt;問13：答3：ミトコンドリアは母親由来である。&lt;/li&gt;
&lt;li&gt;問14：答3：グリセリンはアミノ酸ですらない。Gはグリシン。&lt;/li&gt;
&lt;li&gt;問15：答4：プロモータ領域にあるGC含量の高い領域はGCボックスという。LINEはレトロトランスポゾンの一種。問62でも登場。&lt;/li&gt;
&lt;li&gt;問16：答2：PCRで変化させるのは溶液組成ではなく温度である。&lt;/li&gt;
&lt;li&gt;問17：答4：メタボローム解析とはその名の通り、低分子化合物を主とする代謝産物の網羅的解析である。DNAの配列決定とは無関係。&lt;/li&gt;
&lt;li&gt;問18：答3：はい&lt;/li&gt;
&lt;li&gt;問19：答1：2,3,4は正しいので消去法で決めることができる。&lt;/li&gt;
&lt;li&gt;問20：答3：はい&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;インフォマティクス（問21-40）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;問21：答3：偶奇を決める演算を問われている。該当するのはXORしかない。&lt;/li&gt;
&lt;li&gt;問22：答4：GPGPUの省略前名称を与えてくれており、これが説明と矛盾することは知らなくてもわかる。GPGPUの本当の意味は名前の通りだが、特に現在のカジュアルな深層学習には必須の技術である（そのうち専用プロセッサが主流となれば死語になるかもしれない）。&lt;/li&gt;
&lt;li&gt;問23：答2：はい&lt;/li&gt;
&lt;li&gt;問24：答2：はい&lt;/li&gt;
&lt;li&gt;問25：答4：はい&lt;/li&gt;
&lt;li&gt;問26：答1：while中の条件&lt;code&gt;x&amp;lt;A[j]&lt;/code&gt;が満たされることは決してない。よって&lt;code&gt;i&lt;/code&gt;のループが&lt;code&gt;2&lt;/code&gt;から&lt;code&gt;n&lt;/code&gt;まで一巡するだけで終了するので、計算量は&lt;span class="math"&gt;\(\Theta(n)\)&lt;/span&gt;である。&lt;/li&gt;
&lt;li&gt;問27：答2：マージソートを知らなくても、&lt;span class="math"&gt;\(f(n) = n + 2f(n/2)\)&lt;/span&gt; をただ解くだけでよい。&lt;span class="math"&gt;\(f(n)=n\log_2 n\)&lt;/span&gt; はこの厳密解となるので、計算量オーダーは &lt;span class="math"&gt;\(\Theta(n\log n)\)&lt;/span&gt; である。&lt;/li&gt;
&lt;li&gt;問28：答1：20n個の中の上位n個に入る確率は1/20であり、n依存性は消滅する。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;問29：答4：順に辿ると、E &amp;lt; F &amp;lt; G &amp;lt; H になることがわかる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;問30：答3：&lt;span class="math"&gt;\({}_5C_{2}=10\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;問31：答1：(i, j)に達する経路は(i-1, j)からと(i, j-1)からの2パターン。AtCoderのD問題以上でも頻出。&lt;/li&gt;
&lt;li&gt;問32：答1：SQLはRDB用の言語。&lt;/li&gt;
&lt;li&gt;問33：答1：論理演算を注意深く考えれば良い。&lt;/li&gt;
&lt;li&gt;問34：答2：はい&lt;/li&gt;
&lt;li&gt;問35：答1：-1から2までfを積分すればよいので、原始関数を使うと選択肢1が自動的に出る。&lt;/li&gt;
&lt;li&gt;問36：答2：どちらも負の相関があるが、x-yグラフの方がばらついている、つまり相関係数の絶対値が小さい。回帰直線の傾きは関係ない（引っ掛けである）。&lt;/li&gt;
&lt;li&gt;問37：答3：勾配ベクトルは軌跡に接し、また等高線に直交する。向きが紛らわしいが、上り方向である。学習時の変分ベクトルは符号を変えて下り方向。&lt;/li&gt;
&lt;li&gt;問38：答4：はい&lt;/li&gt;
&lt;li&gt;問39：答1：隠れマルコフモデルがクラスタリングに使えるかわからなくても（実際僕は知らない）、2,3,4は明らかにクラスタリングに使えるアルゴリズムである。&lt;/li&gt;
&lt;li&gt;問40：答4：訓練用とテスト用が逆である。訓練用のデータはなるべく多く確保したい。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;バイオインフォマティクス（問41-80）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;問41：答3：菌種によらず共通に必要な機能は多く存在する。それらを1菌種にまとめるようなことをしてはいけない。&lt;/li&gt;
&lt;li&gt;問42：答4：はい&lt;/li&gt;
&lt;li&gt;問43：答4：書いているかどうかチェックするだけ。選択肢4のようなことは書いていない。&lt;/li&gt;
&lt;li&gt;問44：答3：4塩基分前後にずれたところ（右下と左上）にも直線状プロットがなければならない。&lt;/li&gt;
&lt;li&gt;問45：答2：はい&lt;/li&gt;
&lt;li&gt;問46：答2：四角が表すのは代謝反応を触媒する酵素である。&lt;/li&gt;
&lt;li&gt;問47：答3：はい&lt;/li&gt;
&lt;li&gt;問48：答1：一般に次世代シークエンサは繰り返し配列を苦手とする。たとえ反復配列から多くのRNAが転写されていても、そこから「ゲノム上の反復配列」を復元するのは困難と思われる。&lt;/li&gt;
&lt;li&gt;問49：答4：シュードノットとは、2度ヘアピンで折り返して元と同じ向きに進むような構造。そもそも2塩基だけで作れるようなものではない。&lt;/li&gt;
&lt;li&gt;問50：答1：PAMスコア行列の計算は、まず近縁なタンパク質間の置換回数から変異確率行列（=マルコフ過程遷移行列）を求める。1/100の割合で置換=1PAM。これを行列積で&lt;span class="math"&gt;\(n\)&lt;/span&gt;乗した遷移行列から、対数オッズスコアを計算したものがPAM&lt;span class="math"&gt;\(n\)&lt;/span&gt;である。「様々なアミノ酸の物理化学的指標を組み合わせて評価」したものではない。&lt;/li&gt;
&lt;li&gt;問51：答2：P(G)は縦および横に足し算するだけ。結果は一致する（一致しなければおかしい）。次にP(T|G)は0.05/0.2=0.25となる。&lt;/li&gt;
&lt;li&gt;問52：答3：1文字目Gの出現確率がP(G)=0.2、P(T|G)=0.25、P(C|T)=0.06/0.3=0.2なので、掛け合わせれば0.01が出る。&lt;/li&gt;
&lt;li&gt;問53：答3：疎水性アミノ酸は5番目のI（イソロイシン）と10番目のV（バリン）なので、それらが内部に埋もれるものを探して選べばよい。&lt;/li&gt;
&lt;li&gt;問54：答1：配列同士を比較すると、残基2と11、3と10のペアがそれぞれセットで変異していることがわかる。よってこれら同士が隣接するものを探して選べばよい。&lt;/li&gt;
&lt;li&gt;問55：答3：意味の異なる文字や数字が隣接していても、ルールが明確であればプログラムによる判読は容易である。&lt;/li&gt;
&lt;li&gt;問56：答4：はい（見ればわかる）&lt;/li&gt;
&lt;li&gt;問57：答4：図中にMainly Beta-Beta Barrelと書かれている。&lt;/li&gt;
&lt;li&gt;問58：答4：一概にそのようなことは言えない。一般に立体構造は一次配列よりもよく保存される傾向があり、遠い昔に共通起源を持つタンパク質が分化したものである可能性もよく検討する必要がある。&lt;/li&gt;
&lt;li&gt;問59：答2：1,3,4は少なくとも正しいと思われるので、消去法で。&lt;/li&gt;
&lt;li&gt;問60：答3：はい&lt;/li&gt;
&lt;li&gt;問61：答1：超優性だけでは高々ヘテロ結合になるだけであり、1箇所に何種類もの変異を保持することはできない。&lt;/li&gt;
&lt;li&gt;問62：答3：AluはSINEの一種で、レトロトランスポゾンでありながら有効な逆転写酵素を持たない。&lt;/li&gt;
&lt;li&gt;問63：答2：機能的制約から、特異な構造を持つタンパク質があってもおかしくない。&lt;/li&gt;
&lt;li&gt;問64：答1：連鎖不平衡と遺伝的連鎖は違う場合がある。&lt;/li&gt;
&lt;li&gt;問65：答1：はい&lt;/li&gt;
&lt;li&gt;問66：答3：新しい枝を追加する場所の選択肢が7通りあるので、15x7=105である。一般には(2n-5)!!となる。&lt;/li&gt;
&lt;li&gt;問67：答4：変異が有利に働く場合なので、中立説での説明とは異なる。&lt;/li&gt;
&lt;li&gt;問68：答4：はい（何もかも間違い）&lt;/li&gt;
&lt;li&gt;問69：答2：はい&lt;/li&gt;
&lt;li&gt;問70：答1：自身を活性化するAを抑えるので、「増えることによりさらに増える」ことはない。&lt;/li&gt;
&lt;li&gt;問71：答1：はい&lt;/li&gt;
&lt;li&gt;問72：答2：通常、DNAメチル化は遺伝子発現の抑制に働く。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;問73：答4：終止コドンはTAA、TAGと、TATでなくTGAである。正確に記憶していなくても、3つとも最初の2文字が共通ということはないこと、さらに2文字目と3文字目は両方プリンだったことなど、断片的な情報からも答えられるように作られた問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;問74：答4？：想定解答はおそらく4と思われるが、それも実は正しい模様（質量分析の情報が構造決定のために用いられる）。すると全選択肢が正しく、正答なしとなる。&lt;em&gt;全員正解扱いの可能性あり。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;問75：答2：菌の割合を求めて細菌数に掛ければ各菌ごとの菌密度が求められ、菌Xの密度は試料Aで&lt;span class="math"&gt;\(1.0\times 10^5\)&lt;/span&gt; 、試料Bで &lt;span class="math"&gt;\(0.75\times 10^5\)&lt;/span&gt; となる。&lt;/li&gt;
&lt;li&gt;問76：答3：知らなくても、エントロピーという言葉がShannonのヒントになっている。&lt;/li&gt;
&lt;li&gt;問77：答4：タンパク質間相互作用があってもそれが元の遺伝子にフィードバックされるとは限らないため、一般に完全グラフになるというのは誤り。&lt;/li&gt;
&lt;li&gt;問78：答4：タンパク質とmRNAの量比を問題にしているので、直接は無関係な事象である。&lt;/li&gt;
&lt;li&gt;問79：答3：ポリクローナル抗体での解析で有意差が無かったのだから、これはおかしい。&lt;/li&gt;
&lt;li&gt;問80：答3：ベイジアンネットワーク推定ではループ構造が現れることはない。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Blog"></category><category term="Bioinformatics"></category></entry><entry><title>機械学習のための最新GPU比較</title><link href="/previews/refs/heads/feature/category_pages/blog/2019/10/GPUs_for_ML.html" rel="alternate"></link><published>2019-10-07T00:00:00+09:00</published><updated>2019-10-07T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2019-10-07:/previews/refs/heads/feature/category_pages/blog/2019/10/GPUs_for_ML.html</id><summary type="html">&lt;p&gt;某所でGPU調達の必要があって、いまどきの事情を調べました。ゲームのことは知りません。&lt;/p&gt;</summary><content type="html">&lt;p&gt;某所でGPU調達の必要があって、いまどきの事情を調べました。
ゲームのことは知りません。&lt;/p&gt;
&lt;h2&gt;主要GPU一覧&lt;/h2&gt;
&lt;p&gt;NVidia製Volta/Turing世代ハイエンドデスクトップ／ワークステーション用の主要GPUラインアップ。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;コア&lt;/th&gt;
&lt;th&gt;VRAM&lt;/th&gt;
&lt;th&gt;最大精度&lt;/th&gt;
&lt;th&gt;TDP&lt;/th&gt;
&lt;th&gt;放熱&lt;/th&gt;
&lt;th&gt;価格(税込)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 2080Ti&lt;/td&gt;
&lt;td&gt;Turing (TU102)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;11GB&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;単精度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;250W&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;外排気&lt;/td&gt;
&lt;td&gt;14万円〜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Titan RTX&lt;/td&gt;
&lt;td&gt;Turing (TU102)&lt;/td&gt;
&lt;td&gt;24GB&lt;/td&gt;
&lt;td&gt;単精度&lt;/td&gt;
&lt;td&gt;&lt;em&gt;280W&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;内排気&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;27.6万円〜※&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quadro RTX 6000&lt;/td&gt;
&lt;td&gt;Turing (TU102)&lt;/td&gt;
&lt;td&gt;24GB&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;倍精度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;260W&lt;/td&gt;
&lt;td&gt;外排気&lt;/td&gt;
&lt;td&gt;&lt;em&gt;41.5万円〜&lt;/em&gt;※&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quadro RTX 8000&lt;/td&gt;
&lt;td&gt;Turing (TU102)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;48GB&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;倍精度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;260W&lt;/td&gt;
&lt;td&gt;外排気&lt;/td&gt;
&lt;td&gt;60万円〜※&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Titan V&lt;/td&gt;
&lt;td&gt;Volta (V102?)&lt;/td&gt;
&lt;td&gt;&lt;em&gt;12GB&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;倍精度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;250W&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;外排気&lt;/td&gt;
&lt;td&gt;&lt;em&gt;40万円〜&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tesla V100 32GB (参考)&lt;/td&gt;
&lt;td&gt;Volta (V100)&lt;/td&gt;
&lt;td&gt;32GB&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;倍精度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;250W&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;外排気&lt;/td&gt;
&lt;td&gt;&lt;em&gt;99万円〜&lt;/em&gt;※&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;（&lt;strong&gt;すごい&lt;/strong&gt;。&lt;em&gt;いまいち&lt;/em&gt;。※はアカデミック価格。価格は2019年10月初頭調べ。）&lt;/p&gt;
&lt;h2&gt;ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目を引くのはTuring世代ワークステーション用GPUの&lt;strong&gt;VRAM大容量化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Titan RTXでも24GB、Quadro RTX 8000に至っては&lt;strong&gt;泣く子も黙る48GB&lt;/strong&gt;。
サーバ用のTesla V100も凌ぐ。&lt;/li&gt;
&lt;li&gt;Titan RTXのみ内排気のため、多数枚の搭載には水冷システムが必要。&lt;/li&gt;
&lt;li&gt;Quadro 6000がやや割高なことを除けば、Turingコア製品の&lt;strong&gt;VRAM容量あたりの価格は概ね一定&lt;/strong&gt;なのが面白い。&lt;/li&gt;
&lt;li&gt;大きなネットワークを学習したい時など、GPU1基のメモリ容量はしばしば演算性能以上に重要。
例えばGPU予算が60万の場合、2080Tiを4枚かTitan RTXを2枚かQuadro 8000を1枚か、は用途次第。&lt;/li&gt;
&lt;li&gt;どれもTensorCore搭載。
FP16を使うように調整してやらないと本来の性能は出ない。&lt;/li&gt;
&lt;li&gt;倍精度演算機能は、実際のところ物理シミュレーションでもしない限り、あっても使わないので関係ない。遅いし。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;演算性能を妥協すれば、大容量VRAMの上位GPUにも実は手が出しやすくなっています。
用途に合わせて選びましょう。
選べる余地があるのはいいことですね。&lt;/p&gt;
&lt;p&gt;おしまい。&lt;/p&gt;</content><category term="Blog"></category><category term="Machine Learning"></category></entry><entry><title>はじめての競プロ：入力アンチョコメモ</title><link href="/previews/refs/heads/feature/category_pages/blog/2019/04/competition_input.html" rel="alternate"></link><published>2019-04-27T00:00:00+09:00</published><updated>2019-04-29T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2019-04-27:/previews/refs/heads/feature/category_pages/blog/2019/04/competition_input.html</id><summary type="html">&lt;p&gt;AtCoderのABCで、これさえ覚えれば大丈夫！な入力のパターンについて解説します。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;入力のパターン&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python会競プロ部（？）へようこそ！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;はじめての方には&lt;strong&gt;入力&lt;/strong&gt;が最初の鬼門だと思います。&lt;br&gt;
&lt;a href="https://atcoder.jp"&gt;AtCoder&lt;/a&gt; のABCで、&lt;strong&gt;これさえ覚えれば大丈夫！&lt;/strong&gt;な入力パターンは以下の通り。
最初は説明の意味がわからなくても、とりあえずコピペすれば動きます（何）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;言語&lt;/strong&gt;は &lt;code&gt;Python3 (3.4.3)&lt;/code&gt; (または &lt;code&gt;PyPy3 (2.4.0)&lt;/code&gt;) を選択してね。&lt;/p&gt;
&lt;h3&gt;文字列を入力&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;整数ひとつを入力&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;int()&lt;/code&gt; が、文字列を整数 (integer) に変換する&lt;strong&gt;呪文&lt;/strong&gt;です。&lt;/p&gt;
&lt;h3&gt;整数2つ〜を一行（空白区切り）で入力&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;まず &lt;code&gt;split()&lt;/code&gt; で文字列を分割。
次に &lt;code&gt;map()&lt;/code&gt; で &lt;code&gt;int()&lt;/code&gt; をそれぞれに適用しています。&lt;/p&gt;
&lt;h3&gt;多数の整数を一行で入力&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;x&lt;/code&gt; は0番目から始まる配列になる。n番目は &lt;code&gt;x[n]&lt;/code&gt; で参照します。&lt;/p&gt;
&lt;h2&gt;使用例&lt;/h2&gt;
&lt;h3&gt;問題1&lt;/h3&gt;
&lt;p&gt;整数A, Bが1行 (空白区切り) で&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;A B&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;のように与えられる。和 &lt;code&gt;A+B&lt;/code&gt; を出力せよ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;問題2&lt;/h3&gt;
&lt;p&gt;1行目に自然数 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;K&lt;/code&gt; (&lt;code&gt;N&amp;gt;=K&lt;/code&gt;)、2行目にN個の整数 &lt;code&gt;x1,..,xN&lt;/code&gt; が、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;N K&lt;/span&gt;
&lt;span class="err"&gt;x1 x2 x3 ... xN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;のように与えられる。
このうちK番目の整数xKを出力せよ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;K&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配列が0番目からであることに注意。
&lt;code&gt;N&lt;/code&gt; は実は使わなくてよい。&lt;br&gt;
ちょっと難しいパターンだが、B問題ではちょくちょく出てくる。&lt;/p&gt;
&lt;h3&gt;問題3&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;(このパターンはたぶんC問題以降のみ。)&lt;/s&gt; B問題にも時々出ます。&lt;br&gt;
1行目に自然数 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;K&lt;/code&gt; (&lt;code&gt;N&amp;gt;=K&lt;/code&gt;)、2行目〜N+1行目に &lt;code&gt;N&lt;/code&gt;個の整数 &lt;code&gt;x1,..,xN&lt;/code&gt; が、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;N K&lt;/span&gt;
&lt;span class="err"&gt;x1&lt;/span&gt;
&lt;span class="err"&gt;x2&lt;/span&gt;
&lt;span class="err"&gt;x3&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;xN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;のように与えられる。
このうち &lt;code&gt;K&lt;/code&gt; 番目の整数 &lt;code&gt;xK&lt;/code&gt; を出力せよ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;K&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ループとの組み合わせ。&lt;s&gt;C問題&lt;/s&gt; B問題以降でときどき必要。&lt;/p&gt;
&lt;p&gt;以上です。おしまい。&lt;/p&gt;</content><category term="Blog"></category><category term="競技プログラミング"></category></entry><entry><title>阪医Python会特製 RNA-seq pipeline ver. 1.0 リリース</title><link href="/previews/refs/heads/feature/category_pages/blog/2019/03/original_rnaseq_pipeline.html" rel="alternate"></link><published>2019-03-19T00:00:00+09:00</published><updated>2019-03-19T00:00:00+09:00</updated><author><name>菅波</name></author><id>tag:None,2019-03-19:/previews/refs/heads/feature/category_pages/blog/2019/03/original_rnaseq_pipeline.html</id><summary type="html"></summary><content type="html">&lt;p&gt;阪医Python会のbioinformaticsチームの一つの成果として、RNA-seqのパイプラインのv1.0がリリースとなったので記事とさせていただきます。SRR idから遺伝子✕サンプルのテーブルにするまでには意外に大変ですが、それをすべて自動化しました。ダウンロード、詳細等は以下にあります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/yyoshiaki/auto_counttable_maker"&gt;https://github.com/yyoshiaki/auto_counttable_maker&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;なお、以下のイラストはikraのアイコンとなっています。&lt;/p&gt;
&lt;p&gt;&lt;img src="/previews/refs/heads/feature/category_pages/blog/2019/03/images/original_rnaseq_pipeline_figs/ikra.png" width="250px"&gt; &lt;/p&gt;
&lt;h2&gt;特徴&lt;/h2&gt;
&lt;p&gt;今回、自分たちの使いやすさを考えてツールの設計を行いました。他サンプルのファイル名の管理など、煩わしいところをすべて自動化することで、ミスも減らせると思います。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;準備するのは簡単なCSVファイル（テーブルだけ）で、極力パラメーターを減らした。&lt;/li&gt;
&lt;li&gt;すべてdocker上で動くため、ツールを各々インストールする必要がないし、バージョンに苦しむこともない。&lt;/li&gt;
&lt;li&gt;udockerにも対応しているため、ユーザー権限しかないサーバー上でも実行可能。&lt;/li&gt;
&lt;li&gt;outputは&lt;a href="http://bioinformatics.sdstate.edu/idep/"&gt;idep&lt;/a&gt;に対応。&lt;/li&gt;
&lt;li&gt;もちろんマルチスレッド対応。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;必要なテーブルは&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;SRR or fastq&lt;/th&gt;
&lt;th&gt;Layout&lt;/th&gt;
&lt;th&gt;condition1&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Treg_LN_1&lt;/td&gt;
&lt;td&gt;SRR5385247&lt;/td&gt;
&lt;td&gt;SE&lt;/td&gt;
&lt;td&gt;Treg&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Treg_LN_2&lt;/td&gt;
&lt;td&gt;SRR5385248&lt;/td&gt;
&lt;td&gt;SE&lt;/td&gt;
&lt;td&gt;Treg&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;のような形式で、前3列が必須です。簡単ですね！データの集め方は、論文についているaccession number等をたどるのでもいいし、新しくなって爆速になった&lt;a href="http://sra.dbcls.jp/"&gt;DDBJ Search&lt;/a&gt;もおすすめ。&lt;/p&gt;
&lt;p&gt;コマンドはオプションが指定でき、リード数を100000に絞ったテストモードやマルチプロセスにも対応。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;Usage&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MakeCountTable_Illumina_trimgalore_SRR&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;experiment_table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spiece&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;--test, --help, --without-docker, --udocker&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;--threads [VALUE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="n"&gt;reference&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;human&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mouse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nl"&gt;Options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;--test test mode(MAX_SPOT_ID=100000).(dafault : False)&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--udocker&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--without-docker&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--threads&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--help Show usage.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;なお、自前のfastq filesからの実行はv1.1で載せようと思っています。また、出力はscaled TPMを採用。(Soneson, C., Love, M. I. &amp;amp; Robinson, M. D. Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research 4, 1521 (2015).)。&lt;/p&gt;
&lt;h2&gt;pipelineの構成&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;fasterq-dump : シーケンスデータの取得&lt;/li&gt;
&lt;li&gt;fastqc : QC&lt;/li&gt;
&lt;li&gt;trim-galore : トリミング&lt;/li&gt;
&lt;li&gt;salmon : RNA定量&lt;/li&gt;
&lt;li&gt;multiqc : QCログの回収、可視化&lt;/li&gt;
&lt;li&gt;tximport : 遺伝子テーブルの生成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;となっています。各ツールの説明は省きますが、今時のツールの選定になっていると思います。&lt;/p&gt;
&lt;h2&gt;idep&lt;/h2&gt;
&lt;p&gt;本ツールは&lt;a href="http://bioinformatics.sdstate.edu/idep/"&gt;idep&lt;/a&gt;を意識した設計になっています。idepはRNA-seqの解析をinteractiveに行えるプラットフォームで、Differential expressed genes(DEGs)の検出だけではなく、遺伝子、サンプルのクラスタリング、パスウェイ解析、可視化などが行えます。idepについては以下がとても参考になります。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kazumaxneo.hatenablog.com/entry/2018/12/29/153838"&gt;macでインフォマティクス : インタラクティブなRNA seq解析webアプリケーション iDEP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="2" src="/previews/refs/heads/feature/category_pages/blog/2019/03/images/original_rnaseq_pipeline_figs/screenshot-from-2019-03-19-23-14-31.png"&gt;&lt;/p&gt;
&lt;h2&gt;githubを用いたチーム開発&lt;/h2&gt;
&lt;p&gt;今回、githubを用いてチーム開発を行いました。githubはエンジニアの間では当たり前のツールで、チームでのソフト開発によく用いられます。bioinformatics界隈でチーム開発を経験できることは意外に少なく、非常にいい経験になりました。&lt;/p&gt;
&lt;p&gt;&lt;img alt="3" src="/previews/refs/heads/feature/category_pages/blog/2019/03/images/original_rnaseq_pipeline_figs/ikra_git.png"&gt;&lt;/p&gt;
&lt;p&gt;雑多にはなりましたが、阪医Python会bioinformaticsチームの成果をアナウンスさせていただきました。完成までには3ヶ月ほどを要し、各人のアイデアや努力が詰まっております。今後もどんどん開発を進めていこうと思います。また、皆様のissue, Pull Requestもお待ちしております。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Enjoy bioinformatics life!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="4" src="/previews/refs/heads/feature/category_pages/blog/2019/03/images/original_rnaseq_pipeline_figs/ios-e381aee794bbe5838f.jpg"&gt;&lt;/p&gt;</content><category term="Blog"></category><category term="Bioinformatics"></category></entry><entry><title>JuliaとPythonと競技プログラミング</title><link href="/previews/refs/heads/feature/category_pages/blog/2019/03/julia_python_competition.html" rel="alternate"></link><published>2019-03-16T00:00:00+09:00</published><updated>2019-03-16T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2019-03-16:/previews/refs/heads/feature/category_pages/blog/2019/03/julia_python_competition.html</id><summary type="html"></summary><content type="html">&lt;p&gt;最近友人と話していてJulia (&lt;a href="https://julialang.org"&gt;https://julialang.org&lt;/a&gt;)が話題になったことがあったので、少しだけ調べて試してみた話。&lt;/p&gt;
&lt;h2&gt;Juliaってなに？&lt;/h2&gt;
&lt;p&gt;Pythonのような動的型付けのスクリプト言語です。実行時にコンパイルを行いC言語にも迫る実行速度、科学技術系の数値計算もどんと来い、という触れ込みで、人気上昇中らしいです。Pythonを含む他言語のライブラリを読み込む仕組みを備えているのもすごいところ。&lt;br&gt;
&lt;s&gt;ただ、コードの見た目が激しくMatlab風味で思わず目を背けたくなります。&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;AtCoderでのJulia&lt;/h2&gt;
&lt;p&gt;ご多分に漏れず、実行速度に惹かれました。半年ほど前から参加している競技プログラミングサイト&lt;strong&gt;AtCoder&lt;/strong&gt; (&lt;a href="https://atcoder.jp"&gt;https://atcoder.jp&lt;/a&gt;)で、常用しているPython（← Python会だからね！）で実行時間切れ、C/C++に書き換えると正答、という経験を何度かしてきたので。&lt;/p&gt;
&lt;p&gt;そういうわけで、ここでは最近の&lt;strong&gt;第121回 AtCoder Beginner Contest (ABC121)&lt;/strong&gt; (&lt;a href="https://atcoder.jp/contests/abc121/"&gt;https://atcoder.jp/contests/abc121/&lt;/a&gt;)の問題で、Juliaのパフォーマンスを実際に見てみます。&lt;br&gt;
（言語知識0から数十分調べて書いたコードのため、動きはするが思わぬところで非効率、ということはあるかもしれません。）&lt;/p&gt;
&lt;h3&gt;AtCoder Beginner Contest 121 問題A "White Cells"&lt;/h3&gt;
&lt;p&gt;（問題はこちら → &lt;a href="https://atcoder.jp/contests/abc121/tasks/abc121_a"&gt;https://atcoder.jp/contests/abc121/tasks/abc121_a&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;入力値4個を読み込んで簡単な演算結果を返すだけの問題です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;# ABC121-A &amp;quot;White Cells&amp;quot; in Julia&lt;/span&gt;
&lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所要時間が入力にほぼ依存しない問題ですが、、各言語でのAtCoder上実行結果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;言語&lt;/th&gt;
&lt;th align="right"&gt;実行時間&lt;/th&gt;
&lt;th align="right"&gt;消費メモリ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;&lt;strong&gt;Julia&lt;/strong&gt;&lt;/td&gt;
&lt;td align="right"&gt;&lt;strong&gt;360 ms&lt;/strong&gt;&lt;/td&gt;
&lt;td align="right"&gt;&lt;strong&gt;110 MB&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;PyPy3&lt;/td&gt;
&lt;td align="right"&gt;180 ms&lt;/td&gt;
&lt;td align="right"&gt;40 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;Python3&lt;/td&gt;
&lt;td align="right"&gt;17 ms&lt;/td&gt;
&lt;td align="right"&gt;3 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;C++&lt;/td&gt;
&lt;td align="right"&gt;1 ms&lt;/td&gt;
&lt;td align="right"&gt;256 kB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++にもPythonにも、実行時間と消費メモリ双方で惨敗。 &lt;br&gt;
おそらくですが、&lt;strong&gt;実行ごとにまずコンパイルを行う&lt;/strong&gt;ので、簡単な問題だとそれが相対的に巨大なオーバーヘッドになってしまうようです。&lt;br&gt;
Pythonの半コンパイラ型実装であるPyPyはJuliaの半分程度でした。&lt;/p&gt;
&lt;!---

### AtCoder Beginner Contest 121-B

問題はこちら → &lt;https://atcoder.jp/contests/abc121/tasks/abc121_b&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;# ABC121-B by Julia&lt;/span&gt;
&lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="kp"&gt;in&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;



---&gt;

&lt;h3&gt;AtCoder Beginner Contest 121 問題C "Energy Drink Collector"&lt;/h3&gt;
&lt;p&gt;（問題はこちら → &lt;a href="https://atcoder.jp/contests/abc121/tasks/abc121_c"&gt;https://atcoder.jp/contests/abc121/tasks/abc121_c&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;読み込んだ値の列をソートして、条件判定をしながら順番に足し上げていく問題。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;# ABC121-C &amp;quot;Energy Drink Collector&amp;quot; in Julia&lt;/span&gt;
&lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="kp"&gt;in&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sortrows&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="kp"&gt;in&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;なんと、テスト16個中15個でタイムアウト（2000ms以上）。。。&lt;/p&gt;
&lt;p&gt;Pythonのコードはこちら：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# ABC121-C &amp;quot;Energy Drink Collector&amp;quot; in Python3&lt;/span&gt;
&lt;span class="n"&gt;inpl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inpl&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;
    &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;こちらは最大466msでクリア（同一コードのPyPy3では733ms）。ここで134msのテストもJuliaではタイムアウト。悲しい。&lt;/p&gt;
&lt;p&gt;今回Juliaでタイムアウトになったのは、言語の特性や正しいコーディングの仕方を知らないから、という可能性は高いです。ただ実際にこの問題でJuliaを使って提出されている答案は、最速クリアのものでも1724ms（そもそもJuliaでの提出数自体が少ないですが）。やはり上の安直なPythonコードが圧勝しています。&lt;/p&gt;
&lt;h2&gt;Juliaは競技プログラミングに向かない？&lt;/h2&gt;
&lt;p&gt;Juliaの実行速度が速いこと自体は（今回検証していませんが、きっと）本当なんだと思います。しかしそれは時間のかかる複雑・大規模な処理の場合であって、競技プログラミングのような高々2-3秒の計算にはコンパイルのオーバーヘッドがやはり大きいのかな、という印象です。  &lt;/p&gt;
&lt;p&gt;AtCoderなどでは、C++などのあからさまなコンパイル型言語はコンパイル時間が実行時間に算入されず、一方でJuliaに対しては算入されます。やや理不尽な感じはしなくもないけれど、このルール下でJuliaの高速性能を生かすことは（あくまでAtCoderのような短時間型競技プログラミングの話ですが）なかなか難しそう。残念ながら、普通にやるとPythonよりもずっと遅い。  &lt;/p&gt;
&lt;p&gt;なので、当面の競技プログラミング用言語は&lt;strong&gt;やっぱりPython&lt;/strong&gt;（とC/C++）、と個人的には結論づけたところです。おしまい。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt; History &amp;gt;&lt;/strong&gt;&lt;br&gt;
2019.03.21 ver1.0&lt;br&gt;
2019.03.21 ver1.1 微修正、PyPy3の成績を追記&lt;br&gt;
2019.03.21 ver1.2 JuliaとPythonのコードが対応するよう修正&lt;/p&gt;</content><category term="Blog"></category><category term="競技プログラミング"></category></entry><entry><title>Pythonの変数と代入について</title><link href="/previews/refs/heads/feature/category_pages/blog/2018/12/python_value.html" rel="alternate"></link><published>2018-12-20T00:00:00+09:00</published><updated>2018-12-20T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2018-12-20:/previews/refs/heads/feature/category_pages/blog/2018/12/python_value.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Pythonの変数、ふだん何気なく使っていますが、やっていることは実は結構複雑です。主にC/C++と対比しつつ簡単にまとめてみます。&lt;/p&gt;
&lt;p&gt;実際のところ、よく知らなくてもあまり影響がない場合が殆どです。が、複雑な操作を行ったり何か変数の挙動が不審な場合などは、思い出してみるのもよさそうです。&lt;/p&gt;
&lt;h2&gt;変数は参照である&lt;/h2&gt;
&lt;p&gt;一言でいえば表題の通り。
Pythonでの&lt;strong&gt;変数への代入とは、変数の参照するメモリ（インスタンス）を切り替えること&lt;/strong&gt;であり、&lt;strong&gt;メモリの内容を書き換えることではない&lt;/strong&gt;。これが多くの言語（C/C++など）と大きく違うところです。&lt;/p&gt;
&lt;h2&gt;変数の代入(1)&lt;/h2&gt;
&lt;p&gt;例えばこんなコード。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C++で書き換えると、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;なのか？？
（#include\とかint main(void){...}とかは全部省略。）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;実は違う&lt;/strong&gt;のです。&lt;br&gt;
C++の方では&lt;code&gt;a&lt;/code&gt;で表されるメモリ領域を一つ確保し、そこにまず&lt;code&gt;0&lt;/code&gt;をセット、次に&lt;code&gt;1&lt;/code&gt;を、&lt;strong&gt;同じメモリ領域を書き換えて&lt;/strong&gt;セットしています。  &lt;/p&gt;
&lt;p&gt;Pythonの方はそうではありません。まず&lt;code&gt;0&lt;/code&gt;の値を持つメモリ領域を確保し、&lt;strong&gt;変数&lt;code&gt;a&lt;/code&gt;がそこを指すように&lt;/strong&gt;します。次に&lt;code&gt;1&lt;/code&gt;の値を持つ&lt;strong&gt;別のメモリ領域を確保&lt;/strong&gt;し、変数&lt;code&gt;a&lt;/code&gt;がそこを指すように切り替えます。&lt;/p&gt;
&lt;p&gt;C++で無理矢理それっぽいものを書くと、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 1を出力&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;のようになります。&lt;br&gt;
（C++に参照定数はあるが参照変数がないため、ポインタで書いた。）&lt;/p&gt;
&lt;p&gt;実はこのC++コード、2行目で確保した&lt;code&gt;int(0)&lt;/code&gt;メモリを3行目の&lt;code&gt;int(1)&lt;/code&gt;代入時に&lt;strong&gt;放棄&lt;/strong&gt;していて、&lt;strong&gt;メモリリーク&lt;/strong&gt;が起こっています。C++では、これを処理（メモリ解放）するためのコードを本当は書き加えないといけません。&lt;br&gt;
しかし、Pythonではそれを&lt;strong&gt;ガベージコレクタ&lt;/strong&gt;という仕組みが&lt;strong&gt;勝手に代行&lt;/strong&gt;してくれます。逆にこれがないと、Pythonではメモリリークが頻繁に起こって大変なことになります。&lt;/p&gt;
&lt;h2&gt;変数の代入(2)&lt;/h2&gt;
&lt;p&gt;問題です。次のコードは何を出力するでしょうか。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 何が出る？&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;答えは「&lt;code&gt;0&lt;/code&gt;」&lt;/strong&gt;です。&lt;br&gt;
C++で書いた似たようなコード、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// C++&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 出力は「0」&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;も結果は同じなのですが、内部動作は全く異なります。&lt;strong&gt;Pythonでの変数代入は参照の切り替え&lt;/strong&gt;であることがやはりポイントです。&lt;/p&gt;
&lt;p&gt;一方で、過程は違えどPythonもC++も結果は変わりません。&lt;strong&gt;気にしなくても大抵はうまくいく&lt;/strong&gt;、というのも大事なところです(笑)。&lt;/p&gt;
&lt;h2&gt;関数引数はすべて参照渡し&lt;/h2&gt;
&lt;p&gt;「変数が全て参照」であることから、関数引数もまた&lt;strong&gt;参照渡し&lt;/strong&gt;となります。C/C++のデフォルトである&lt;strong&gt;値渡し&lt;/strong&gt;と異なり、メモリのコピーなどは行われません。&lt;/p&gt;
&lt;p&gt;では再び問題。次のコードは何を出力するでしょう？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# ここまで。このprint()は何を出力するか？0？1？&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;「参照渡し」を知っている人ほど、「1」と答えたくなりそうですが、、  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答えは「0」&lt;/strong&gt;です。何故か？&lt;br&gt;
&lt;code&gt;func(a)&lt;/code&gt;を呼び出した時点では、&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の指すメモリは同じ&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;ですが、&lt;code&gt;x = 1&lt;/code&gt;で&lt;code&gt;x&lt;/code&gt;の指すメモリは&lt;strong&gt;別に確保された&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;に切り替わります。&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;および、&lt;code&gt;a&lt;/code&gt;の指す&lt;code&gt;0&lt;/code&gt;には何の変化も無い&lt;/strong&gt;のです。このあたりは前項の問題とほとんど同じです。&lt;/p&gt;
&lt;h2&gt;「変数への代入」ではない場合&lt;/h2&gt;
&lt;p&gt;例えばこんなとき。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 出力は[2,1]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3行目で&lt;code&gt;b&lt;/code&gt;と&lt;code&gt;a&lt;/code&gt;は同じリストを参照するようになります。4行目では、そのリスト（これも参照の列みたいなもの）の最初の成分を、&lt;code&gt;0&lt;/code&gt;でなく&lt;code&gt;2&lt;/code&gt;のメモリを参照するように切り替えます。全体として見れば&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;が同じリストを参照していることに変わりはないので、この変更は&lt;code&gt;b&lt;/code&gt;にも反映されています。&lt;/p&gt;
&lt;p&gt;これは、前項の関数引数で若干の問題を引き起こします。&lt;br&gt;
次のコード、前項で見たものにそっくりですが、、、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Python3&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;前項とは違い、この出力は「&lt;code&gt;1&lt;/code&gt;」&lt;/strong&gt;です。&lt;br&gt;
関数が呼び出されると&lt;strong&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の指すリストは一貫して同じ&lt;/strong&gt;で、その一部が書き換えられるからです。これは&lt;strong&gt;リストでなくnumpy配列の場合もほぼ同じ&lt;/strong&gt;です。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;以上見てきたように、Pythonの変数は全て参照、関数引数は全て参照渡しです。これらが組み合わさると、結果的に全てを値渡しにした場合（C/C++）と殆ど違いが見えなくなり、あまり意識することなくプログラムを書けるようになっています。&lt;/p&gt;
&lt;p&gt;しかし、リストや配列（や、もっと複雑なクラスオブジェクトなど）のように部分的に書き換え可能なものを扱う場合などには、この違いはかなり重要になってきます。怪しいと思ったら、各変数が何を参照しているか、互いに同じか違うかなどを、その都度考えてみてください。&lt;/p&gt;
&lt;p&gt;ひとまず今回はここまで。おしまい。
※画像は&lt;a href="https://www.python.org/"&gt;公式&lt;/a&gt;のものです。&lt;/p&gt;</content><category term="Blog"></category><category term="Python"></category></entry><entry><title>PythonとKerasでどうぶつしょうぎ</title><link href="/previews/refs/heads/feature/category_pages/blog/2018/12/animalshogi.html" rel="alternate"></link><published>2018-12-06T00:00:00+09:00</published><updated>2018-12-06T00:00:00+09:00</updated><author><name>小川</name></author><id>tag:None,2018-12-06:/previews/refs/heads/feature/category_pages/blog/2018/12/animalshogi.html</id><summary type="html"></summary><content type="html">&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「どうぶつしょうぎ」&lt;/strong&gt; というゲームをご存知でしょうか。（&lt;a href="https://ja.wikipedia.org/wiki/どうぶつしょうぎ"&gt;wikipediaの解説&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;普及・教育用のミニ将棋として考案されたもので、本将棋が盤9x9、駒8種のところを盤3x4、駒4種までコンパクトにしたものです。&lt;br&gt;
駒の名前もひよこ（歩）、ぞう（弱い角）、きりん（弱い飛車）、ライオン（玉）、にわとり（ひよこの成り駒＝と金）、のように、かわいいです。&lt;br&gt;
駒に描かれているイラストも、大変、かわいいです。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="/previews/refs/heads/feature/category_pages/blog/2018/12/images/animalshogi_figs/1024px-doubutsu-shogi.jpg"&gt;&lt;/p&gt;
&lt;p&gt;ゲーム空間の規模がそこそこ小さいため、すでに随分前に&lt;a href="https://www.tanaka.ecc.u-tokyo.ac.jp/ktanaka/dobutsushogi/"&gt;完全解析もされています&lt;/a&gt;。
双方最善を尽くすと78手まで後手勝ち、だそうです。&lt;/p&gt;
&lt;p&gt;今回は、&lt;a href="https://www.nature.com/articles/nature16961"&gt;AlphaGo&lt;/a&gt;
(&lt;a href="https://www.nature.com/articles/nature24270"&gt;Zero&lt;/a&gt;)
を部分的に真似した深層強化学習で、PythonとKeras（初心者向けの深層学習フレームワーク）を使い、&lt;strong&gt;どうぶつしょうぎをプレイするプログラム&lt;/strong&gt; を作ってみました。&lt;br&gt;
ひとまず先読みは無しで、目の前の局面に対して直感的に手を選び、そこそこ強いもの、を目指します。&lt;/p&gt;
&lt;p&gt;今更な話題で研究としての価値はほぼないと思いますが、ただ論文を読むだけよりも実際に手を動かしてみると、色々とわかることもあるものです。  （たぶん。）&lt;/p&gt;
&lt;h2&gt;つくりかた概要&lt;/h2&gt;
&lt;p&gt;「プレイするプログラム」と大層なことを書きましたが、核心部分は「与えられた局面に対して次の指し手を返す」、これだけです。&lt;br&gt;
この部分を、深層ニューラルネットワーク「だけ」で作ります。  &lt;/p&gt;
&lt;p&gt;実はこれ、&lt;strong&gt;画像カテゴリ認識と殆ど同じ&lt;/strong&gt; です。
例えば手書き数字認識と対比すると、数字画像の代わりに局面データ、0-9の代わりに何番目の指し手か、が対応します。&lt;br&gt;
入力として局面を与え、各指し手のスコア（指す確率）を出力する、順伝搬型の深層ネットワークを作ればいいわけです。&lt;/p&gt;
&lt;h2&gt;ネットワーク構成&lt;/h2&gt;
&lt;h3&gt;入力：盤面と持駒の表現&lt;/h3&gt;
&lt;p&gt;どうぶつしょうぎの盤面は3x4。各マスを考えるとそれぞれ11通りの状態がありえます。
（駒が成駒含めて5種類、自分と相手の駒があり、空白マスとあわせて5x2+1=11です。）&lt;br&gt;
なので、盤面はサイズ(3,4,11)の3次元整数配列として与えましょう。
各マスで11チャネルのうち1つだけが1、残りは0をとるようにします。&lt;/p&gt;
&lt;p&gt;次に持駒ですが、持駒になるのはひよこ、ぞう、きりんの3種のみ。各最大2枚。&lt;br&gt;
こちらは(2,3,2)の3次元配列とします。次元は順に、自分か相手か、駒の種類、持駒の1枚目または2枚目、を表し、値はいずれも0または1です。&lt;/p&gt;
&lt;p&gt;入力は合わせて144ノード。ちょっと冗長すぎる気はしますが、ひとまず気にせず進めましょう。&lt;/p&gt;
&lt;h3&gt;出力：可能な指し手を網羅する&lt;/h3&gt;
&lt;p&gt;どうぶつしょうぎの指し手は、(1)駒の移動、(2)駒打ち、の2種類があります。&lt;br&gt;
これらは任意の局面に対して、&lt;br&gt;
(1)「動かす駒の位置」「移動後の位置」「成るか、成らないか」&lt;br&gt;
(2)「打つ駒の種類」「打つ位置」&lt;br&gt;
を与えると一意に決められます。&lt;br&gt;
一番強い駒であるライオンでも、盤の端から端まで一手で移動などはできないため、(1)には制限があります。実際に合法でありうる動きは61通り。(2)は単純に、打てる駒3種（ひよこ、ぞう、きりん）と打ち場所3x4で36通り。&lt;br&gt;
合わせて&lt;strong&gt;合法手の可能性は97通り&lt;/strong&gt;です。
ですからネットワークは、&lt;strong&gt;97ノードのソフトマックスを出力とすればよい&lt;/strong&gt; ことになります。&lt;/p&gt;
&lt;h3&gt;今回使ったネットワーク&lt;/h3&gt;
&lt;p&gt;入力と出力が決まったので、あとは工夫しだい。
今回は適当に、こんなネットワークでやってみます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;Layer (type)                     Output Shape          Param #     Connected to                     &lt;/span&gt;
&lt;span class="err"&gt;====================================================================================================&lt;/span&gt;
&lt;span class="err"&gt;input_1 (InputLayer)             (None, 3, 4, 11)      0                                            &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;input_2 (InputLayer)            (None, 2, 3, 2)       0                                            &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;flatten_1 (Flatten)              (None, 132)           0           input_1[0][0]                    &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;flatten_2 (Flatten)             (None, 12)            0           input_2[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;concatenate_1 (Concatenate)      (None, 144)           0           flatten_1[0][0]                  &lt;/span&gt;
&lt;span class="err"&gt;                                                                   flatten_2[0][0]                 &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_1 (Dense)                 (None, 128)           18560       concatenate_1[0][0]              &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_2 (Dense)                 (None, 128)           16512       dense_1[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_3 (Dense)                 (None, 128)           16512       dense_2[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_4 (Dense)                 (None, 128)           16512       dense_3[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_5 (Dense)                 (None, 128)           16512       dense_4[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_6 (Dense)                 (None, 128)           16512       dense_5[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;span class="err"&gt;dense_7 (Dense)                 (None, 97)            12513       dense_6[0][0]                   &lt;/span&gt;
&lt;span class="err"&gt;====================================================================================================&lt;/span&gt;
&lt;span class="err"&gt;Total params: 113,633&lt;/span&gt;
&lt;span class="err"&gt;Trainable params: 113,633&lt;/span&gt;
&lt;span class="err"&gt;Non-trainable params: 0&lt;/span&gt;
&lt;span class="err"&gt;____________________________________________________________________________________________________&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;input_1とinput_2がそれぞれ盤面と持駒の入力です。中間層6層、活性化関数は途中全てReLU、最後はsoftmax。パラメータ数は11万余り。&lt;br&gt;
盤が小さいので、畳み込みも使わず全て全結合にしています。本将棋に拡張する場合は、畳み込みを使った方がいいでしょう。&lt;/p&gt;
&lt;h2&gt;強化学習：自己対戦と指し手評価&lt;/h2&gt;
&lt;p&gt;さて、ようやく本番の学習。基本は、自己対戦の結果による指し手評価です。&lt;/p&gt;
&lt;p&gt;そのためには、&lt;strong&gt;審判・履歴機能付きのどうぶつしょうぎ盤セット&lt;/strong&gt; をPythonのクラスとして実装することが必要です。実は全体の中でここが一番面倒なのですが、別に面白くはないので割愛。数時間頑張れば、動くものは作れます。そう、Pythonならね。&lt;/p&gt;
&lt;p&gt;自己対戦学習は多少試行錯誤して、いくつか工夫しました。これが良いかはよくわかりませんが。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初期配置からいきなり自己対戦するのではなく、勝負がつかない範囲でランダムに数手〜数十手進めた局面から開始。&lt;/li&gt;
&lt;li&gt;出力中の反則手は無視し、合法手の中で、スコアに比例した確率で指す。&lt;/li&gt;
&lt;li&gt;自己対戦の終局後、勝者側の指し手全てを教師信号としてネットワークを学習する。&lt;/li&gt;
&lt;li&gt;敗者側の指し手は無視し、減点しない。また反則スコアが高くても減点しない。&lt;br&gt;
  （褒めて伸ばす。初期局面が敗勢だとどうしようもないから、という理由もあり。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は2^17局の自己対戦を行い、終局ごとに学習させました。1局あたりの平均手数は20手、このうち勝者側のみを学習するので、延べ130万局面程度を学習したことになります。&lt;br&gt;
計算は全てノートPC上で行い、計算時間は45分程度でした。&lt;/p&gt;
&lt;h2&gt;学習結果&lt;/h2&gt;
&lt;h3&gt;ルールの習得&lt;/h3&gt;
&lt;p&gt;まず、学習したネットワークはどうぶつしょうぎのルール（合法手の規則）をどれくらい学んでいるのか？を検証してみます。&lt;br&gt;
ランダムに指して生成した局面で、ルールの制限を外して自由に指させてみたところ、じつに &lt;strong&gt;合法手が98.7%&lt;/strong&gt; となりました。1.3%の指し手が反則です。&lt;br&gt;
これら局面での合法手は、平均して局面あたり6.5手程度しかありません。97手からランダムに指せば殆どが反則、合法手は7%にも満たないはず。&lt;br&gt;
ルールについてはかなり良く習得してきていることがわかります。&lt;/p&gt;
&lt;h3&gt;どれくらい強い？&lt;/h3&gt;
&lt;p&gt;自分で対戦してみたいところなのですが、インターフェースを作っていないのと客観性のため、学習前のランダムなネットワークと対戦させてみます。揺らぎが1%程度未満になるように、2^14局連続で対戦。先手後手はランダムです。  &lt;/p&gt;
&lt;p&gt;結果は、、、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勝率 53% !!!!!!&lt;/strong&gt; (´･ω･`)&lt;/p&gt;
&lt;p&gt;んと、、、まず、この数字は十分に有意であるといえます（ｷﾘｯ）。&lt;br&gt;
ランダムに指すのと比べて、確実に強いです。&lt;br&gt;
しかし、、この程度では、まだ人間と勝負できるレベルでないことも明らかでしょう。&lt;/p&gt;
&lt;p&gt;原因についてはネットワーク設計に問題がある可能性もありますが、おそらく学習量が全然足りないのだと思われます。&lt;br&gt;
強化学習の成長はゆっくりで、少しづつ高度な好手を順番に見出していく必要があります。  &lt;/p&gt;
&lt;p&gt;例えばまず最初に、ライオンが取れるときは取るのが好手だ、ということを学ぶ。すると、駒が多いとライオンを取れる機会も増えるので、駒を取るのがいいことを学ぶ。多分まだ、最初の段階の途中くらいと想像できます。&lt;br&gt;
そういうことを考えると、130万局面を評価した段階での勝率53%は、それなりに納得できる数字かもしれません。&lt;/p&gt;
&lt;p&gt;今回はノートPC上で1時間足らずの学習なので、また時間ができたらもっと大規模にやってみたいと思います。
自己対戦部分をCythonで高速化して、GPUサーバ上で学習するとか。&lt;/p&gt;
&lt;p&gt;ひとまず今回はここまで。おしまい。&lt;/p&gt;
&lt;h3&gt;追記1&lt;/h3&gt;
&lt;p&gt;強化学習をさらに2倍、総計2&lt;sup&gt;18&lt;/sup&gt;局の自己対戦まで行わせたところ、合法手率86.0%、学習前ネットワークに対する勝率51.7%までそれぞれ暴落。何が起こっているのか、やっぱりよくわかりません。学習方法をもう少し検討するとか、あとはやはりもっと計算資源を投入する必要はありそうですかね。&lt;/p&gt;
&lt;h3&gt;追記2&lt;/h3&gt;
&lt;p&gt;強化学習の方法についてですが、碁と将棋の違いとして、特に棋力が低い場合、将棋では終盤（終局間際）の指し手が勝敗に圧倒的に重要、ということがあるかもしれません。&lt;br&gt;
今の場合、最初はライオン取りを学ぶことが必要なのですが、最後にライオンを取るまでにライオン取りを見逃した手なども教師信号になってしまいます。&lt;br&gt;
最初は最終手だけ学ぶなどと人為的に重みをいじった方が、今のレベルでは良い結果が出るかも。王道は、マシンパワーの力尽くなのでしょうが。。&lt;/p&gt;</content><category term="Blog"></category><category term="Machine Learning"></category></entry></feed>